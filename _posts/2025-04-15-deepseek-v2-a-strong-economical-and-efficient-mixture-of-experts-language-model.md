---
layout: post
title: "DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model"
date: 2024-05-07 15:56:43
author: "DeepSeek AI"
categories: "Language-Models"
tags: ["Multi-Head-Latent-Attention", "DeepSeekMoE", "Device-Limited-Routing", "Low-Rank-Key-Value-Joint-Compression", "Decoupled-Rotary-Position-Embedding", "Auxiliary-Loss-for-Load-Balance", "Token-Dropping-Strategy", "Expert-Parallelism", "Sparse-Computation-Mechanism", "Efficient-Long-Context-Attention-Mechanism"]
cover: /assets/images/language-models.jpg
use_math: true
---
### TL;DR
#### 이 연구를 시작하게 된 배경과 동기는 무엇입니까?

대규모 언어 모델(Large Language Models, LLMs)의 발전은 인공지능 분야에서 혁명적인 변화를 가져오고 있습니다. 최근 몇 년간 언어 모델의 성능은 파라미터 수의 증가에 따라 급격히 향상되었으며, 이는 '출현적 능력(emergent capabilities)'이라는 현상으로 설명됩니다. 그러나 이러한 성능 향상은 막대한 계산 자원과 훈련 비용을 필요로 하며, 추론 처리량의 감소라는 중요한 한계점을 동반합니다.

이러한 도전 과제는 대규모 언어 모델의 광범위한 채택과 실제 응용을 제한하는 주요 장애물이 되고 있습니다. 특히 모델의 규모가 커질수록 훈련 및 추론에 필요한 계산 비용이 기하급수적으로 증가하며, 이는 AI 기술의 실용화를 저해하는 중요한 문제로 대두되고 있습니다. 따라서 높은 성능을 유지하면서도 경제적이고 효율적인 언어 모델을 개발하는 것이 연구자들의 핵심 관심사가 되었습니다.

#### 이 연구에서 제시하는 새로운 해결 방법은 무엇입니까?

DeepSeek-V2는 이러한 문제를 해결하기 위해 두 가지 혁신적인 기술을 제안합니다. 첫째, 다중 헤드 잠재 어텐션(Multi-head Latent Attention, MLA)은 키-값(Key-Value) 캐시의 크기를 획기적으로 줄이면서도 모델의 성능을 유지하거나 오히려 향상시키는 새로운 어텐션 메커니즘입니다. 이 기술은 저차원 압축 기법을 통해 추론 시 메모리 사용량을 크게 줄이고 처리 속도를 향상시킵니다.

둘째, DeepSeekMoE(Mixture-of-Experts) 아키텍처는 피드포워드 네트워크의 전문가 분할 방식을 혁신적으로 개선했습니다. 세밀한 전문가 분할과 공유 전문가 격리 전략을 통해, 모델은 더 적은 계산 비용으로 높은 성능을 달성할 수 있게 되었습니다. 이 접근법은 기존의 혼합 전문가 모델보다 더 효율적이고 경제적인 모델 훈련을 가능하게 합니다.

#### 제안된 방법은 어떻게 구현되었습니까?

DeepSeek-V2는 총 236B의 파라미터를 가진 대규모 언어 모델로, 각 토큰에 대해 21B의 파라미터가 활성화됩니다. 모델은 8.1T 토큰으로 구성된 고품질 다중 소스 사전 훈련 코퍼스를 사용하여 훈련되었으며, 특히 중국어 데이터에 대한 확장된 데이터 양과 품질에 중점을 두었습니다. 사전 훈련 후에는 1.5M의 대화 세션을 사용하여 지도 미세 조정(Supervised Fine-Tuning, SFT)을 수행했습니다.

MLA 구현에서는 저차원 키-값 공동 압축 기법을 사용하여 어텐션 메커니즘의 효율성을 높였습니다. 분리된 회전 위치 임베딩(RoPE) 전략을 통해 추론 시 키-값 캐시 계산의 오버헤드를 줄였습니다. DeepSeekMoE는 2개의 공유 전문가와 160개의 라우팅된 전문가로 구성되며, 각 토큰에 대해 6개의 전문가가 활성화되도록 설계되었습니다.

#### 이 연구의 결과가 가지는 의미는 무엇입니까?

DeepSeek-V2는 오픈소스 언어 모델 중 최고 수준의 성능을 달성하면서도 훈련 비용을 42.5% 절감하고, KV 캐시를 93.3% 줄이며, 최대 생성 처리량을 5.76배 향상시켰습니다. 특히 영어와 중국어 벤치마크에서 Qwen1.5 72B, LLaMA3 70B, Mixtral 8x22B와 같은 최첨단 모델들을 능가하는 성과를 보였습니다.

이 연구는 대규모 언어 모델의 계산 효율성과 성능 사이의 균형을 새롭게 정의했다는 점에서 중요한 의미를 가집니다. 혼합 전문가 아키텍처와 혁신적인 어텐션 메커니즘을 통해, 더 적은 계산 자원으로 더 높은 성능을 달성할 수 있음을 입증했습니다. 또한 오픈소스 커뮤니티에 DeepSeek-V2-Lite와 같은 경량화된 모델을 제공함으로써 AI 기술의 접근성과 확산에 기여하고 있습니다.
- - -
# DeepSeek-V2: 강력하고 경제적이며 효율적인 혼합 전문가 언어 모델

## 소개

최근 몇 년간 대규모 언어 모델(Large Language Models, LLMs)은 급속한 발전을 이루어 인공 일반 지능(Artificial General Intelligence, AGI)의 시대를 엿볼 수 있게 해주었습니다. 일반적으로 언어 모델의 지능은 파라미터 수가 증가함에 따라 향상되는 경향이 있으며, 이를 통해 다양한 작업에서 새로운 능력을 발현할 수 있게 됩니다. 이러한 현상은 Wei 등이 2022년에 발표한 연구에서 '출현적 능력(emergent capabilities)'이라고 불리는 특성으로, 모델 규모가 특정 임계점을 넘어서면 갑자기 나타나는 능력을 의미합니다. 그러나 이러한 개선은 훈련에 더 많은 컴퓨팅 자원을 필요로 하고 추론 처리량이 감소할 수 있다는 비용을 수반합니다. 이러한 제약은 LLM의 광범위한 채택과 활용을 방해하는 중요한 도전 과제입니다.

이러한 문제를 해결하기 위해 DeepSeek-V2가 개발되었습니다. DeepSeek-V2는 혁신적인 트랜스포머 아키텍처를 통해 경제적인 훈련과 효율적인 추론을 특징으로 하는 강력한 오픈소스 혼합 전문가(Mixture-of-Experts, MoE) 언어 모델입니다. 이 모델은 총 236B 파라미터를 갖추고 있으며, 각 토큰에 대해 21B 파라미터가 활성화되고 128K 토큰의 컨텍스트 길이를 지원합니다.

DeepSeek-V2는 제안된 다중 헤드 잠재 어텐션(Multi-head Latent Attention, MLA)과 DeepSeekMoE라는 혁신적인 아키텍처를 통해 트랜스포머 프레임워크 내의 어텐션 모듈과 피드포워드 네트워크(Feed-Forward Networks, FFNs)를 최적화합니다.

### 다중 헤드 잠재 어텐션: 추론 효율성 향상

어텐션 메커니즘의 맥락에서, 다중 헤드 어텐션(Multi-Head Attention, MHA)의 키-값(Key-Value, KV) 캐시는 LLM의 추론 효율성에 중요한 장애물이 됩니다. 이 문제를 해결하기 위해 그룹 쿼리 어텐션(Grouped-Query Attention, GQA)과 다중 쿼리 어텐션(Multi-Query Attention, MQA)과 같은 다양한 접근 방식이 탐색되었습니다. 그러나 이러한 방법들은 KV 캐시를 줄이려는 시도에서 종종 성능을 저하시킵니다.

두 가지 장점을 모두 달성하기 위해 DeepSeek-V2는 저차원 키-값 공동 압축을 갖춘 어텐션 메커니즘인 MLA를 도입합니다. 경험적으로 MLA는 MHA보다 우수한 성능을 달성하면서도 추론 중 KV 캐시를 크게 줄여 추론 효율성을 향상시킵니다.

### DeepSeekMoE: 경제적 비용으로 강력한 모델 훈련

피드포워드 네트워크(FFNs)의 경우, DeepSeek-V2는 세밀한 전문가 분할과 공유 전문가 격리를 채택하여 전문가 특수화에서 더 높은 잠재력을 제공하는 DeepSeekMoE 아키텍처를 따릅니다. DeepSeekMoE 아키텍처는 GShard와 같은 기존의 MoE 아키텍처와 비교하여 큰 이점을 보여주어 경제적인 비용으로 강력한 모델을 훈련할 수 있게 합니다. 훈련 중에 전문가 병렬 처리를 사용함에 따라 통신 오버헤드를 제어하고 부하 균형을 보장하기 위한 보조 메커니즘도 고안되었습니다.

이 두 기술을 결합함으로써 DeepSeek-V2는 강력한 성능, 경제적인 훈련 비용, 효율적인 추론 처리량을 동시에 제공합니다. 아래 왼쪽 그림에서 볼 수 있듯이, DeepSeek-V2는 MMLU에서 활성화된 파라미터 수가 적음에도 불구하고 최고 수준의 성능을 달성합니다. 또한 아래 오른쪽 그림에서 보여주듯이, DeepSeek 67B와 비교하여 DeepSeek-V2는 훈련 비용을 42.5% 절감하고, KV 캐시를 93.3% 줄이며, 최대 생성 처리량을 5.76배 향상시킵니다.

![그림 1: (a) 다양한 오픈소스 모델 간의 활성화된 파라미터 대비 MMLU 정확도. (b) DeepSeek 67B(Dense)와 DeepSeek-V2의 훈련 비용 및 추론 효율성.](/assets/2025-04-15-deepseek-v2-a-strong-economical-and-efficient-mixture-of-experts-language-model/1.png)

DeepSeek-V2는 8.1T 토큰으로 구성된 고품질의 다중 소스 사전 훈련 코퍼스를 구축합니다. DeepSeek 67B(이전 릴리스)에 사용된 코퍼스와 비교하여, 이 코퍼스는 특히 중국어 데이터와 같은 확장된 데이터 양과 더 높은 데이터 품질을 특징으로 합니다. 먼저 전체 사전 훈련 코퍼스에서 DeepSeek-V2를 사전 훈련합니다. 그런 다음 수학, 코드, 글쓰기, 추론, 안전 등 다양한 영역을 포괄하는 1.5M 대화 세션을 수집하여 DeepSeek-V2 Chat(SFT)에 대한 지도 미세 조정(Supervised Fine-Tuning, SFT)을 수행합니다. 마지막으로 DeepSeekMath를 따라 그룹 상대 정책 최적화(Group Relative Policy Optimization, GRPO)를 사용하여 모델을 인간 선호도와 더 잘 일치시키고 DeepSeek-V2 Chat(RL)을 생성합니다.

![그림 2: DeepSeek-V2의 아키텍처 도식. MLA는 생성을 위한 KV 캐시를 크게 줄여 효율적인 추론을 보장하고, DeepSeekMoE는 희소 아키텍처를 통해 경제적인 비용으로 강력한 모델을 훈련할 수 있게 합니다.](/assets/2025-04-15-deepseek-v2-a-strong-economical-and-efficient-mixture-of-experts-language-model/2.png)

DeepSeek-V2는 영어와 중국어로 다양한 벤치마크에서 평가되었으며, 대표적인 오픈소스 모델과 비교되었습니다. 평가 결과에 따르면 활성화된 파라미터가 21B에 불과함에도 불구하고 DeepSeek-V2는 오픈소스 모델 중 최고 수준의 성능을 달성하고 가장 강력한 오픈소스 MoE 언어 모델이 되었습니다.

또한 DeepSeek-V2 Chat(SFT)와 DeepSeek-V2 Chat(RL)을 개방형 벤치마크에서 평가했습니다. 특히 DeepSeek-V2 Chat(RL)은 AlpacaEval 2.0에서 38.9의 길이 제어 승률, MT-Bench에서 8.97의 전체 점수, AlignBench에서 7.91의 전체 점수를 달성했습니다. 영어 개방형 대화 평가는 DeepSeek-V2 Chat(RL)이 오픈소스 채팅 모델 중 최고 수준의 성능을 보여줌을 입증합니다. 또한 AlignBench에 대한 평가는 중국어에서 DeepSeek-V2 Chat(RL)이 모든 오픈소스 모델을 능가하고 대부분의 비공개 모델도 능가한다는 것을 보여줍니다.

MLA와 DeepSeekMoE에 대한 추가 연구 및 개발을 촉진하기 위해, 오픈소스 커뮤니티를 위해 MLA와 DeepSeekMoE를 갖춘 더 작은 모델인 DeepSeek-V2-Lite도 공개합니다. 이 모델은 총 15.7B 파라미터를 가지고 있으며, 각 토큰에 대해 2.4B 파라미터가 활성화됩니다.

이 논문의 나머지 부분에서는 먼저 DeepSeek-V2의 모델 아키텍처에 대한 자세한 설명을 제공합니다. 이어서 훈련 데이터 구성, 하이퍼파라미터 설정, 인프라, 긴 컨텍스트 확장, 모델 성능 및 효율성 평가를 포함한 사전 훈련 노력을 소개합니다. 그 다음으로 지도 미세 조정(SFT), 강화 학습(RL), 평가 결과 및 기타 논의를 포함하는 정렬 노력을 보여줍니다. 마지막으로 결론을 요약하고 DeepSeek-V2의 현재 한계에 대해 논의하며 향후 작업을 설명합니다.

## 아키텍처

DeepSeek-V2는 기본적으로 [Vaswani와 연구진](https://arxiv.org/pdf/1706.03762v7)이 제안한 트랜스포머 아키텍처를 따르고 있습니다. 트랜스포머 블록은 어텐션 모듈과 피드포워드 네트워크(Feed-Forward Network, FFN)로 구성되어 있습니다. 그러나 DeepSeek-V2는 어텐션 모듈과 FFN 모두에 혁신적인 아키텍처를 도입하여 기존 트랜스포머의 한계를 극복하고자 했습니다.

### 다중 헤드 잠재 어텐션(MLA)

어텐션 모듈에서는 다중 헤드 잠재 어텐션(Multi-head Latent Attention, MLA)을 설계하여 사용합니다. MLA는 저차원 키-값 공동 압축(low-rank key-value joint compression) 기법을 활용하여 추론 시간에 병목 현상을 일으키는 키-값 캐시의 문제를 해결합니다. 이를 통해 효율적인 추론이 가능해집니다.

기존 트랜스포머의 다중 헤드 어텐션(Multi-Head Attention, MHA)은 다음과 같이 정의됩니다.

\\[
\text{MultiHead}(Q, K, V) = \text{Concat}(\text{head}_1, \ldots, \text{head}_h)W^O
\\]

여기서 각 헤드는 \\(\text{head}_i = \text{Attention}(QW_i^Q, KW_i^K, VW_i^V)\\)로 계산되며, 어텐션 함수는 스케일된 닷-프로덕트 어텐션입니다.

\\[
\text{Attention}(Q, K, V) = \text{softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right)V
\\]

MLA는 이러한 기존 어텐션 메커니즘을 개선하여 키-값 캐시의 크기를 줄이면서도 성능을 유지하거나 향상시키는 방식으로 설계되었습니다. 저차원 키-값 공동 압축 기법을 통해 추론 시 메모리 사용량을 크게 줄이고 처리 속도를 향상시킵니다.

### DeepSeekMoE

FFN에 대해서는 [Dai와 연구진](https://arxiv.org/pdf/2401.06066v1)이 제안한 DeepSeekMoE 아키텍처를 채택했습니다. DeepSeekMoE는 고성능 혼합 전문가(Mixture-of-Experts, MoE) 아키텍처로, 경제적인 비용으로 강력한 모델을 훈련할 수 있게 합니다.

DeepSeekMoE는 두 가지 주요 혁신을 통해 전문가 특수화를 극대화합니다.

1. 세밀한 전문가 분할(Fine-Grained Expert Segmentation): FFN의 중간 은닉 차원을 분할하여 전문가를 더 세밀한 단위로 나눕니다. 이에 따라 더 많은 수의 전문가가 활성화되어 더 유연하고 적응력 있는 조합이 가능해집니다. 이를 통해 다양한 지식이 서로 다른 전문가에게 더 정확하게 분해되고 학습될 수 있어 전문화가 향상됩니다.

2. 공유 전문가 격리(Shared Expert Isolation): 특정 전문가들을 항상 활성화되는 공유 전문가로 격리시킵니다. 이러한 공유 전문가들은 다양한 맥락에서 공통적인 지식을 포착하고 통합하는 역할을 합니다. 공통 지식을 이러한 공유 전문가에 압축함으로써 다른 라우팅된 전문가 간의 중복성이 줄어들고, 파라미터 효율성이 향상되며 각 라우팅된 전문가가 고유한 측면에 집중할 수 있게 됩니다.

DeepSeekMoE 레이어의 출력은 다음과 같이 수식화됩니다.

\\[
\mathbf{h}\_{t}^{l} = \sum_{i=1}^{K_{s}}{\operatorname{FFN}\_{i}\left(\mathbf{u}\_{t}^{l}\right)}+\sum_{i=K_{s}+1}^{mN}\left({g_{i,t}\operatorname{FFN}\_{i}\left(\mathbf{u}\_{t}^{l}\right)}\right)+\mathbf{u}_{t}^{l}
\\]

여기서 \\(K_{s}\\)는 공유 전문가의 수를 나타내고, \\(m\\)은 전문가 세그먼트의 수, \\(N\\)은 전체 전문가의 수, \\(g_{i,t}\\)는 \\(i\\)번째 전문가에 대한 게이팅 값을 나타냅니다.

### 아키텍처 개요

아래 그림은 DeepSeek-V2의 아키텍처를 도식화하여 보여줍니다. 이 그림에서 볼 수 있듯이, MLA는 생성 과정에서 KV 캐시를 크게 줄여 효율적인 추론을 보장하고, DeepSeekMoE는 희소 아키텍처를 통해 경제적인 비용으로 강력한 모델을 훈련할 수 있게 합니다.

![그림 2: DeepSeek-V2의 아키텍처 도식. MLA는 생성을 위한 KV 캐시를 크게 줄여 효율적인 추론을 보장하고, DeepSeekMoE는 희소 아키텍처를 통해 경제적인 비용으로 강력한 모델을 훈련할 수 있게 합니다.](/assets/2025-04-15-deepseek-v2-a-strong-economical-and-efficient-mixture-of-experts-language-model/2.png)

기타 세부 사항(예: 레이어 정규화 및 FFN의 활성화 함수)에 대해서는 특별히 명시되지 않는 한, DeepSeek-V2는 [DeepSeek-AI](https://arxiv.org/pdf/2401.02954v1)가 개발한 DeepSeek 67B의 설정을 따릅니다.

이러한 혁신적인 아키텍처 설계를 통해 DeepSeek-V2는 강력한 성능, 경제적인 훈련 비용, 효율적인 추론 처리량이라는 세 가지 목표를 동시에 달성할 수 있게 되었습니다. MLA는 추론 시 KV 캐시의 크기를 크게 줄여 메모리 효율성을 높이고 처리 속도를 향상시키며, DeepSeekMoE는 희소 활성화를 통해 계산 효율성을 높이면서도 모델의 표현력을 유지합니다.

## 다중 헤드 잠재 어텐션: 추론 효율성 향상

기존의 트랜스포머 모델은 일반적으로 [Vaswani와 연구진](https://arxiv.org/pdf/1706.03762v7)이 제안한 다중 헤드 어텐션(Multi-Head Attention, MHA)을 채택하고 있습니다. 그러나 텍스트 생성 과정에서 MHA의 무거운 키-값(Key-Value, KV) 캐시는 추론 효율성을 제한하는 병목 현상이 됩니다. KV 캐시를 줄이기 위해 다중 쿼리 어텐션(Multi-Query Attention, MQA)과 그룹 쿼리 어텐션(Grouped-Query Attention, GQA)이 제안되었습니다. 이러한 방법들은 KV 캐시의 크기를 줄일 수 있지만, 성능 면에서는 MHA에 미치지 못합니다(MHA, GQA, MQA의 비교 실험은 부록에 제공되어 있습니다).

DeepSeek-V2에서는 다중 헤드 잠재 어텐션(Multi-head Latent Attention, MLA)이라는 혁신적인 어텐션 메커니즘을 설계했습니다. 저차원 키-값 공동 압축 기법을 갖춘 MLA는 MHA보다 더 나은 성능을 달성하면서도 KV 캐시의 양을 크게 줄일 수 있습니다. 다음에서는 MLA의 아키텍처를 소개하고, 부록에서는 MLA와 MHA의 비교를 제공합니다.

### 기본 개념: 표준 다중 헤드 어텐션

먼저 배경 지식으로 표준 MHA 메커니즘을 소개하겠습니다. \\(d\\)를 임베딩 차원, \\(n_h\\)를 어텐션 헤드 수, \\(d_h\\)를 헤드당 차원, \\(\mathbf{h}_t \in \mathbb{R}^d\\)를 어텐션 레이어에서 \\(t\\)번째 토큰의 어텐션 입력이라고 합시다. 표준 MHA는 먼저 세 개의 행렬 \\(\mathbf{W}^Q, \mathbf{W}^K, \mathbf{W}^V \in \mathbb{R}^{d_h n_h \times d}\\)를 통해 \\(\mathbf{q}_t, \mathbf{k}_t, \mathbf{v}_t \in \mathbb{R}^{d_h n_h}\\)를 생성합니다.

\\[
\begin{array}{l}
\mathbf{q}_t = \mathbf{W}^Q \mathbf{h}_t, \\
\mathbf{k}_t = \mathbf{W}^K \mathbf{h}_t, \\
\mathbf{v}_t = \mathbf{W}^V \mathbf{h}_t,
\end{array}
\\]

그런 다음, \\(\mathbf{q}_t, \mathbf{k}_t, \mathbf{v}_t\\)는 다중 헤드 어텐션 계산을 위해 \\(n_h\\)개의 헤드로 분할됩니다.

\\[
\begin{array}{l}
[\mathbf{q}\_{t,1}; \mathbf{q}\_{t,2}; \ldots; \mathbf{q}\_{t,n_h}] = \mathbf{q}_t, \\
[\mathbf{k}\_{t,1}; \mathbf{k}\_{t,2}; \ldots; \mathbf{k}\_{t,n_h}] = \mathbf{k}_t, \\
[\mathbf{v}\_{t,1}; \mathbf{v}\_{t,2}; \ldots; \mathbf{v}\_{t,n_h}] = \mathbf{v}_t,
\end{array}
\\]

\\[
\mathbf{o}\_{t,i} = \sum_{j=1}^{t} \text{Softmax}\_j \left( \frac{\mathbf{q}\_{t,i}^T \mathbf{k}_{j,i}}{\sqrt{d_h}} \right) \mathbf{v}\_{j,i},
\\]

\\[
\mathbf{u}\_t = \mathbf{W}^O [\mathbf{o}\_{t,1}; \mathbf{o}\_{t,2}; \ldots; \mathbf{o}_{t,n_h}],
\\]

여기서 \\(\mathbf{q}\_{t,i}, \mathbf{k}_{t,i}, \mathbf{v}\_{t,i} \in \mathbb{R}^{d_h}\\)는 각각 \\(i\\)번째 어텐션 헤드의 쿼리, 키, 값을 나타내며, \\(\mathbf{W}^O \in \mathbb{R}^{d \times d_h n_h}\\)는 출력 투영 행렬입니다.

추론 과정에서는 모든 키와 값을 캐싱하여 추론 속도를 높여야 하므로, MHA는 각 토큰마다 \\(2n_h d_h l\\) 개의 요소를 캐싱해야 합니다. 모델 배포 시, 이러한 무거운 KV 캐시는 최대 배치 크기와 시퀀스 길이를 제한하는 큰 병목 현상이 됩니다.

### 저차원 키-값 공동 압축

MLA의 핵심은 KV 캐시를 줄이기 위한 저차원 키-값 공동 압축입니다.

\\[
\begin{array}{l}
\mathbf{c}_t^{KV} = \mathbf{W}^{DKV} \mathbf{h}_t, \\
\mathbf{k}_t^C = \mathbf{W}^{UK} \mathbf{c}_t^{KV}, \\
\mathbf{v}_t^C = \mathbf{W}^{UV} \mathbf{c}_t^{KV},
\end{array}
\\]

여기서 \\(\mathbf{c}_t^{KV} \in \mathbb{R}^{d_c}\\)는 키와 값을 위한 압축된 잠재 벡터입니다. \\(d_c\\)(\\(\ll d_h n_h\\))는 KV 압축 차원을 나타내며, \\(\mathbf{W}^{DKV} \in \mathbb{R}^{d_c \times d}\\)는 다운-투영 행렬이고, \\(\mathbf{W}^{UK}, \mathbf{W}^{UV} \in \mathbb{R}^{d_h n_h \times d_c}\\)는 각각 키와 값을 위한 업-투영 행렬입니다.

추론 과정에서 MLA는 \\(\mathbf{c}_t^{KV}\\)만 캐싱하면 되므로, KV 캐시는 \\(d_c l\\) 요소만 필요합니다(여기서 \\(l\\)은 레이어 수를 나타냅니다).

또한 추론 과정에서 \\(\mathbf{W}^{UK}\\)는 \\(\mathbf{W}^Q\\)에 흡수될 수 있고, \\(\mathbf{W}^{UV}\\)는 \\(\mathbf{W}^O\\)에 흡수될 수 있기 때문에, 어텐션을 위해 키와 값을 계산할 필요조차 없습니다. 아래 그림은 MLA의 KV 공동 압축이 어떻게 KV 캐시를 줄이는지 직관적으로 보여줍니다.

![그림 3 다중 헤드 어텐션(MHA), 그룹 쿼리 어텐션(GQA), 다중 쿼리 어텐션(MQA), 다중 헤드 잠재 어텐션(MLA)의 간소화된 도식. 키와 값을 잠재 벡터로 공동 압축함으로써, MLA는 추론 과정에서 KV 캐시를 크게 줄입니다.](/assets/2025-04-15-deepseek-v2-a-strong-economical-and-efficient-mixture-of-experts-language-model/3.png)

또한 훈련 중 활성화 메모리를 줄이기 위해, KV 캐시를 줄일 수는 없지만 쿼리에 대해서도 저차원 압축을 수행합니다.

\\[
\begin{array}{c}
\mathbf{c}_t^Q = \mathbf{W}^{DQ} \mathbf{h}_t, \\
\mathbf{q}_t^C = \mathbf{W}^{UQ} \mathbf{c}_t^Q,
\end{array}
\\]

여기서 \\(\mathbf{c}_t^Q \in \mathbb{R}^{d'_c}\\)는 쿼리를 위한 압축된 잠재 벡터입니다. \\(d'_c\\)(\\(\ll d_h n_h\\))는 쿼리 압축 차원을 나타내며, \\(\mathbf{W}^{DQ} \in \mathbb{R}^{d'_c \times d}, \mathbf{W}^{UQ} \in \mathbb{R}^{d_h n_h \times d'_c}\\)는 각각 쿼리를 위한 다운-투영 및 업-투영 행렬입니다.

### 분리된 회전 위치 임베딩

DeepSeek 67B([DeepSeek-AI, 2024](https://arxiv.org/pdf/2401.02954v1))를 따라, DeepSeek-V2에서는 회전 위치 임베딩(Rotary Position Embedding, RoPE)([Su 등, 2024](https://arxiv.org/pdf/2104.09864))을 사용하고자 합니다. 그러나 RoPE는 저차원 KV 압축과 호환되지 않습니다. 구체적으로, RoPE는 키와 쿼리 모두에 대해 위치에 민감합니다. 만약 키 \\(\mathbf{k}_t^C\\)에 RoPE를 적용하면, \\(\mathbf{W}^{UK}\\)는 위치에 민감한 RoPE 행렬과 결합됩니다. 이렇게 되면 \\(\mathbf{W}^{UK}\\)는 더 이상 \\(\mathbf{W}^Q\\)에 흡수될 수 없게 됩니다. 왜냐하면 현재 생성 중인 토큰과 관련된 RoPE 행렬이 \\(\mathbf{W}^Q\\)와 \\(\mathbf{W}^{UK}\\) 사이에 위치하게 되고, 행렬 곱셈은 교환 법칙을 따르지 않기 때문입니다. 결과적으로 추론 과정에서 모든 접두사 토큰에 대한 키를 다시 계산해야 하며, 이는 추론 효율성을 크게 저하시킬 것입니다.

해결책으로, 분리된 RoPE 전략을 제안합니다. 이 전략은 RoPE를 전달하기 위해 추가적인 다중 헤드 쿼리 \\(\mathbf{q}_{t,i}^R \in \mathbb{R}^{d_h^R}\\)와 공유 키 \\(\mathbf{k}_t^R \in \mathbb{R}^{d_h^R}\\)를 사용합니다. 여기서 \\(d_h^R\\)는 분리된 쿼리와 키의 헤드당 차원을 나타냅니다. 분리된 RoPE 전략을 갖춘 MLA는 다음과 같은 계산을 수행합니다.

\\[
\begin{array}{l}
[\mathbf{q}\_{t,1}^R; \mathbf{q}\_{t,2}^R; \ldots; \mathbf{q}_{t,n_h}^R] = \mathbf{q}_t^R = \text{RoPE}(\mathbf{W}^{QR} \mathbf{c}_t^Q), \\
\mathbf{k}_t^R = \text{RoPE}(\mathbf{W}^{KR} \mathbf{h}_t),
\end{array}
\\]

\\[
\begin{array}{l}
\mathbf{q}\_{t,i} = [\mathbf{q}_{t,i}^C \cdot \mathbf{q}\_{t,i}^R], \\
\mathbf{k}\_{t,i} = [\mathbf{k}\_{t,i}^C; \mathbf{k}_t^R],
\end{array}
\\]

\\[
\mathbf{o}\_{t,i} = \sum_{j=1}^{t} \text{Softmax}\_j \left( \frac{\mathbf{q}\_{t,i}^T \mathbf{k}\_{j,i}}{\sqrt{d_h + d_h^R}} \right) \mathbf{v}_{j,i}^C,
\\]

\\[
\mathbf{u}\_t = \mathbf{W}^O [\mathbf{o}\_{t,1}; \mathbf{o}_{t,2}; \ldots; \mathbf{o}\_{t,n_h}],
\\]

여기서 \\(\mathbf{W}^{QR} \in \mathbb{R}^{d_h^R n_h \times d'_c}\\)와 \\(\mathbf{W}^{KR} \in \mathbb{R}^{d_h^R \times d}\\)는 각각 분리된 쿼리와 키를 생성하는 행렬입니다. \\(\text{RoPE}(\cdot)\\)는 RoPE 행렬을 적용하는 연산을 나타내며, \\([\cdot; \cdot]\\)은 연결(concatenation) 연산을 나타냅니다.

추론 과정에서 분리된 키도 캐싱되어야 합니다. 따라서 DeepSeek-V2는 총 \\((d_c + d_h^R)l\\) 요소를 포함하는 KV 캐시가 필요합니다.

MLA의 전체 계산 과정을 보여주기 위해, 부록에서 MLA의 전체 공식을 정리하여 제공합니다.

### 키-값 캐시 비교

아래 표에서는 다양한 어텐션 메커니즘 간의 토큰당 KV 캐시를 비교합니다. MLA는 단지 2.25개의 그룹을 가진 GQA와 동일한 적은 양의 KV 캐시만 필요로 하지만, MHA보다 더 강력한 성능을 달성할 수 있습니다.

| 어텐션 메커니즘 | 토큰당 KV 캐시 (요소 수) | 성능 |
|-----------------|--------------------------|------|
| 다중 헤드 어텐션 (MHA) | \\(2n_h d_h l\\) | 강함 |
| 그룹 쿼리 어텐션 (GQA) | \\(2n_g d_h l\\) | 중간 |
| 다중 쿼리 어텐션 (MQA) | \\(2d_h l\\) | 약함 |
| MLA (제안 방식) | \\((d_c + d_h^R)l\\) ~ \\(4.5d_h l\\) | 더 강함 |

다양한 어텐션 메커니즘 간의 토큰당 KV 캐시 비교. \\(n_h\\)는 어텐션 헤드 수, \\(d_h\\)는 어텐션 헤드당 차원, \\(l\\)은 레이어 수, \\(n_g\\)는 GQA의 그룹 수, \\(d_c\\)와 \\(d_h^R\\)은 각각 MLA의 KV 압축 차원과 분리된 쿼리와 키의 헤드당 차원을 나타냅니다. KV 캐시의 양은 저장 정밀도와 관계없이 요소 수로 측정됩니다. DeepSeek-V2의 경우, \\(d_c\\)는 \\(4d_h\\)로 설정되고 \\(d_h^R\\)은 1로 설정됩니다. 따라서 KV 캐시는 단지 2.25개의 그룹을 가진 GQA와 동일하지만, 성능은 MHA보다 더 강합니다.

## DeepSeekMoE: 경제적 비용으로 강력한 모델 훈련하기

### 기본 아키텍처

피드포워드 네트워크(FFN)에 대해서는 [Dai와 연구진](https://arxiv.org/pdf/2401.06066v1)이 제안한 DeepSeekMoE 아키텍처를 채택했습니다. DeepSeekMoE는 두 가지 핵심 아이디어를 기반으로 합니다. 전문가를 더 세밀한 단위로 분할하여 전문가 특수화와 정확한 지식 습득을 향상시키는 것과, 라우팅된 전문가 간의 지식 중복을 완화하기 위해 일부 공유 전문가를 격리하는 것입니다. 활성화된 전문가 파라미터와 총 전문가 파라미터의 수가 동일한 상황에서, DeepSeekMoE는 GShard([Lepikhin 등, 2021](https://arxiv.org/pdf/2006.16668v1))와 같은 기존 MoE 아키텍처보다 훨씬 뛰어난 성능을 보여줍니다.

\\(t\\)번째 토큰의 FFN 입력을 \\(\mathbf{u}_t\\)라고 할 때, FFN 출력 \\(\mathbf{h}_t\\)는 다음과 같이 계산됩니다.

\\[
\mathbf{h}\_{t}^{\prime}=\mathbf{u}\_{t}+\sum_{i=1}^{N_{s}}\operatorname{FFN}\_{i}^{(s)}\left(\mathbf{u}\_{t}\right)+\sum_{i=1}^{N_{r}}g_{i,t}\operatorname{FFN}\_{i}^{(r)}\left(\mathbf{u}_{t}\right),
\\]

\\[
g_{i,t} =
\begin{cases}
  s_{i,t}, & \text{if } s_{i,t} \in \mathrm{Topk}(\{s_{j,t}\}_{1 \le j \le N_r}, K_r) \\\\  
  0, & \text{otherwise}
\end{cases}
\\]

\\[
s_{i,t}=\mathrm{Softmax}\_{i}\left(\mathbf{u}\_{t}^{T}\mathbf{e}_{i}\right),
\\]

여기서 \\(N_s\\)와 \\(N_r\\)은 각각 공유 전문가와 라우팅된 전문가의 수를 나타냅니다. \\(\operatorname{FFN}\_{i}^{(s)}(\cdot)\\)과 \\(\operatorname{FFN}\_{i}^{(r)}(\cdot)\\)은 각각 \\(i\\)번째 공유 전문가와 \\(i\\)번째 라우팅된 전문가를 나타냅니다. \\(K_r\\)은 활성화된 라우팅 전문가의 수를 나타내며, \\(g_{i,t}\\)는 \\(i\\)번째 전문가에 대한 게이트 값입니다. \\(s_{i,t}\\)는 토큰-전문가 친화도(affinity)를 나타내고, \\(\mathbf{e}_i\\)는 이 레이어에서 \\(i\\)번째 라우팅된 전문가의 중심점(centroid)입니다. \\(\mathrm{Topk}(\cdot, K)\\)는 \\(t\\)번째 토큰과 모든 라우팅된 전문가 간에 계산된 친화도 점수 중 가장 높은 \\(K\\)개의 점수를 포함하는 집합을 나타냅니다.

### 디바이스 제한 라우팅

DeepSeek-V2에서는 MoE 관련 통신 비용을 제한하기 위해 디바이스 제한 라우팅 메커니즘을 설계했습니다. 전문가 병렬 처리가 사용될 때, 라우팅된 전문가들은 여러 디바이스에 분산됩니다. 각 토큰에 대해, MoE 관련 통신 빈도는 해당 토큰의 대상 전문가가 포함된 디바이스 수에 비례합니다. DeepSeekMoE의 세밀한 전문가 분할로 인해 활성화된 전문가 수가 많아질 수 있으므로, 전문가 병렬 처리를 적용할 경우 MoE 관련 통신 비용이 더 커질 수 있습니다.

DeepSeek-V2에서는 라우팅된 전문가의 단순한 상위 K 선택을 넘어, 각 토큰의 대상 전문가가 최대 \\(M\\)개의 디바이스에 분산되도록 추가로 보장합니다. 구체적으로, 각 토큰에 대해 먼저 가장 높은 친화도 점수를 가진 전문가가 있는 \\(M\\)개의 디바이스를 선택합니다. 그런 다음 이 \\(M\\)개의 디바이스에 있는 전문가들 중에서 상위 K 선택을 수행합니다. 실제로, \\(M \geq 3\\)일 때 디바이스 제한 라우팅이 제한되지 않은 상위 K 라우팅과 거의 비슷한 좋은 성능을 달성할 수 있음을 발견했습니다.

### 부하 균형을 위한 보조 손실

자동으로 학습된 라우팅 전략에 대해 부하 균형을 고려합니다. 첫째, 불균형한 부하는 라우팅 붕괴([Shazeer 등, 2017](https://arxiv.org/pdf/1701.06538v1))의 위험을 높여 일부 전문가가 충분히 훈련되고 활용되지 못하게 할 수 있습니다. 둘째, 전문가 병렬 처리가 사용될 때 불균형한 부하는 계산 효율성을 저하시킵니다. DeepSeek-V2 훈련 중에는 전문가 수준 부하 균형(\\(\mathcal{L}\_{\text{ExpBal}}\\)), 디바이스 수준 부하 균형(\\(\mathcal{L}\_{\text{DevBal}}\\)), 통신 균형(\\(\mathcal{L}_{\text{CommBal}}\\))을 제어하기 위한 세 가지 보조 손실을 설계했습니다.

#### 전문가 수준 균형 손실

라우팅 붕괴의 위험을 완화하기 위해 전문가 수준 균형 손실([Fedus 등, 2021](https://arxiv.org/pdf/2101.03961v3); [Lepikhin 등, 2021](https://arxiv.org/pdf/2006.16668v1))을 사용합니다.

\\[
\mathcal{L}\_{\text{ExpBal}}=\alpha_{1}\sum_{i=1}^{N_{r}}f_{i}P_{i},
\\]

\\[
f_{i}=\frac{1}{T}\sum_{t=1}^{T}\mathbf{1}(\text{Token }t\text{ selects Expert }i),
\\]

\\[
P_{i}=\frac{1}{T}\sum_{t=1}^{T}s_{i,t},
\\]

여기서 \\(\alpha_1\\)은 전문가 수준 균형 인자라고 불리는 하이퍼파라미터입니다. \\(\mathbf{1}(\cdot)\\)은 지시 함수(indicator function)를 나타내며, \\(T\\)는 시퀀스의 토큰 수를 나타냅니다.

#### 디바이스 수준 균형 손실

전문가 수준 균형 손실 외에도, 서로 다른 디바이스 간에 균형 잡힌 계산을 보장하기 위해 디바이스 수준 균형 손실을 추가로 설계했습니다. DeepSeek-V2의 훈련 과정에서, 모든 라우팅된 전문가를 \\(D\\)개의 그룹 \\(\{E_1, E_2, ..., E_D\}\\)으로 분할하고, 각 그룹을 단일 디바이스에 배치합니다. 디바이스 수준 균형 손실은 다음과 같이 계산됩니다.

\\[
\mathcal{L}\_{\text{DevBal}}=\alpha_{2}\sum_{i=1}^{D}f_{i}^{\prime}P_{i}^{\prime},
\\]

\\[
f_{i}^{\prime}=\frac{1}{T}\sum_{t=1}^{T}\mathbf{1}(\text{Token }t\text{ selects Device }i),
\\]

\\[
P_{i}^{\prime}=\frac{1}{|E_{i}|}\sum_{j\in E_{i}}P_{j},
\\]

여기서 \\(\alpha_2\\)는 디바이스 수준 균형 인자라고 불리는 하이퍼파라미터입니다.

#### 통신 균형 손실

마지막으로, 각 디바이스의 통신이 균형을 이루도록 통신 균형 손실을 도입합니다. 디바이스 제한 라우팅 메커니즘이 각 디바이스의 송신 통신이 제한되도록 보장하지만, 특정 디바이스가 다른 디바이스보다 더 많은 토큰을 수신하는 경우 실제 통신 효율성도 영향을 받습니다. 이 문제를 완화하기 위해 다음과 같은 통신 균형 손실을 설계합니다.

\\[
\mathcal{L}\_{\text{CommBal}}=\alpha_{3}\sum_{i=1}^{D}(r_{i}-\frac{MT}{D})^2,
\\]

\\[
r_{i}=\sum_{t=1}^{T}\sum_{j=1,j\neq i}^{D}\mathbf{1}(\text{Token }t\text{ is sent from Device }j\text{ to Device }i),
\\]

여기서 \\(\alpha_3\\)은 통신 균형 인자라고 불리는 하이퍼파라미터입니다.

디바이스 제한 라우팅 메커니즘은 각 디바이스가 최대 \\(MT\\)개의 은닉 상태를 다른 디바이스로 전송한다는 원칙에 따라 작동합니다. 동시에, 통신 균형 손실은 각 디바이스가 다른 디바이스로부터 약 \\(MT\\)개의 은닉 상태를 수신하도록 장려하는 데 사용됩니다. 통신 균형 손실은 디바이스 간에 균형 잡힌 정보 교환을 보장하여 효율적인 통신을 촉진합니다.

### 토큰 드롭핑 전략

균형 손실은 균형 잡힌 부하를 장려하는 것을 목표로 하지만, 엄격한 부하 균형을 보장할 수 없다는 점을 인식하는 것이 중요합니다. 불균형한 부하로 인한 계산 낭비를 더욱 완화하기 위해, 훈련 중에 디바이스 수준 토큰 드롭핑 전략을 도입합니다. 이 접근 방식은 먼저 각 디바이스에 대한 평균 계산 예산을 계산하는데, 이는 각 디바이스의 용량 인자가 1.0과 동일하다는 것을 의미합니다. 그런 다음 [Riquelme 등(2021)](https://arxiv.org/pdf/2106.05974v1)에서 영감을 받아, 계산 예산에 도달할 때까지 각 디바이스에서 친화도 점수가 가장 낮은 토큰을 드롭합니다. 또한, 훈련 시퀀스의 약 10%에 속하는 토큰은 절대 드롭되지 않도록 보장합니다. 이러한 방식으로, 효율성 요구 사항에 따라 추론 중에 토큰을 드롭할지 여부를 유연하게 결정할 수 있으며, 훈련과 추론 간의 일관성을 항상 보장할 수 있습니다.

# 사전 학습

## 실험 설정

### 데이터 구성

DeepSeek 67B(DeepSeek-AI, 2024)와 동일한 데이터 처리 단계를 유지하면서도, 데이터의 양을 확장하고 데이터 품질을 향상시켰습니다. 사전 학습 코퍼스를 확장하기 위해 인터넷 데이터의 잠재력을 탐색하고 정제 과정을 최적화하여 이전에 실수로 삭제된 많은 양의 데이터를 복구했습니다. 또한 중국어 인터넷에서 사용 가능한 코퍼스를 더 잘 활용하기 위해 더 많은 중국어 데이터를 통합했습니다.

데이터의 양뿐만 아니라 데이터 품질에도 중점을 두었습니다. 다양한 출처에서 고품질 데이터를 사전 학습 코퍼스에 추가하고, 품질 기반 필터링 알고리즘을 개선했습니다. 개선된 알고리즘은 유익하지 않은 많은 양의 데이터를 제거하면서도 가치 있는 데이터는 대부분 유지되도록 보장합니다. 또한 특정 지역 문화에서 비롯된 데이터 편향을 완화하기 위해 사전 학습 코퍼스에서 논쟁의 여지가 있는 콘텐츠를 필터링했습니다. 이 필터링 전략의 영향에 대한 자세한 논의는 부록에 제시되어 있습니다.

DeepSeek 67B에서 사용된 것과 동일한 토크나이저를 채택했으며, 이는 바이트 수준 바이트 쌍 인코딩(Byte-level Byte-Pair Encoding, BBPE) 알고리즘을 기반으로 하고 100K의 어휘 크기를 가집니다. 토큰화된 사전 학습 코퍼스는 8.1T 토큰을 포함하며, 중국어 토큰은 영어 토큰보다 약 12% 더 많습니다.

### 하이퍼파라미터

#### 모델 하이퍼파라미터

트랜스포머 레이어 수를 60개로 설정하고 은닉 차원을 5120으로 설정했습니다. 모든 학습 가능한 파라미터는 표준 편차 0.006으로 무작위 초기화되었습니다. MLA(다중 헤드 잠재 어텐션)에서는 어텐션 헤드 수 \\(n_h\\)를 128로 설정하고 헤드당 차원 \\(d_h\\)를 128로 설정했습니다. KV 압축 차원 \\(d_c\\)는 512로 설정하고, 쿼리 압축 차원 \\(d'\\)는 1536으로 설정했습니다. 분리된 쿼리와 키의 경우, 헤드당 차원 \\(d_h^R\\)을 64로 설정했습니다.

[Dai 등(2024)](https://arxiv.org/pdf/2401.06066v1)을 따라, 첫 번째 레이어를 제외한 모든 FFN(피드포워드 네트워크)을 MoE(혼합 전문가) 레이어로 대체했습니다. 각 MoE 레이어는 2개의 공유 전문가와 160개의 라우팅된 전문가로 구성되며, 각 전문가의 중간 은닉 차원은 1536입니다. 라우팅된 전문가 중에서 각 토큰에 대해 6개의 전문가가 활성화됩니다. 또한, 저차원 압축과 세밀한 전문가 분할은 레이어의 출력 규모에 영향을 미칩니다. 따라서 실제로는 압축된 잠재 벡터 이후에 추가적인 RMS 정규화 레이어를 사용하고, 너비 병목 지점(즉, 압축된 잠재 벡터와 라우팅된 전문가의 중간 은닉 상태)에 추가적인 스케일링 요소를 곱하여 안정적인 훈련을 보장합니다.

이 구성 하에서 DeepSeek-V2는 총 236B 파라미터를 포함하며, 이 중 21B가 각 토큰에 대해 활성화됩니다.

#### 훈련 하이퍼파라미터

AdamW 옵티마이저([Loshchilov와 Hutter, 2017](https://arxiv.org/pdf/1711.05101))를 사용하며, 하이퍼파라미터는 \\(\beta_1 = 0.9\\), \\(\beta_2 = 0.95\\), \\(\text{weight\_decay} = 0.1\\)로 설정했습니다. 학습률은 웜업-스텝-감소 전략(DeepSeek-AI, 2024)을 사용하여 스케줄링됩니다. 처음에는 학습률이 처음 2K 스텝 동안 0에서 최대값까지 선형적으로 증가합니다. 이후 토큰의 약 60%를 훈련한 후 학습률에 0.316을 곱하고, 토큰의 약 90%를 훈련한 후 다시 0.316을 곱합니다. 최대 학습률은 \\(2.4 \times 10^{-4}\\)로 설정하고, 그래디언트 클리핑 노름은 1.0으로 설정했습니다.

또한 배치 크기 스케줄링 전략을 사용하여, 처음 225B 토큰의 훈련에서 배치 크기를 2304에서 9216으로 점진적으로 증가시키고, 나머지 훈련에서는 9216을 유지합니다. 최대 시퀀스 길이는 4K로 설정하고, DeepSeek-V2를 8.1T 토큰에 대해 훈련했습니다.

파이프라인 병렬 처리를 활용하여 모델의 다른 레이어를 다른 디바이스에 배포하고, 각 레이어에서 라우팅된 전문가는 8개의 디바이스(\\(D = 8\\))에 균일하게 배포됩니다. 디바이스 제한 라우팅의 경우, 각 토큰은 최대 3개의 디바이스(\\(M = 3\\))로 전송됩니다. 균형 손실의 경우, \\(\alpha_1\\)을 0.003, \\(\alpha_2\\)를 0.05, \\(\alpha_3\\)을 0.02로 설정했습니다. 가속화를 위해 훈련 중에는 토큰 드롭핑 전략을 사용하지만, 평가를 위해서는 어떤 토큰도 드롭하지 않습니다.

### 인프라

DeepSeek-V2는 내부 엔지니어들이 개발한 효율적이고 경량화된 훈련 프레임워크인 HAI-LLM 프레임워크(High-flyer, 2023)를 기반으로 훈련되었습니다. 이 프레임워크는 16-way 제로 버블 파이프라인 병렬 처리([Qi 등, 2023](https://arxiv.org/pdf/2401.10241)), 8-way 전문가 병렬 처리([Lepikhin 등, 2021](https://arxiv.org/pdf/2006.16668v1)), ZeRO-1 데이터 병렬 처리([Rajbhandari 등, 2020](https://arxiv.org/pdf/2006.16668v1))를 사용합니다. DeepSeek-V2는 활성화된 파라미터가 상대적으로 적고, 활성화 메모리를 절약하기 위해 연산자의 일부가 재계산되기 때문에, 텐서 병렬 처리 없이도 훈련이 가능하여 통신 오버헤드를 줄일 수 있습니다. 또한 훈련 효율성을 더욱 향상시키기 위해, 공유 전문가의 계산과 전문가 병렬 all-to-all 통신을 중첩시켰습니다. 또한 통신, 라우팅 알고리즘, 다양한 전문가 간의 융합 선형 계산을 위한 더 빠른 CUDA 커널을 맞춤 제작했습니다. 또한 MLA는 FlashAttention-2([Dao, 2023](https://arxiv.org/pdf/2006.16668v1))의 개선된 버전을 기반으로 최적화되었습니다.

모든 실험은 NVIDIA H800 GPU가 장착된 클러스터에서 수행되었습니다. H800 클러스터의 각 노드에는 노드 내에서 NVLink와 NVSwitch를 사용하여 연결된 8개의 GPU가 포함되어 있습니다. 노드 간에는 InfiniBand 인터커넥트가 통신을 용이하게 하기 위해 사용됩니다.

### 긴 컨텍스트 확장

DeepSeek-V2의 초기 사전 학습 후, YaRN([Peng 등, 2023](https://arxiv.org/pdf/2309.00071))을 사용하여 기본 컨텍스트 윈도우 길이를 4K에서 128K로 확장했습니다. YaRN은 특별히 RoPE([Su 등, 2024](https://arxiv.org/pdf/2104.09864))를 전달하는 역할을 하는 분리된 공유 키 \\(k^R\\)에 적용되었습니다. YaRN의 경우, 스케일 \\(t_s\\)를 40, \\(\alpha\\)를 1, \\(\beta\\)를 32, 목표 최대 컨텍스트 길이를 160K로 설정했습니다. 이러한 설정 하에서, 모델이 128K의 컨텍스트 길이에 대해 잘 응답할 것으로 예상할 수 있습니다.

원래 YaRN과 약간 다르게, 우리의 독특한 어텐션 메커니즘으로 인해 어텐션 엔트로피를 조절하기 위해 길이 스케일링 요소를 조정했습니다. 요소 \\(t\\)는 \\(t = 0.0707 \sqrt{\ln s} + 1\\)로 계산되며, 이는 퍼플렉시티를 최소화하는 것을 목표로 합니다. 또한 32K의 시퀀스 길이와 576 시퀀스의 배치 크기로 1000 스텝 동안 추가로 모델을 훈련했습니다. 훈련이 32K의 시퀀스 길이에서만 수행되었지만, 모델은 여전히 128K의 컨텍스트 길이에서 평가될 때 강력한 성능을 보여줍니다.

아래 그림에서 볼 수 있듯이, "Needle In A Haystack"(NIAH) 테스트의 결과는 DeepSeek-V2가 최대 128K까지의 모든 컨텍스트 윈도우 길이에서 잘 수행됨을 나타냅니다.

![그림 4 "Needle In A Haystack"(NIAH) 테스트에 대한 평가 결과. DeepSeek-V2는 최대 128K까지의 모든 컨텍스트 윈도우 길이에서 잘 수행됩니다.](/assets/2025-04-15-deepseek-v2-a-strong-economical-and-efficient-mixture-of-experts-language-model/4.png)

"Needle In A Haystack" 테스트는 모델이 긴 컨텍스트 내에서 특정 정보를 찾고 활용할 수 있는 능력을 평가하는 방법입니다. 이 테스트에서는 문서의 깊이 백분율(Document Depth Percent)을 측정하는데, 이는 모델이 문서의 얼마나 깊은 부분까지 정보를 효과적으로 검색할 수 있는지를 나타냅니다. 위 그림의 결과를 보면, DeepSeek-V2는 1K에서 128K까지의 다양한 컨텍스트 길이에서 일관되게 높은 문서 깊이 백분율을 유지하고 있습니다. 특히 컨텍스트 길이가 길어질수록 일반적으로 모델의 성능이 저하되는 경향이 있지만, DeepSeek-V2는 128K의 매우 긴 컨텍스트에서도 강력한 성능을 보여주고 있습니다. 이는 YaRN 기법을 통한 컨텍스트 확장이 효과적으로 작동하고 있음을 입증합니다.

## 평가

### 평가 벤치마크

DeepSeek-V2는 영어와 중국어 두 언어로 사전 학습되었기 때문에, 영어와 중국어 모두에서 다양한 벤치마크를 통해 평가되었습니다. 평가는 HAI-LLM 프레임워크에 통합된 내부 평가 프레임워크를 기반으로 수행되었습니다. 평가에 포함된 벤치마크는 다음과 같이 분류됩니다(밑줄이 있는 벤치마크는 중국어 벤치마크입니다):

- 다중 주제 객관식 데이터셋: MMLU([Hendrycks 등, 2020](https://arxiv.org/pdf/2009.03300)), C-Eval([Huang 등, 2023](https://arxiv.org/pdf/2305.08322)), CMMLU([Li 등, 2023](https://arxiv.org/pdf/2306.09212))
- 언어 이해 및 추론 데이터셋: HellaSwag(Zellers 등, 2019), PIQA(Bisk 등, 2020), ARC(Clark 등, 2018), BigBench Hard(BBH)(Suzgun 등, 2022)
- 클로즈드북 질의응답 데이터셋: TriviaQA(Joshi 등, 2017), NaturalQuestions(Kwiatkowski 등, 2019)
- 독해 데이터셋: RACE(Lai 등, 2017), DROP(Dua 등, 2019), C3(Sun 등, 2019), CMRC(Cui 등, 2019)
- 참조 명확화 데이터셋: WinoGrande(Sakaguchi 등, 2019), CLUEWSC(Xu 등, 2020)
- 언어 모델링 데이터셋: Pile(Gao 등, 2020)
- 중국어 이해 및 문화 데이터셋: CHID(Zheng 등, 2019), CCPM(Li 등, 2021)
- 수학 데이터셋: GSM8K(Cobbe 등, 2021), MATH([Hendrycks 등, 2021](https://arxiv.org/pdf/2103.03874)), CMath(Wei 등, 2023)
- 코드 데이터셋: HumanEval(Chen 등, 2021), MBPP([Austin 등, 2021](https://arxiv.org/pdf/2108.07732)), CRUXEval(Gu 등, 2024)
- 표준화된 시험: AGIEval(Zhong 등, 2023). AGIEval은 영어와 중국어 하위 집합을 모두 포함합니다.

이전 연구(DeepSeek-AI, 2024)를 따라, HellaSwag, PIQA, WinoGrande, RACE-Middle, RACE-High, MMLU, ARC-Easy, ARC-Challenge, CHID, C-Eval, CMMLU, C3, CCPM과 같은 데이터셋에 대해서는 퍼플렉시티 기반 평가를 채택했으며, TriviaQA, NaturalQuestions, DROP, MATH, GSM8K, HumanEval, MBPP, CRUXEval, BBH, AGIEval, CLUEWSC, CMRC, CMath에 대해서는 생성 기반 평가를 채택했습니다. 또한 Pile-test에 대해서는 언어 모델링 기반 평가를 수행하고, 서로 다른 토크나이저를 가진 모델 간의 공정한 비교를 보장하기 위해 Bits-Per-Byte(BPB)를 메트릭으로 사용했습니다.

이러한 벤치마크에 대한 직관적인 개요를 제공하기 위해, 부록 G에 각 벤치마크에 대한 평가 형식도 제공되어 있습니다.

### 평가 결과

DeepSeek-V2를 DeepSeek 67B(DeepSeek-AI, 2024)(이전 릴리스), Qwen1.5 72B(Bai 등, 2023), LLaMA3 70B(AI@Meta, 2024), Mixtral 8x22B(Mistral, 2024)를 포함한 여러 대표적인 오픈소스 모델과 비교합니다. 모든 모델은 내부 평가 프레임워크를 통해 평가되었으며, 동일한 평가 설정을 공유합니다.

전반적으로, 활성화된 파라미터가 21B에 불과한 DeepSeek-V2는 거의 모든 벤치마크에서 DeepSeek 67B를 크게 능가하며, 오픈소스 모델 중 최고 수준의 성능을 달성합니다.

더 나아가, DeepSeek-V2와 오픈소스 경쟁 모델들을 하나씩 비교해 보겠습니다.

(1) 중국어와 영어를 모두 지원하는 또 다른 모델인 Qwen1.5 72B와 비교했을 때, DeepSeek-V2는 대부분의 영어, 코드, 수학 벤치마크에서 압도적인 우위를 보여줍니다. 중국어 벤치마크의 경우, Qwen1.5 72B는 다중 주제 객관식 작업에서 더 나은 성능을 보이지만, DeepSeek-V2는 다른 벤치마크에서는 비슷하거나 더 나은 성능을 보입니다. CHID 벤치마크의 경우, Qwen1.5 72B의 토크나이저가 평가 프레임워크에서 오류를 발생시키기 때문에 Qwen1.5 72B의 CHID 점수는 비워두었습니다.

(2) Mixtral 8x22B와 비교했을 때, DeepSeek-V2는 TriviaQA, NaturalQuestions, HellaSwag와 같은 영어 상식 지식과 밀접하게 관련된 일부 벤치마크를 제외하고는 비슷하거나 더 나은 영어 성능을 달성합니다. 특히 DeepSeek-V2는 MMLU에서 Mixtral 8x22B보다 우수한 성능을 보입니다. 코드와 수학 벤치마크에서는 DeepSeek-V2가 Mixtral 8x22B와 비슷한 성능을 보여줍니다. Mixtral 8x22B는 중국어 데이터에 대해 특별히 훈련되지 않았기 때문에, 중국어 능력은 DeepSeek-V2보다 훨씬 뒤처집니다.

(3) LLaMA3 70B와 비교했을 때, DeepSeek-V2는 영어 토큰의 1/4 미만으로 훈련되었습니다. 따라서 DeepSeek-V2는 기본적인 영어 능력에서 LLaMA3 70B와 약간의 차이가 있음을 인정합니다. 그러나 훨씬 적은 훈련 토큰과 활성화된 파라미터에도 불구하고, DeepSeek-V2는 여전히 LLaMA3 70B와 비슷한 코드 및 수학 능력을 보여줍니다. 또한 이중 언어 모델로서 DeepSeek-V2는 중국어 벤치마크에서 LLaMA3 70B를 압도적으로 능가합니다.

마지막으로, 일부 이전 연구(Hu 등, 2024)는 사전 학습 단계에서 SFT(Supervised Fine-Tuning) 데이터를 통합하는 반면, DeepSeek-V2는 사전 학습 중에 SFT 데이터에 노출된 적이 없다는 점을 언급할 가치가 있습니다.

### 훈련 및 추론 효율성

#### 훈련 비용

DeepSeek-V2는 각 토큰에 대해 더 적은 파라미터를 활성화하고 DeepSeek 67B보다 더 적은 FLOP를 필요로 하기 때문에, 이론적으로 DeepSeek-V2를 훈련하는 것이 DeepSeek 67B를 훈련하는 것보다 더 경제적일 것입니다. MoE 모델을 훈련하면 추가적인 통신 오버헤드가 발생하지만, 연산자 및 통신 최적화를 통해 DeepSeek-V2의 훈련은 상대적으로 높은 모델 FLOP 활용도(MFU)를 달성할 수 있습니다. H800 클러스터에서의 실제 훈련 중에, 1조 토큰을 훈련하는 데 DeepSeek 67B는 300.6K GPU 시간이 필요한 반면, DeepSeek-V2는 172.8K GPU 시간만 필요합니다. 즉, 희소 DeepSeek-V2는 밀집 DeepSeek 67B와 비교하여 42.5%의 훈련 비용을 절감할 수 있습니다.

#### 추론 효율성

DeepSeek-V2를 효율적으로 서비스에 배포하기 위해, 먼저 파라미터를 FP8 정밀도로 변환합니다. 또한 DeepSeek-V2에 대해 KV 캐시 양자화(Hooper 등, 2024; Zhao 등, 2023)를 수행하여 KV 캐시의 각 요소를 평균 6비트로 추가 압축합니다. MLA와 이러한 최적화의 혜택을 받아, 실제로 배포된 DeepSeek-V2는 DeepSeek 67B보다 훨씬 적은 KV 캐시를 필요로 하므로 훨씬 더 큰 배치 크기를 처리할 수 있습니다.

실제로 배포된 DeepSeek 67B 서비스의 프롬프트 및 생성 길이 분포를 기반으로 DeepSeek-V2의 생성 처리량을 평가합니다. 8개의 H800 GPU가 있는 단일 노드에서, DeepSeek-V2는 초당 50K 토큰을 초과하는 생성 처리량을 달성하는데, 이는 DeepSeek 67B의 최대 생성 처리량의 5.76배입니다. 또한 DeepSeek-V2의 프롬프트 입력 처리량은 초당 100K 토큰을 초과합니다.

## 정렬

### 지도 미세 조정

이전 연구(DeepSeek-AI, 2024)를 기반으로, 우리는 유용성을 위한 120만 개의 인스턴스와 안전성을 위한 30만 개의 인스턴스를 포함하는 총 150만 개의 인스턴스로 구성된 지시 조정 데이터셋을 큐레이션했습니다. 초기 버전과 비교하여, 우리는 환각적 응답을 완화하고 글쓰기 능력을 향상시키기 위해 데이터 품질을 개선했습니다. DeepSeek-V2를 2 에포크 동안 미세 조정했으며, 학습률은 5 × 10^-6으로 설정했습니다.

DeepSeek-V2 Chat(SFT)의 평가를 위해, 우리는 주로 MMLU와 ARC와 같은 대표적인 객관식 작업을 제외하고 생성 기반 벤치마크를 포함했습니다. 또한 DeepSeek-V2 Chat(SFT)에 대해 지시 따르기 평가(IFEval)(Zhou 등, 2023)를 수행했으며, 프롬프트 수준의 느슨한 정확도를 메트릭으로 사용했습니다. 더불어, 2023년 9월 1일부터 2024년 4월 1일까지의 LiveCodeBench(Jain 등, 2024) 질문을 사용하여 채팅 모델을 평가했습니다.

표준 벤치마크 외에도, 우리는 MT-Bench(Zheng 등, 2023), AlpacaEval 2.0(Dubois 등, 2024), AlignBench(Liu 등, 2023)를 포함한 개방형 대화 벤치마크에서 모델을 추가로 평가했습니다. 비교를 위해, 우리는 또한 Qwen1.5 72B Chat, LLaMA-3-70B Instruct, Mistral-8x22B Instruct를 우리의 평가 프레임워크와 설정에서 평가했습니다. DeepSeek 67B Chat에 대해서는 이전 릴리스에서 보고된 평가 결과를 직접 참조했습니다.

### 강화 학습

DeepSeek-V2의 잠재력을 더욱 발휘하고 인간 선호도와 일치시키기 위해, 우리는 강화 학습(RL)을 수행하여 모델의 선호도를 조정했습니다.

#### 강화 학습 알고리즘

RL 훈련 비용을 절감하기 위해, 우리는 그룹 상대 정책 최적화(Group Relative Policy Optimization, GRPO)(Shao 등, 2024)를 채택했습니다. 이 방법은 일반적으로 정책 모델과 동일한 크기를 가진 비평 모델을 생략하고, 대신 그룹 점수에서 기준선을 추정합니다. 구체적으로, 각 질문 \\(q\\)에 대해, GRPO는 이전 정책 \\(\pi_{\theta_{old}}\\)에서 출력 그룹 \\(\{o_1, o_2, \ldots, o_G\}\\)을 샘플링한 다음, 다음 목표를 최대화하여 정책 모델 \\(\pi_{\theta}\\)를 최적화합니다.

\\[
J_{GRPO}(\theta) = E_{q \sim P(Q), \{o_i\}\_{i=1}^G \sim \pi_{\theta_{old}}(\cdot|q)} \left[\frac{1}{G}\sum_{i=1}^{G}\left(\operatorname*{min}\left(\frac{\pi_{\theta}(o_{i}|q)}{\pi_{\theta_{old}}(o_{i}|q)}A_{i},\mathrm{clip}\left(\frac{\pi_{\theta}(o_{i}|q)}{\pi_{\theta_{old}}(o_{i}|q)},1-\varepsilon,1+\varepsilon\right)A_{i}\right)-\beta D_{KL}\left(\pi_{\theta}||\pi_{ref}\right)\right)\right]
\\]

\\[
D_{KL}\left(\pi_{\theta}||\pi_{ref}\right)=\frac{\pi_{ref}\left(o_{i}|q\right)}{\pi_{\theta}(o_{i}|q)}-\log\frac{\pi_{ref}\left(o_{i}|q\right)}{\pi_{\theta}\left(o_{i}|q\right)}-1
\\]

여기서 \\(\varepsilon\\)과 \\(\beta\\)는 하이퍼파라미터이고, \\(A_i\\)는 각 그룹 내의 출력에 해당하는 보상 그룹 \\(\{r_1, r_2, \ldots, r_G\}\\)을 사용하여 계산된 어드밴티지입니다.

\\[
A_{i}=\frac{r_{i}-\operatorname*{mean}(\{r_{1},r_{2},\cdots,r_{G}\})}{\mathrm{std}(\{r_{1},r_{2},\cdots,r_{G}\})}
\\]

#### 훈련 전략

예비 실험에서, 우리는 코드와 수학 프롬프트와 같은 추론 데이터에 대한 RL 훈련이 일반 데이터에 대한 훈련과는 구별되는 독특한 특성을 보인다는 것을 발견했습니다. 예를 들어, 우리 모델의 수학적 및 코딩 능력은 더 긴 훈련 단계 동안 계속 향상될 수 있습니다. 따라서, 우리는 먼저 추론 정렬을 수행한 다음 인간 선호도 정렬을 수행하는 2단계 RL 훈련 전략을 채택했습니다.

첫 번째 추론 정렬 단계에서, 우리는 코드와 수학 추론 작업을 위한 보상 모델 \\(RM_{reasoning}\\)을 훈련시키고, \\(RM_{reasoning}\\)의 피드백으로 정책 모델을 최적화합니다.

\\[
r_{i}=RM_{reasoning}(o_{i})
\\]

두 번째 인간 선호도 정렬 단계에서, 우리는 유용성 보상 모델 \\(RM_{helpful}\\), 안전성 보상 모델 \\(RM_{safety}\\), 규칙 기반 보상 모델 \\(RM_{rule}\\)에서 보상을 획득하는 다중 보상 프레임워크를 채택합니다. 응답 \\(o_i\\)의 최종 보상은 다음과 같습니다.

\\[
r_{i}=c_{1}\cdot RM_{helpful}(o_{i})+c_{2}\cdot RM_{safety}(o_{i})+c_{3}\cdot RM_{rule}(o_{i})
\\]

여기서 \\(c_1\\), \\(c_2\\), \\(c_3\\)는 해당 계수입니다.

RL 훈련에서 중요한 역할을 하는 신뢰할 수 있는 보상 모델을 얻기 위해, 우리는 선호도 데이터를 신중하게 수집하고, 품질 필터링과 비율 조정을 철저히 수행했습니다. 우리는 컴파일러 피드백을 기반으로 코드 선호도 데이터를 얻고, 정답 레이블을 기반으로 수학적 선호도 데이터를 얻었습니다. 보상 모델 훈련을 위해, 우리는 보상 모델을 DeepSeek-V2 Chat(SFT)로 초기화하고 포인트와이즈 또는 페어와이즈 손실로 훈련했습니다.

실험에서, 우리는 RL 훈련이 모델의 잠재력을 완전히 활용하고 활성화하여 가능한 응답 중에서 정확하고 만족스러운 답변을 선택할 수 있게 한다는 것을 관찰했습니다.

#### 훈련 효율성을 위한 최적화

극도로 큰 모델에 대한 RL 훈련은 훈련 프레임워크에 높은 요구 사항을 부과합니다. GPU 메모리와 RAM 압력을 관리하면서도 빠른 훈련 속도를 유지하기 위해 신중한 엔지니어링 최적화가 필요합니다. 이를 위해 다음과 같은 엔지니어링 최적화를 구현했습니다.

1. 먼저, 훈련과 추론에 각각 다른 병렬 전략을 채택하여 더 높은 GPU 활용도를 달성하는 하이브리드 엔진을 제안했습니다.
2. 둘째, 추론 속도를 가속화하기 위해 큰 배치 크기로 vLLM(Kwon 등, 2023)을 활용했습니다.
3. 셋째, 모델을 CPU로 오프로딩하고 모델을 다시 GPU로 로딩하기 위한 스케줄링 전략을 신중하게 설계하여 훈련 속도와 메모리 소비 사이의 최적에 가까운 균형을 달성했습니다.

### 평가 결과

#### 표준 벤치마크에 대한 평가

먼저, 우리는 DeepSeek-V2 Chat(SFT)와 DeepSeek-V2 Chat(RL)을 표준 벤치마크에서 평가했습니다. 주목할 만한 점은, DeepSeek-V2 Chat(SFT)가 기본 버전과 비교하여 GSM8K, MATH, HumanEval 평가에서 상당한 개선을 보여준다는 것입니다. 이러한 진전은 상당한 양의 수학 및 코드 관련 콘텐츠를 포함하는 SFT 데이터의 포함 덕분입니다. 또한, DeepSeek-V2 Chat(RL)은 수학 및 코드 벤치마크에서 성능을 더욱 향상시킵니다. 부록 F에서 더 많은 코드 및 수학 평가를 보여줍니다.

다른 모델과의 비교에 있어서, 우리는 먼저 DeepSeek-V2 Chat(SFT)를 Qwen1.5 72B Chat과 비교했으며, DeepSeek-V2 Chat(SFT)가 거의 모든 영어, 수학, 코드 벤치마크에서 Qwen1.5 72B Chat을 능가한다는 것을 발견했습니다. 중국어 벤치마크에서, DeepSeek-V2 Chat(SFT)는 다중 주제 객관식 작업에서 Qwen1.5 72B Chat보다 약간 낮은 점수를 보여주는데, 이는 기본 버전에서 관찰된 성능과 일치합니다.

최첨단 오픈소스 MoE 모델인 Mixtral 8x22B Instruct와 비교했을 때, DeepSeek-V2 Chat(SFT)는 NaturalQuestions와 IFEval을 제외한 대부분의 벤치마크에서 더 나은 성능을 보여줍니다. 또한, 최첨단 오픈소스 모델인 LLaMA3 70B Chat과 비교했을 때, DeepSeek-V2 Chat(SFT)는 코드 및 수학 관련 벤치마크에서 유사한 성능을 보여줍니다. LLaMA3 70B Chat은 MMLU와 IFEval에서 더 나은 성능을 보여주는 반면, DeepSeek-V2 Chat(SFT)는 중국어 작업에서 더 강력한 성능을 보여줍니다.

궁극적으로, DeepSeek-V2 Chat(RL)은 DeepSeek-V2 Chat(SFT)와 비교하여 수학적 및 코딩 작업 모두에서 더욱 향상된 성능을 보여줍니다. 이러한 비교는 다양한 도메인과 언어에서 다른 언어 모델과 관련하여 DeepSeek-V2 Chat의 강점을 강조합니다.

#### 개방형 생성에 대한 평가

우리는 개방형 대화 벤치마크에서 모델에 대한 추가 평가를 진행했습니다. 영어 개방형 대화 생성을 위해, 우리는 MT-Bench와 AlpacaEval 2.0을 벤치마크로 사용했습니다. 표 4에 제시된 평가 결과는 DeepSeek-V2 Chat(RL)이 DeepSeek-V2 Chat(SFT)보다 상당한 성능 우위를 보여줍니다. 이 결과는 정렬 개선을 달성하는 데 있어 RL 훈련의 효과를 보여줍니다.

다른 오픈소스 모델과 비교했을 때, DeepSeek-V2 Chat(RL)은 두 벤치마크 모두에서 Mistral 8x22B Instruct와 Qwen1.5 72B Chat보다 우수한 성능을 보여줍니다. LLaMA3 70B Instruct와 비교했을 때, DeepSeek-V2 Chat(RL)은 MT-Bench에서 경쟁력 있는 성능을 보여주고 AlpacaEval 2.0에서 눈에 띄게 능가합니다. 이러한 결과는 특히 지시 기반 대화 작업에서 고품질이고 맥락적으로 관련성 있는 응답을 생성하는 DeepSeek-V2 Chat(RL)의 강력한 성능을 강조합니다.

| 모델 | MT-Bench | AlpacaEval 2.0 |
|------|----------|----------------|
| DeepSeek 67B Chat | 8.35 | 16.6 |
| Mistral 8x22B Instruct v0.1 | 8.66 | 30.9 |
| Qwen1.5 72B Chat | 8.61 | 36.6 |
| LLaMA3 70B Instruct | 8.95 | 34.4 |
| DeepSeek-V2 Chat (SFT) | 8.62 | 30.0 |
| DeepSeek-V2 Chat (RL) | 8.97 | 38.9 |

영어 개방형 대화 평가. AlpacaEval 2.0의 경우, 길이 제어 승률을 메트릭으로 사용합니다.

또한, 우리는 AlignBench를 기반으로 중국어 개방형 생성 능력을 평가했습니다. 위 표에서 제시된 바와 같이, DeepSeek-V2 Chat(RL)은 DeepSeek-V2 Chat(SFT)보다 약간의 우위를 보입니다. 주목할 만한 점은, DeepSeek-V2 Chat(SFT)가 모든 오픈소스 중국어 모델을 상당한 차이로 능가한다는 것입니다. 두 번째로 좋은 오픈소스 모델인 Qwen1.5 72B Chat을 중국어 추론과 언어 모두에서 크게 능가합니다. 또한, DeepSeek-V2 Chat(SFT)와 DeepSeek-V2 Chat(RL) 모두 GPT-4-0613과 ERNIEBot 4.0을 능가하여 중국어를 지원하는 최상위 LLM에서 우리 모델의 위치를 공고히 합니다.

구체적으로, DeepSeek-V2 Chat(RL)은 중국어 언어 이해에서 GPT-4-Turbo-1106-Preview를 포함한 모든 모델을 능가하는 놀라운 성능을 보여줍니다. 반면에, DeepSeek-V2 Chat(RL)의 추론 능력은 여전히 Erniebot-4.0 및 GPT-4와 같은 거대 모델에 뒤처집니다.

| 모델 | 전체 | 추론 중문추리 | 언어 중문언어 |
|------|------|--------------|-------------|
| GPT-4-1106-Preview | 8.01 | 7.73 | 8.29 |
| DeepSeek-V2 Chat (RL) | 7.91 | 7.45 | 8.36 |
| ERNIEBot-4.0-202404*（文心一言） | 7.89 | 7.61 | 8.17 |
| DeepSeek-V2 Chat (SFT) | 7.74 | 7.30 | 8.17 |
| GPT-4-0613 | 7.53 | 7.47 | 7.59 |
| ERNIEBot-4.0-202312*（文心一言） | 7.36 | 6.84 | 7.88 |
| Moonshot-v1-32k-202404*（月之暗面） | 7.22 | 6.42 | 8.02 |
| Qwen1.5-72B-Chat* | 7.19 | 6.45 | 7.93 |
| DeepSeek-67B-Chat | 6.43 | 5.75 | 7.11 |

GPT-4-0613에 의해 평가된 AlignBench 리더보드. 모델은 전체 점수를 기준으로 내림차순으로 정렬됩니다. *로 표시된 모델은 원본 논문에 보고된 결과를 참조하는 대신 API 서비스나 오픈 가중치 모델을 통해 평가했음을 나타냅니다. Erniebot-4.0과 Moonshot의 접미사는 API를 호출한 타임스탬프를 나타냅니다.

### 논의

#### SFT 데이터의 양

SFT 코퍼스의 필요성에 관한 논의는 치열한 논쟁의 주제였습니다. 이전 연구(Young 등, 2024; Zhou 등, 2024)는 10K 미만의 SFT 데이터 인스턴스만으로도 만족스러운 결과를 얻기에 충분하다고 주장합니다. 그러나 우리의 실험에서는 10K 미만의 인스턴스를 사용할 경우 IFEval 벤치마크에서 상당한 성능 저하가 관찰되었습니다.

가능한 설명은 언어 모델이 특정 기술을 개발하기 위해 일정량의 데이터가 필요하다는 것입니다. 필요한 데이터 양은 모델 크기가 증가함에 따라 감소할 수 있지만, 완전히 제거될 수는 없습니다. 우리의 관찰은 LLM에 원하는 능력을 갖추기 위해 충분한 데이터가 필요하다는 중요한 필요성을 강조합니다.

또한, SFT 데이터의 품질도 중요하며, 특히 글쓰기나 개방형 질문을 포함하는 작업에서 그렇습니다.

#### 강화 학습의 정렬 세금

인간 선호도 정렬 중에, 우리는 AI와 인간 평가자 모두에 의해 평가된 점수 측면에서 개방형 생성 벤치마크에서 상당한 성능 향상을 관찰했습니다. 그러나 우리는 또한 "정렬 세금"(alignment tax)(Ouyang 등, 2022) 현상을 관찰했습니다. 즉, 정렬 과정이 BBH와 같은 일부 표준 벤치마크의 성능에 부정적인 영향을 미칠 수 있습니다.

정렬 세금을 완화하기 위해, RL 단계 동안 우리는 데이터 처리와 훈련 전략 개선에 상당한 노력을 기울여 표준 및 개방형 벤치마크의 성능 사이에서 허용 가능한 절충안을 달성했습니다. 인간 선호도와 일치하면서도 일반적인 성능을 손상시키지 않는 모델 정렬 방법을 탐색하는 것은 향후 연구를 위한 가치 있는 방향을 제시합니다.

#### 온라인 강화 학습

선호도 정렬 실험에서, 우리는 온라인 접근 방식이 오프라인 접근 방식보다 상당히 우수한 성능을 보인다는 것을 발견했습니다. 따라서, 우리는 DeepSeek-V2를 정렬하기 위한 온라인 RL 프레임워크를 구현하는 데 엄청난 노력을 투자했습니다. 온라인 또는 오프라인 선호도 정렬에 대한 결론은 다양한 맥락에서 달라질 수 있으며, 우리는 이들 간의 더 철저한 비교와 분석을 향후 작업으로 남겨둡니다.

## 결론, 한계점 및 향후 연구

본 논문에서는 128K 컨텍스트 길이를 지원하는 대규모 혼합 전문가(MoE) 언어 모델인 DeepSeek-V2를 소개했습니다. DeepSeek-V2는 강력한 성능뿐만 아니라 MLA(다중 헤드 잠재 어텐션)와 DeepSeekMoE를 포함한 혁신적인 아키텍처 덕분에 경제적인 훈련과 효율적인 추론이라는 특징을 갖추고 있습니다. 실제로 DeepSeek 67B와 비교했을 때, DeepSeek-V2는 훨씬 더 강력한 성능을 달성하면서도 훈련 비용을 42.5% 절감하고, KV 캐시를 93.3% 줄이며, 최대 생성 처리량을 5.76배 향상시켰습니다. 평가 결과는 활성화된 파라미터가 21B에 불과함에도 불구하고 DeepSeek-V2가 오픈소스 모델 중 최고 수준의 성능을 달성하고 가장 강력한 오픈소스 MoE 모델이 되었음을 보여줍니다.

DeepSeek-V2와 그 채팅 버전들은 다른 대규모 언어 모델(LLM)에서 일반적으로 발견되는 한계점들을 공유하고 있습니다. 여기에는 사전 훈련 이후 지식 업데이트의 부재, 검증되지 않은 조언과 같은 사실이 아닌 정보를 생성할 가능성, 그리고 환각을 생성할 가능성이 포함됩니다. 또한 데이터가 주로 중국어와 영어 콘텐츠로 구성되어 있기 때문에, 모델은 다른 언어에서 제한된 능력을 보일 수 있습니다. 중국어와 영어를 넘어선 시나리오에서는 주의해서 사용해야 합니다.

DeepSeek은 장기주의(longtermism)를 바탕으로 오픈소스 대규모 모델에 지속적으로 투자할 것이며, 인공 일반 지능(AGI)이라는 목표에 점진적으로 접근하는 것을 목표로 합니다.

- 현재 진행 중인 탐색에서, DeepSeek은 경제적인 훈련 및 추론 비용을 유지하면서 MoE 모델을 더욱 확장할 수 있는 방법을 개발하는 데 전념하고 있습니다. 다음 단계의 목표는 다음 릴리스에서 GPT-4와 동등한 성능을 달성하는 것입니다.

- DeepSeek의 정렬 팀은 모델을 지속적으로 개선하기 위해 노력하고 있으며, 전 세계 사용자에게 도움이 될 뿐만 아니라 정직하고 안전한 모델을 개발하는 것을 목표로 합니다. 궁극적인 목표는 인간의 감독 필요성을 최소화하면서 모델의 가치를 인간의 가치와 일치시키는 것입니다. 윤리적 고려사항과 책임감 있는 개발을 우선시함으로써, DeepSeek은 사회에 긍정적이고 유익한 영향을 미치기 위해 노력하고 있습니다.

- 현재 DeepSeek-V2는 텍스트 모달리티만 지원하도록 설계되어 있습니다. 향후 계획에서는 모델이 다양한 시나리오에서 활용도와 유용성을 높일 수 있도록 여러 모달리티를 지원할 수 있게 하는 것을 목표로 하고 있습니다.

이러한 향후 연구 방향은 DeepSeek-V2의 현재 성과를 기반으로 하며, 더 강력하고 다재다능하며 인간의 가치와 일치하는 AI 시스템을 개발하기 위한 DeepSeek의 지속적인 노력을 보여줍니다. 경제적인 훈련과 효율적인 추론을 유지하면서 모델 규모를 확장하는 것은 특히 중요한 연구 방향으로, 이는 더 큰 모델이 더 강력한 능력을 보이는 경향이 있지만 계산 비용이 증가한다는 점에서 중요한 균형을 맞추는 작업입니다.

또한 모델 정렬에 대한 지속적인 연구는 AI 시스템이 인간의 가치와 일치하도록 보장하는 데 중요합니다. 이는 단순히 유용한 모델을 만드는 것을 넘어, 정직하고 안전하며 윤리적인 AI 시스템을 개발하는 것을 목표로 합니다. 이러한 정렬 노력은 AI 시스템이 사회에 긍정적인 영향을 미치도록 하는 데 필수적입니다.

마지막으로, 다중 모달리티 지원을 향한 움직임은 AI 시스템의 응용 범위를 크게 확장할 수 있는 중요한 발전입니다. 텍스트를 넘어 이미지, 오디오, 비디오와 같은 다른 형태의 데이터를 처리할 수 있는 능력은 AI 시스템이 더 다양한 실제 응용 프로그램에서 유용하게 만들 것입니다.

이러한 향후 연구 방향은 DeepSeek-V2의 현재 성과를 기반으로 하며, AI 기술의 발전과 그 사회적 영향 사이의 균형을 맞추는 DeepSeek의 장기적인 비전을 반영합니다.

## 부록
### DeepSeek-V2-Lite: MLA와 DeepSeekMoE를 갖춘 16B 모델

#### 모델 설명

##### 아키텍처

DeepSeek-V2-Lite는 27개의 레이어와 2048의 은닉 차원을 가지고 있습니다. 이 모델은 다중 헤드 잠재 어텐션(MLA)을 채택하고 있으며, 16개의 어텐션 헤드를 갖추고 있고 각 헤드의 차원은 128입니다. KV 압축 차원은 512로 설정되어 있지만, DeepSeek-V2와 약간 다르게 쿼리를 압축하지 않습니다. 분리된 쿼리와 키의 경우, 헤드당 차원은 64입니다.

DeepSeek-V2-Lite는 또한 DeepSeekMoE를 채택하고 있으며, 첫 번째 레이어를 제외한 모든 피드포워드 네트워크(FFN)가 MoE 레이어로 대체되었습니다. 각 MoE 레이어는 2개의 공유 전문가와 64개의 라우팅된 전문가로 구성되어 있으며, 각 전문가의 중간 은닉 차원은 1408입니다. 라우팅된 전문가 중에서 각 토큰에 대해 6개의 전문가가 활성화됩니다.

이러한 구성 하에서 DeepSeek-V2-Lite는 총 15.7B 파라미터를 포함하며, 이 중 2.4B가 각 토큰에 대해 활성화됩니다.

아래 표는 DeepSeek-V2-Lite, DeepSeekMoE 16B, DeepSeek 7B의 성능을 비교합니다.

| 벤치마크 | DeepSeek 7B | DeepSeekMoE 16B | DeepSeek-V2-Lite |
|---------|------------|-----------------|-----------------|
| 아키텍처 | MHA+Dense | MHA+MoE | MLA+MoE |
| 컨텍스트 길이 | 4K | 4K | 32K |
| 활성화된 파라미터 수 | 6.9B | 2.8B | 2.4B |
| 총 파라미터 수 | 6.9B | 16.4B | 15.7B |
| 훈련 토큰 수 | 2T | 2T | 5.7T |
| MMLU 영어 | 48.2 | 45.0 | 58.3 |
| BBH | 39.5 | 38.9 | 44.1 |
| TriviaQA | 59.7 | 64.8 | 64.2 |
| NaturalQuestions | 22.2 | 25.5 | 26.0 |
| ARC-Easy | 67.9 | 68.1 | 70.9 |
| ARC-Challenge | 48.1 | 49.8 | 51.2 |
| AGIEval | 26.4 | 17.4 | 33.2 |
| CodeHumanEval | 26.2 | 26.8 | 29.9 |
| MBPP | 39.0 | 39.2 | 43.2 |
| MathGSM8K | 17.4 | 18.8 | 41.1 |
| MATH | 3.3 | 4.3 | 17.1 |
| CMath | 34.5 | 40.4 | 58.4 |
| 중국어 CLUEWSC | 73.1 | 72.1 | 74.3 |
| C-Eval | 45.0 | 40.6 | 60.3 |
| CMMLU | 47.2 | 42.5 | 64.3 |

##### 훈련 세부 사항

DeepSeek-V2-Lite는 DeepSeek-V2와 동일한 사전 훈련 코퍼스에서 처음부터 훈련되었으며, 이 코퍼스는 어떠한 SFT 데이터로도 오염되지 않았습니다. 이 모델은 하이퍼파라미터가 \\(\beta_1 = 0.9\\), \\(\beta_2 = 0.95\\), \\(\text{weight\_decay} = 0.1\\)로 설정된 AdamW 옵티마이저를 사용합니다. 학습률은 웜업-스텝-감소 전략을 사용하여 스케줄링됩니다. 처음에는 학습률이 처음 2K 스텝 동안 0에서 최대값까지 선형적으로 증가합니다. 이후 토큰의 약 80%를 훈련한 후 학습률에 0.316을 곱하고, 토큰의 약 90%를 훈련한 후 다시 0.316을 곱합니다. 최대 학습률은 \\(4.2 \times 10^{-4}\\)로 설정하고, 그래디언트 클리핑 노름은 1.0으로 설정했습니다.

이 모델에 대해서는 배치 크기 스케줄링 전략을 사용하지 않고, 일정한 배치 크기 4608 시퀀스로 훈련했습니다. 사전 훈련 중에는 최대 시퀀스 길이를 4K로 설정하고, DeepSeek-V2-Lite를 5.7T 토큰에 대해 훈련했습니다.

파이프라인 병렬 처리를 활용하여 모델의 다른 레이어를 다른 디바이스에 배포하지만, 각 레이어에서 모든 전문가는 동일한 디바이스에 배포됩니다. 따라서 \\(\alpha_1 = 0.001\\)의 작은 전문가 수준 균형 손실만 사용하고, 디바이스 수준 균형 손실과 통신 균형 손실은 사용하지 않습니다.

사전 훈련 후, DeepSeek-V2-Lite에 대해서도 긴 컨텍스트 확장과 SFT(지도 미세 조정)를 수행하여 DeepSeek-V2-Lite Chat이라는 채팅 모델을 얻었습니다.

아래 표는 DeepSeek-V2-Lite Chat, DeepSeekMoE 16B Chat, DeepSeek 7B Chat의 성능을 비교합니다.

| 벤치마크 | DeepSeek 7B Chat | DeepSeekMoE 16B Chat | DeepSeek-V2-Lite Chat |
|---------|-----------------|---------------------|----------------------|
| 아키텍처 | MHA+Dense | MHA+MoE | MLA+MoE |
| 컨텍스트 길이 | 4K | 4K | 32K |
| 활성화된 파라미터 수 | 6.9B | 2.8B | 2.4B |
| 총 파라미터 수 | 6.9B | 16.4B | 15.7B |
| 훈련 토큰 수 | 2T | 2T | 5.7T |
| 영어 MMLU | 49.7 | 47.2 | 55.7 |
| BBH | 43.1 | 42.2 | 48.1 |
| TriviaQA | 59.5 | 63.3 | 65.2 |
| NaturalQuestions | 32.7 | 35.1 | 35.5 |
| ARC-Easy | 70.2 | 69.9 | 74.3 |
| ARC-Challenge | 50.2 | 50.0 | 51.5 |
| AGIEval | 17.6 | 19.7 | 42.8 |
| CodeHumanEval | 45.1 | 45.7 | 57.3 |
| MBPP | 39.0 | 46.2 | 45.8 |
| MathGSM8K | 62.6 | 62.2 | 72.0 |
| MATH | 14.7 | 15.2 | 27.9 |
| CMath | 66.4 | 67.9 | 71.7 |
| 중국어 CLUEWSC | 66.2 | 68.2 | 80.0 |
| C-Eval | 44.7 | 40.0 | 60.1 |
| CMMLU | 51.2 | 49.3 | 62.5 |

#### MLA의 전체 공식

MLA의 완전한 계산 과정을 보여주기 위해, 다음과 같이 전체 공식을 제공합니다.

\\[
\begin{array}{c}
\mathbf{c}\_{t}^{Q}=\mathbf{W}^{DQ}\mathbf{h}\_{t}, \\
[\mathbf{q}\_{t,1}^{C};\mathbf{q}\_{t,2}^{C};\ldots;\mathbf{q}\_{t,n_{h}}^{C}]=\mathbf{q}\_{t}^{C}=\mathbf{W}^{UQ}\mathbf{c}\_{t}^{Q}, \\
[\mathbf{q}\_{t,1}^{R};\mathbf{q}\_{t,2}^{R};\ldots;\mathbf{q}\_{t,n_{h}}^{R}]=\mathbf{q}\_{t}^{R}=\text{RoPE}(\mathbf{W}^{QR}\mathbf{c}\_{t}^{Q}),
\end{array}
\\]

\\[
\mathbf{q}\_{t,i} = [\mathbf{q}\_{t,i}^{C}; \mathbf{q}_{t,i}^{R}],
\\]

\\[
\mathbf{c}_{t}^{KV} = \mathbf{W}^{DKV} \mathbf{h}_t,
\\]

\\[
[\mathbf{k}\_{t,1}^{C}; \mathbf{k}\_{t,2}^{C}; \ldots; \mathbf{k}\_{t,n_h}^{C}] = \mathbf{k}_{t}^{C} = \mathbf{W}^{UK} \mathbf{c}\_{t}^{KV},
\\]

\\[
\mathbf{k}_{t}^{R} = \text{RoPE}(\mathbf{W}^{KR} \mathbf{h}_t),
\\]

\\[
\mathbf{k}\_{t,i} = [\mathbf{k}\_{t,i}^{C}; \mathbf{k}_{t}^{R}],
\\]

\\[
[\mathbf{v}\_{t,1}^{C}; \mathbf{v}\_{t,2}^{C}; \ldots; \mathbf{v}_{t,n_h}^{C}] = \mathbf{v}\_{t}^{C} = \mathbf{W}^{UV} \mathbf{c}\_{t}^{KV},
\\]

\\[
\mathbf{o}\_{t,i}=\sum_{j=1}^{t}\text{Softmax}\_{j}\left(\frac{\mathbf{q}\_{t,i}^{T}\mathbf{k}\_{j,i}}{\sqrt{d_{h}+d_{h}^{R}}}\right)\mathbf{v}_{j,i}^{C},
\\]

\\[
\mathbf{u}\_t = \mathbf{W}^O [\mathbf{o}\_{t,1}; \mathbf{o}\_{t,2}; \ldots; \mathbf{o}_{t,n_h}],
\\]

여기서 파란색 상자로 표시된 벡터는 생성을 위해 캐싱되어야 합니다.

추론 과정에서, 단순한 공식은 어텐션을 위해 \\(\mathbf{c}_t^{KV}\\)에서 \\(\mathbf{k}_t^C\\)와 \\(\mathbf{v}_t^C\\)를 복구해야 합니다. 다행히도, 행렬 곱셈의 결합 법칙 덕분에 \\(\mathbf{W}^{UK}\\), \\(\mathbf{W}^{UQ}\\), \\(\mathbf{W}^{UV}\\)를 \\(\mathbf{W}^O\\)에 흡수할 수 있습니다. 따라서 추론 중에 키와 값을 각 쿼리에 대해 계산할 필요가 없습니다. 이러한 최적화를 통해, 추론 중에 \\(\mathbf{k}_t^C\\)와 \\(\mathbf{v}_t^C\\)를 재계산하는 계산 오버헤드를 피할 수 있습니다.

#### 어텐션 메커니즘의 비교 실험

##### MHA, GQA, MQA의 비교

아래 표는 MHA, GQA, MQA를 갖춘 7B 밀집 모델의 네 가지 어려운 벤치마크에 대한 평가 결과를 보여줍니다. 이 세 모델은 모두 1.33T 토큰에 대해 훈련되었으며, 어텐션 메커니즘을 제외하고는 동일한 아키텍처를 공유합니다. 또한 공정한 비교를 위해, 레이어 수를 조정하여 이들 모델의 파라미터 수를 약 7B로 맞추었습니다.

표에서 볼 수 있듯이, MHA는 이러한 벤치마크에서 GQA와 MQA보다 상당한 이점을 보여줍니다.

| 벤치마크 (메트릭) | 샷 수 | MQA를 갖춘 밀집 7B | GQA를 갖춘 밀집 7B (8 그룹) | MHA를 갖춘 밀집 7B |
|-----------------|------|-----------------|------------------------|-----------------|
| 파라미터 수 | - | 7.1B | 6.9B | 6.9B |
| BBH (EM) | 3-shot | 33.2 | 35.6 | 37.0 |
| MMLU (Acc.) | 5-shot | 37.9 | 41.2 | 45.2 |
| C-Eval (Acc.) | 5-shot | 30.0 | 37.7 | 42.9 |
| CMMLU (Acc.) | 5-shot | 34.6 | 38.4 | 43.5 |

##### MLA와 MHA의 비교

아래 표에서는 MLA와 MHA를 각각 갖춘 MoE 모델의 네 가지 어려운 벤치마크에 대한 평가 결과를 보여줍니다. 확실한 결론을 위해, 두 가지 규모에서 모델을 훈련하고 평가했습니다. 두 개의 소형 MoE 모델은 약 16B의 총 파라미터를 포함하며, 1.33T 토큰에 대해 훈련되었습니다. 두 개의 대형 MoE 모델은 약 250B의 총 파라미터를 포함하며, 420B 토큰에 대해 훈련되었습니다. 또한 두 소형 MoE 모델과 두 대형 MoE 모델은 각각 어텐션 메커니즘을 제외하고 동일한 아키텍처를 공유합니다.

표에서 볼 수 있듯이, MLA는 MHA보다 더 나은 성능을 보여줍니다. 더 중요한 것은, MLA는 MHA보다 훨씬 적은 양의 KV 캐시(소형 MoE 모델의 경우 14%, 대형 MoE 모델의 경우 4%)를 필요로 합니다.

| 벤치마크 (메트릭) | 샷 수 | MHA를 갖춘 소형 MoE | MLA를 갖춘 소형 MoE | MHA를 갖춘 대형 MoE | MLA를 갖춘 대형 MoE |
|-----------------|------|-------------------|-------------------|-------------------|-------------------|
| 활성화된 파라미터 수 | - | 2.5B | 2.4B | 25.0B | 21.5B |
| 총 파라미터 수 | - | 15.8B | 15.7B | 250.8B | 247.4B |
| 토큰당 KV 캐시 (요소 수) | - | 110.6K | 15.6K | 860.2K | 34.6K |
| BBH (EM) | 3-shot | 37.9 | 39.0 | 46.6 | 50.7 |
| MMLU (Acc.) | 5-shot | 48.7 | 50.0 | 57.5 | 59.0 |
| C-Eval (Acc.) | 5-shot | 51.6 | 50.9 | 57.9 | 59.2 |
| CMMLU (Acc.) | 5-shot | 52.3 | 53.4 | 60.7 | 62.5 |

#### 사전 훈련 데이터 편향 제거에 관한 논의

사전 훈련 데이터 준비 과정에서, 우리는 특정 지역 문화의 영향을 받는 가치관과 같은 논쟁의 여지가 있는 콘텐츠를 식별하고 필터링하여 모델이 이러한 논쟁적인 주제에 대해 불필요한 주관적 편향을 보이지 않도록 했습니다. 결과적으로, DeepSeek-V2는 특정 지역 문화와 밀접하게 관련된 테스트 세트에서 약간 더 낮은 성능을 보이는 것을 관찰했습니다. 예를 들어, MMLU에서 평가할 때, DeepSeek-V2는 Mixtral 8x22B와 같은 경쟁 모델과 비교하여 대부분의 테스트 세트에서 비슷하거나 우수한 성능을 달성하지만, 주로 미국 가치관과 관련된 Humanity-Moral 하위 집합에서는 여전히 뒤처집니다.

더 나아가, 우리는 이 하위 집합에 대한 수동 분석을 수행했습니다. 세 명의 고학력 인간 주석자가 MMLU Humanity-Moral 하위 집합의 420개 도덕적 시나리오에 대해 독립적인 주석을 수행했습니다. 그런 다음 그들의 주석과 정답 레이블 간의 일치도를 계산했습니다. 아래 표에서 볼 수 있듯이, 세 명의 인간 주석자와 정답 레이블은 서로 낮은 일치도를 보입니다. 따라서, 우리는 이러한 가치에 민감한 테스트 세트에서 DeepSeek-V2의 비정상적인 성능을 사전 훈련 코퍼스의 편향 제거 노력 때문이라고 생각합니다.

| 일치도 | 정답 레이블 | 주석자 1 | 주석자 2 | 주석자 3 |
|-------|-----------|---------|---------|---------|
| 정답 레이블 | 100.0% | 66.7% | 59.8% | 42.1% |
| 주석자 1 | 66.7% | 100.0% | 57.9% | 69.0% |
| 주석자 2 | 59.8% | 57.9% | 100.0% | 65.5% |
| 주석자 3 | 42.1% | 69.0% | 65.5% | 100.0% |

#### 수학 및 코드에 대한 추가 평가

평가는 수천 개의 중국어 수학 문제로 구성된 SC-Math6 코퍼스를 사용합니다. DeepSeek-V2 Chat(RL)은 오픈소스와 비공개 모델을 포함한 모든 중국어 LLM을 능가합니다.

또한 아래 그림에서 HumanEval과 LiveCodeBench에 대한 더 많은 결과를 공유합니다. LiveCodeBench의 질문은 2023년 9월 1일부터 2024년 4월 1일까지의 기간에서 선택되었습니다. 그림에서 볼 수 있듯이, DeepSeek-V2 Chat(RL)은 LiveCodeBench에서 상당한 능력을 보여주며, 일부 거대 모델을 능가하는 Pass@1 점수를 달성합니다. 이 성능은 DeepSeek-V2 Chat(RL)이 실시간 코딩 작업을 처리하는 강력한 능력을 강조합니다.

![그림 5 HumanEval과 LiveCodeBench에 대한 평가 결과. LiveCodeBench의 질문은 2023년 9월 1일부터 2024년 4월 1일까지의 기간에서 선택되었습니다.](/assets/2025-04-15-deepseek-v2-a-strong-economical-and-efficient-mixture-of-experts-language-model/5.png)

| 모델 이름 | R 레벨 | 종합 점수 | 추론 단계 점수 | 전체 정확도 점수 |
|---------|--------|----------|--------------|----------------|
| GPT-4-1106-Preview | 5 | 90.71 | 91.65 | 89.77 |
| GPT-4 | 5 | 88.40 | 89.10 | 87.71 |
| DeepSeek-V2 Chat (RL) | 5 | 83.35 | 85.73 | 84.54 |
| Ernie-bot 4.0 | 5 | 85.60 | 86.82 | 84.38 |
| Qwen-110B-Chat | 5 | 83.25 | 84.93 | 84.09 |
| GLM-4 | 5 | 84.24 | 85.72 | 82.77 |
| Xinghuo 3.5 | 5 | 83.73 | 85.37 | 82.09 |
| Qwen-72B-Chat | 4 | 78.42 | 80.07 | 79.25 |
| ChatGLM-Turbo | 4 | 57.70 | 60.32 | 55.09 |
| GPT-3.5-Turbo | 4 | 57.05 | 59.61 | 54.50 |
| Qwen-14B-Chat | 4 | 53.12 | 55.99 | 50.26 |
| ChatGLM3-6B | 3 | 40.90 | 44.20 | 37.60 |
| Xinghuo 3.0 | 3 | 40.08 | 45.27 | 34.89 |
| Baichuan2-13B-Chat | 3 | 39.40 | 42.63 | 36.18 |
| Ernie-3.5-turbo | 2 | 25.19 | 27.70 | 22.67 |
| Chinese-Alpaca2-13B | 2 | 20.55 | 22.52 | 18.58 |

#### 평가 형식

각 벤치마크는 특정 형식과 평가 방법을 가지고 있으며, 이를 통해 모델의 다양한 측면을 종합적으로 평가할 수 있습니다. 예를 들어, 일부 벤치마크는 객관식 질문을 사용하여 모델의 지식을 평가하는 반면, 다른 벤치마크는 코드 생성이나 수학 문제 해결과 같은 더 복잡한 작업을 요구합니다.

이러한 다양한 평가 형식을 통해 DeepSeek-V2-Lite의 성능을 다양한 측면에서 평가할 수 있으며, 이는 모델의 강점과 약점을 더 잘 이해하는 데 도움이 됩니다.

- - -
### References
* [DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model](http://arxiv.org/pdf/2405.04434v5)
