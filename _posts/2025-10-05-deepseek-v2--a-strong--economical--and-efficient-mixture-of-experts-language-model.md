---
layout: post
title: "DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model"
date: 2024-05-07 15:56:43
author: "DeepSeek AI"
categories: ["Paper Reviews", "Language-Models"]
tags: ["Multi-Head-Latent-Attention", "DeepSeekMoE", "Low-Rank-Key-Value-Joint-Compression", "Decoupled-Rotary-Position-Embedding", "Device-Limited-Routing", "Auxiliary-Loss-for-Load-Balance", "Token-Dropping-Strategy", "Sparse-Mixture-of-Experts", "Expert-Parallelism", "Efficient-Long-Context-Attention-Mechanism"]
cover: /assets/images/language-models.jpg
use_math: true
---
### TL;DR
#### 이 연구를 시작하게 된 배경과 동기는 무엇입니까?

대규모 언어 모델(LLM)의 발전은 인공지능 분야에서 혁명적인 변화를 가져왔지만, 동시에 심각한 기술적 도전 과제들을 야기했습니다. 모델의 크기가 증가함에 따라 훈련과 추론에 필요한 계산 자원도 기하급수적으로 늘어나고 있어, 경제적이고 효율적인 모델 개발의 필요성이 대두되었습니다. 특히 기존 트랜스포머 아키텍처는 추론 과정에서 무거운 키-값(KV) 캐시로 인해 심각한 성능 병목 현상을 겪고 있었으며, 이는 대규모 언어 모델의 실용적 배포를 제한하는 주요 장애물이었습니다.

연구팀은 이러한 문제를 해결하기 위해 두 가지 핵심 혁신에 주목했습니다. 첫째, 어텐션 메커니즘의 효율성을 근본적으로 개선할 수 있는 새로운 접근법이 필요했고, 둘째, 모델의 계산 비용을 획기적으로 줄이면서도 성능을 유지할 수 있는 아키텍처 설계가 요구되었습니다. 특히 중국어와 영어를 동시에 지원하는 이중 언어 모델 개발은 글로벌 AI 연구에서 중요한 과제로 인식되고 있었습니다.

#### 이 연구에서 제시하는 새로운 해결 방법은 무엇입니까?

DeepSeek-V2는 Multi-head Latent Attention(MLA)과 DeepSeekMoE라는 두 가지 혁신적인 기술을 통해 이러한 도전 과제들을 해결하고자 합니다. MLA는 키-값 캐시를 저랭크 잠재 벡터로 압축함으로써 추론 효율성을 획기적으로 개선하는 새로운 어텐션 메커니즘입니다. 기존 어텐션 방식과 달리 MLA는 키와 값을 공동으로 압축하여 추론 중 메모리 사용량을 크게 줄이면서도 모델 성능을 유지할 수 있습니다.

DeepSeekMoE는 Mixture-of-Experts(MoE) 아키텍처를 혁신적으로 재설계하여 모델의 계산 효율성을 높입니다. 이 접근법은 전문가들을 더 세밀하게 분할하고, 라우팅된 전문가들 간의 지식 중복을 완화하는 독특한 메커니즘을 도입했습니다. 결과적으로 동일한 수의 활성화된 전문가 파라미터로 기존 MoE 아키텍처보다 훨씬 우수한 성능을 달성할 수 있게 되었습니다.

#### 제안된 방법은 어떻게 구현되었습니까?

DeepSeek-V2의 구현은 매우 정교하고 체계적인 접근을 보여줍니다. 총 236B개의 파라미터를 가진 모델은 8.1T 토큰으로 구성된 고품질 다중 소스 코퍼스에서 사전 훈련되었으며, 중국어 토큰이 영어 토큰보다 약 12% 더 많은 이중 언어 특성을 가집니다. 훈련 과정에서는 AdamW 옵티마이저와 복잡한 학습률 스케줄링 전략을 사용하여 모델의 안정적인 학습을 보장했습니다.

MLA 구현에서는 128개의 어텐션 헤드와 128의 헤드당 차원을 설정하고, KV 압축 차원을 512로 제한하여 메모리 효율성을 극대화했습니다. DeepSeekMoE는 각 레이어에 2개의 공유 전문가와 160개의 라우팅된 전문가를 배치하고, 각 토큰당 6개의 전문가를 활성화하도록 설계되었습니다. 특히 장치 제한 라우팅과 로드 밸런스를 위한 보조 손실 함수를 도입하여 계산 효율성을 더욱 높였습니다.

#### 이 연구의 결과가 가지는 의미는 무엇입니까?

DeepSeek-V2의 성과는 대규모 언어 모델 분야에 중요한 이정표를 제시합니다. 단 21B개의 활성화된 파라미터로 오픈소스 모델 중 최고 수준의 성능을 달성했으며, 동시에 DeepSeek 67B 대비 42.5%의 훈련 비용 절감, 93.3%의 KV 캐시 감소, 5.76배의 생성 처리량 향상을 이루어냈습니다. AlpacaEval 2.0에서 38.9의 길이 제어 승률, MT-Bench에서 8.97의 점수를 기록하며 개방형 대화 벤치마크에서도 탁월한 성능을 보여주었습니다.

이 연구는 단순한 기술적 혁신을 넘어 AI 기술의 실용적 배포와 접근성 향상에 중요한 기여를 합니다. MLA와 DeepSeekMoE 아키텍처는 대규모 언어 모델의 계산 효율성과 성능 사이의 트레이드오프를 근본적으로 재정의했으며, 오픈소스 AI 생태계의 발전에 새로운 방향을 제시했습니다. 특히 중국어와 영어를 동시에 지원하는 고성능 이중 언어 모델을 개발함으로써 글로벌 AI 연구에 의미 있는 진전을 이루었습니다.
- - -
# DeepSeek-V2: 강력하고 경제적이며 효율적인 Mixture-of-Experts 언어 모델

## 초록

DeepSeek-V2는 경제적인 훈련과 효율적인 추론을 특징으로 하는 강력한 Mixture-of-Experts(MoE) 언어 모델입니다. 이 모델은 총 236B개의 파라미터를 보유하고 있으며, 각 토큰당 21B개의 파라미터가 활성화되고, 128K 토큰의 컨텍스트 길이를 지원합니다.

DeepSeek-V2의 핵심 혁신은 두 가지 새로운 아키텍처에 있습니다. 첫째, Multi-head Latent Attention(MLA)은 Key-Value(KV) 캐시를 잠재 벡터로 크게 압축하여 효율적인 추론을 보장합니다. 둘째, DeepSeekMoE는 희소 계산을 통해 경제적인 비용으로 강력한 모델을 훈련할 수 있게 합니다.

![성능 비교 그래프](https://arxiv.org/html/2405.04434/x1.png)

위 그래프는 다양한 오픈소스 언어 모델들의 활성화된 파라미터 수와 MMLU(Massive Multitask Language Understanding) 정확도 간의 관계를 보여줍니다. DeepSeek-V2는 단 21B개의 활성화된 파라미터로도 최고 수준의 성능을 달성하고 있음을 확인할 수 있습니다.

![효율성 비교](https://arxiv.org/html/2405.04434/x2.png)

성능 개선 지표를 보면, DeepSeek-V2는 이전 모델인 DeepSeek 67B와 비교하여 훈련 비용을 42.5% 절감하고, KV 캐시를 93.3% 감소시키며, 최대 생성 처리량을 5.76배 향상시켰습니다.

모델은 8.1T 토큰으로 구성된 고품질 다중 소스 코퍼스에서 사전 훈련되었으며, 이후 Supervised Fine-Tuning(SFT)과 Reinforcement Learning(RL)을 통해 잠재력을 완전히 발휘하도록 조정되었습니다. 평가 결과, 21B개의 활성화된 파라미터만으로도 DeepSeek-V2와 그 채팅 버전들은 오픈소스 모델 중 최고 수준의 성능을 달성했습니다.

## 서론

지난 몇 년간 대규모 언어 모델(LLM)은 급속한 발전을 이루며 인공일반지능(AGI)의 새벽을 엿보게 했습니다. 일반적으로 LLM의 지능은 파라미터 수가 증가함에 따라 향상되며, 다양한 작업에서 창발적 능력을 보여줍니다. 그러나 이러한 개선은 훈련을 위한 더 큰 컴퓨팅 자원과 추론 처리량의 잠재적 감소라는 비용을 수반합니다.

이러한 문제를 해결하기 위해 DeepSeek-V2를 소개합니다. 이는 혁신적인 트랜스포머 아키텍처를 통해 경제적인 훈련과 효율적인 추론을 특징으로 하는 강력한 오픈소스 MoE 언어 모델입니다.

### 핵심 기술 혁신

DeepSeek-V2는 트랜스포머 프레임워크 내에서 어텐션 모듈과 Feed-Forward Networks(FFN)을 최적화합니다. 이를 위해 제안된 Multi-head Latent Attention(MLA)과 DeepSeekMoE를 활용합니다.

**Multi-head Latent Attention(MLA)의 필요성**

기존 Multi-Head Attention(MHA)의 Key-Value 캐시는 LLM의 추론 효율성에 심각한 장애물이 됩니다. 이를 해결하기 위해 Grouped-Query Attention(GQA)이나 Multi-Query Attention(MQA) 같은 다양한 접근법이 탐구되었지만, 이러한 방법들은 KV 캐시를 줄이려는 시도에서 종종 성능을 타협합니다.

MLA는 이러한 문제를 해결하기 위해 저랭크 키-값 공동 압축을 갖춘 어텐션 메커니즘을 도입합니다. 실험적으로 MLA는 MHA보다 우수한 성능을 달성하면서 동시에 추론 중 KV 캐시를 크게 줄여 추론 효율성을 향상시킵니다.

**DeepSeekMoE의 장점**

Feed-Forward Networks의 경우, DeepSeekMoE 아키텍처를 따릅니다. 이는 전문가 특화의 더 높은 잠재력을 위해 세밀한 전문가 분할과 공유 전문가 격리를 채택합니다. DeepSeekMoE 아키텍처는 GShard와 같은 기존 MoE 아키텍처와 비교하여 큰 장점을 보여주며, 경제적인 비용으로 강력한 모델을 훈련할 수 있게 합니다.

![DeepSeek-V2 아키텍처](https://arxiv.org/html/2405.04434/x3.png)

위 그림은 DeepSeek-V2의 전체 아키텍처를 보여줍니다. MLA는 생성을 위한 KV 캐시를 크게 줄여 효율적인 추론을 보장하고, DeepSeekMoE는 희소 아키텍처를 통해 경제적인 비용으로 강력한 모델 훈련을 가능하게 합니다.

### 데이터와 훈련 과정

DeepSeek-V2는 8.1T 토큰으로 구성된 고품질 다중 소스 사전 훈련 코퍼스에서 훈련되었습니다. 이전 DeepSeek 67B에서 사용된 코퍼스와 비교하여, 이 코퍼스는 특히 중국어 데이터의 확장된 양과 더 높은 데이터 품질을 특징으로 합니다.

훈련 과정은 다음과 같이 진행됩니다.
1. 전체 사전 훈련 코퍼스에서 DeepSeek-V2를 사전 훈련
2. 수학, 코드, 작문, 추론, 안전성 등 다양한 도메인을 포괄하는 1.5M개의 대화 세션을 수집하여 DeepSeek-V2 Chat(SFT)에 대한 Supervised Fine-Tuning 수행
3. Group Relative Policy Optimization(GRPO)을 사용하여 인간 선호도와 모델을 추가로 정렬하고 DeepSeek-V2 Chat(RL) 생성

### 성능 평가 결과

영어와 중국어의 광범위한 벤치마크에서 DeepSeek-V2를 평가하고 대표적인 오픈소스 모델들과 비교했습니다. 평가 결과는 21B개의 활성화된 파라미터만으로도 DeepSeek-V2가 오픈소스 모델 중 최고 수준의 성능을 달성하며 가장 강력한 오픈소스 MoE 언어 모델이 되었음을 보여줍니다.

특히 주목할 만한 성과는 다음과 같습니다.
- AlpacaEval 2.0에서 38.9의 길이 제어 승률
- MT-Bench에서 8.97의 전체 점수
- AlignBench에서 7.91의 전체 점수

이러한 영어 개방형 대화 평가는 DeepSeek-V2 Chat(RL)이 오픈소스 채팅 모델 중 최고 수준의 성능을 가지고 있음을 보여줍니다. 또한 AlignBench 평가는 중국어에서 DeepSeek-V2 Chat(RL)이 모든 오픈소스 모델을 능가하고 심지어 대부분의 폐쇄형 모델도 이긴다는 것을 나타냅니다.

### 연구 기여도

MLA와 DeepSeekMoE에 대한 추가 연구와 개발을 촉진하기 위해, 오픈소스 커뮤니티를 위해 MLA와 DeepSeekMoE를 갖춘 더 작은 모델인 DeepSeek-V2-Lite도 공개합니다. 이 모델은 총 15.7B개의 파라미터를 가지며, 각 토큰당 2.4B개가 활성화됩니다.

DeepSeek-V2는 두 가지 핵심 기술을 결합하여 강력한 성능, 경제적인 훈련 비용, 효율적인 추론 처리량을 동시에 달성합니다. 이는 대규모 언어 모델의 실용적 배포와 광범위한 채택에 중요한 진전을 나타냅니다.
## 아키텍처

DeepSeek-V2는 기본적으로 트랜스포머 아키텍처를 따르고 있으며, 각 트랜스포머 블록은 어텐션 모듈과 Feed-Forward Network(FFN)으로 구성됩니다. 하지만 어텐션 모듈과 FFN 모두에서 혁신적인 아키텍처를 설계하고 채택했습니다. 어텐션의 경우 MLA(Multi-head Latent Attention)를 설계했으며, 이는 저랭크 키-값 공동 압축을 활용하여 추론 시 키-값 캐시의 병목 현상을 제거하고 효율적인 추론을 지원합니다. FFN의 경우 DeepSeekMoE 아키텍처를 채택했으며, 이는 경제적인 비용으로 강력한 모델을 훈련할 수 있게 하는 고성능 MoE 아키텍처입니다.

![DeepSeek-V2 아키텍처](https://arxiv.org/html/2405.04434/x4.png)

위 그림은 Multi-Head Attention(MHA), Grouped-Query Attention(GQA), Multi-Query Attention(MQA), 그리고 Multi-head Latent Attention(MLA)의 서로 다른 어텐션 메커니즘을 보여주는 아키텍처 다이어그램입니다. 이 다이어그램은 입력 쿼리, 키, 값과 같은 핵심 구성 요소와 관계를 보여주며, MLA의 경우 키와 값을 잠재 벡터로 압축하는 과정을 나타냅니다. 이 그림의 연구적 의의는 MLA가 키와 값을 잠재 벡터로 공동 압축함으로써 추론 중 키-값(KV) 캐시를 크게 줄일 수 있다는 핵심 기여를 보여주는 것입니다.

다른 세부 사항들(예: 레이어 정규화 및 FFN의 활성화 함수)의 경우, 특별히 명시되지 않는 한 DeepSeek-V2는 DeepSeek 67B의 설정을 따릅니다.

### Multi-Head Latent Attention: 추론 효율성 향상

기존 트랜스포머 모델은 일반적으로 Multi-Head Attention(MHA)을 채택하지만, 생성 과정에서 무거운 Key-Value(KV) 캐시가 추론 효율성을 제한하는 병목 현상이 됩니다. KV 캐시를 줄이기 위해 Multi-Query Attention(MQA)과 Grouped-Query Attention(GQA)가 제안되었습니다. 이들은 더 적은 양의 KV 캐시를 필요로 하지만, 성능이 MHA에 미치지 못합니다.

DeepSeek-V2에서는 Multi-head Latent Attention(MLA)이라는 혁신적인 어텐션 메커니즘을 설계했습니다. 저랭크 키-값 공동 압축을 갖춘 MLA는 MHA보다 우수한 성능을 달성하면서도 훨씬 적은 양의 KV 캐시를 필요로 합니다.

#### 기본 개념: 표준 Multi-Head Attention

먼저 배경으로 표준 MHA 메커니즘을 소개하겠습니다. $d$를 임베딩 차원, $n_h$를 어텐션 헤드 수, $d_h$를 헤드당 차원, $\mathbf{h}_t \in \mathbb{R}^d$를 어텐션 레이어에서 $t$번째 토큰의 어텐션 입력이라고 하겠습니다.

표준 MHA는 먼저 세 개의 행렬 $W^Q, W^K, W^V \in \mathbb{R}^{d_h n_h \times d}$를 통해 $\mathbf{q}_t, \mathbf{k}_t, \mathbf{v}_t \in \mathbb{R}^{d_h n_h}$를 생성합니다.

$$\mathbf{q}_t = W^Q \mathbf{h}_t$$

$$\mathbf{k}_t = W^K \mathbf{h}_t$$

$$\mathbf{v}_t = W^V \mathbf{h}_t$$

이해를 돕기 위해 이 과정을 구체적으로 설명하면, 각 토큰의 숨겨진 표현 $\mathbf{h}_t$가 세 개의 서로 다른 선형 변환을 거쳐 쿼리, 키, 값 벡터로 변환됩니다. 이는 마치 하나의 정보를 세 가지 다른 관점에서 바라보는 것과 같습니다.

그 다음, $\mathbf{q}_t, \mathbf{k}_t, \mathbf{v}_t$는 멀티헤드 어텐션 계산을 위해 $n_h$개의 헤드로 분할됩니다.

$$[\mathbf{q}_{t,1}; \mathbf{q}_{t,2}; ...; \mathbf{q}_{t,n_h}] = \mathbf{q}_t$$

$$[\mathbf{k}_{t,1}; \mathbf{k}_{t,2}; ...; \mathbf{k}_{t,n_h}] = \mathbf{k}_t$$

$$[\mathbf{v}_{t,1}; \mathbf{v}_{t,2}; ...; \mathbf{v}_{t,n_h}] = \mathbf{v}_t$$

여기서 $\mathbf{q}\_{t,i}, \mathbf{k}\_{t,i}, \mathbf{v}\_{t,i} \in \mathbb{R}^{d_h}$는 각각 $i$번째 어텐션 헤드의 쿼리, 키, 값을 나타냅니다. 각 헤드에서 어텐션 출력은 다음과 같이 계산됩니다.

$$\mathbf{o}_{t,i} = \sum_{j=1}^t \text{Softmax}_j\left(\frac{\mathbf{q}_{t,i}^T \mathbf{k}_{j,i}}{\sqrt{d_h}}\right) \mathbf{v}_{j,i}$$

이 식에서 중요한 점은 현재 토큰 $t$가 이전의 모든 토큰들 $j=1, ..., t$와 어텐션을 계산한다는 것입니다. 이는 자기회귀적 언어 모델의 핵심 특성으로, 현재 토큰이 이전 모든 토큰들의 정보를 활용할 수 있게 합니다.

최종적으로 모든 헤드의 출력을 연결하고 출력 투영 행렬을 적용합니다.

$$\mathbf{u}_t = W^O [\mathbf{o}_{t,1}; \mathbf{o}_{t,2}; ...; \mathbf{o}_{t,n_h}]$$

여기서 $W^O \in \mathbb{R}^{d \times d_h n_h}$는 출력 투영 행렬입니다.

추론 과정에서 추론을 가속화하기 위해 모든 키와 값이 캐시되어야 하므로, MHA는 각 토큰당 $2 n_h d_h l$개의 요소를 캐시해야 합니다. 여기서 $l$은 레이어 수입니다. 모델 배포에서 이러한 무거운 KV 캐시는 최대 배치 크기와 시퀀스 길이를 제한하는 큰 병목 현상입니다.

#### 저랭크 키-값 공동 압축

MLA의 핵심은 KV 캐시를 줄이기 위한 키와 값의 저랭크 공동 압축입니다. 이 혁신적인 접근법은 키와 값을 별도로 처리하는 대신 공동으로 압축하여 더 효율적인 표현을 만듭니다.

$$\mathbf{c}_t^{KV} = W^{DKV} \mathbf{h}_t$$

$$\mathbf{k}_t^C = W^{UK} \mathbf{c}_t^{KV}$$

$$\mathbf{v}_t^C = W^{UV} \mathbf{c}_t^{KV}$$

여기서 $\mathbf{c}_t^{KV} \in \mathbb{R}^{d_c}$는 키와 값을 위한 압축된 잠재 벡터이고, $d_c (\ll d_h n_h)$는 KV 압축 차원을 나타냅니다. $W^{DKV} \in \mathbb{R}^{d_c \times d}$는 압축 행렬이고, $W^{UK}, W^{UV} \in \mathbb{R}^{d_h n_h \times d_c}$는 각각 키와 값을 위한 복원 행렬입니다.

이 압축 과정을 직관적으로 이해하면, 원래의 고차원 키-값 정보를 훨씬 작은 차원의 잠재 공간으로 압축한 다음, 필요할 때 이를 다시 복원하는 것입니다. 이는 정보의 핵심적인 부분만을 보존하면서 메모리 사용량을 크게 줄이는 효과적인 방법입니다.

추론 과정에서 MLA는 $\mathbf{c}_t^{KV}$만 캐시하면 되므로, KV 캐시는 $d_c l$개의 요소만 가지면 됩니다. 또한 추론 중에는 $W^{UK}$가 $W^Q$에 흡수될 수 있고, $W^{UV}$가 $W^O$에 흡수될 수 있어서, 어텐션을 위해 키와 값을 실제로 계산할 필요가 없습니다.

훈련 중 활성화 메모리를 줄이기 위해 KV 캐시를 줄일 수는 없지만 쿼리에 대해서도 저랭크 압축을 수행합니다.

$$\mathbf{c}_t^Q = W^{DQ} \mathbf{h}_t$$

$$\mathbf{q}_t^C = W^{UQ} \mathbf{c}_t^Q$$

여기서 $\mathbf{c}_t^Q \in \mathbb{R}^{d_c'}$는 쿼리를 위한 압축된 잠재 벡터이고, $d_c' (\ll d_h n_h)$는 쿼리 압축 차원을 나타냅니다.

#### 분리된 회전 위치 임베딩

DeepSeek 67B를 따라 DeepSeek-V2에서도 Rotary Position Embedding(RoPE)을 사용하려고 했습니다. 그러나 RoPE는 저랭크 KV 압축과 호환되지 않습니다. 구체적으로, RoPE는 키와 쿼리 모두에 대해 위치에 민감합니다. 키 $\mathbf{k}_t^C$에 RoPE를 적용하면, $W^{UK}$가 위치에 민감한 RoPE 행렬과 결합됩니다.

이 문제를 해결하기 위해 분리된 RoPE 전략을 제안합니다. 이 전략은 RoPE를 수행하기 위해 추가적인 멀티헤드 쿼리 $\mathbf{q}_{t,i}^R \in \mathbb{R}^{d_h^R}$와 공유 키 $\mathbf{k}_t^R \in \mathbb{R}^{d_h^R}$를 사용합니다. 여기서 $d_h^R$는 분리된 쿼리와 키의 헤드당 차원을 나타냅니다.

분리된 RoPE 전략을 갖춘 MLA는 다음과 같은 계산을 수행합니다.

$$[\mathbf{q}_{t,1}^R; \mathbf{q}_{t,2}^R; ...; \mathbf{q}_{t,n_h}^R] = \mathbf{q}_t^R = \text{RoPE}(W^{QR} \mathbf{c}_t^Q)$$
$$\mathbf{k}_t^R = \text{RoPE}(W^{KR} \mathbf{h}_t)$$

그 다음 압축된 부분과 RoPE 부분을 연결합니다.

$$\mathbf{q}_{t,i} = [\mathbf{q}_{t,i}^C; \mathbf{q}_{t,i}^R]$$

$$\mathbf{k}_{t,i} = [\mathbf{k}_{t,i}^C; \mathbf{k}_t^R]$$

최종 어텐션 계산은 다음과 같습니다.

$$\mathbf{o}_{t,i} = \sum_{j=1}^t \text{Softmax}_j\left(\frac{\mathbf{q}_{t,i}^T \mathbf{k}_{j,i}}{\sqrt{d_h + d_h^R}}\right) \mathbf{v}_{j,i}^C$$

추론 중에는 분리된 키도 캐시되어야 하므로, DeepSeek-V2는 총 $(d_c + d_h^R) l$개의 요소를 포함하는 KV 캐시가 필요합니다.

#### 키-값 캐시 비교

다음 표는 서로 다른 어텐션 메커니즘 간의 토큰당 KV 캐시를 비교한 것입니다.

| 어텐션 메커니즘               | 토큰당 KV 캐시 (요소 수)                    | 성능    |
| ----------------------------- | ------------------------------------------- | ------- |
| Multi-Head Attention (MHA)    | $2 n_h d_h l$                               | 강함    |
| Grouped-Query Attention (GQA) | $2 n_g d_h l$                               | 보통    |
| Multi-Query Attention (MQA)   | $2 d_h l$                                   | 약함    |
| MLA (제안 방법)               | $(d_c + d_h^R) l \approx \frac{9}{2} d_h l$ | 더 강함 |

여기서 $n_h$는 어텐션 헤드 수, $d_h$는 어텐션 헤드당 차원, $l$은 레이어 수, $n_g$는 GQA의 그룹 수를 나타냅니다. DeepSeek-V2에서는 $d_c$를 $4d_h$로, $d_h^R$를 $\frac{d_h}{2}$로 설정했습니다. 따라서 KV 캐시는 단 2.25개 그룹을 가진 GQA와 동일하지만, 성능은 MHA보다 강력합니다.

MLA는 적은 양의 KV 캐시만 필요로 하면서도 MHA보다 우수한 성능을 달성할 수 있습니다. 이는 저랭크 공동 압축과 분리된 RoPE 전략의 혁신적인 조합 덕분입니다.
### DeepSeekMoE: 경제적 비용으로 강력한 모델 훈련

FFN의 경우, DeepSeekMoE 아키텍처를 채택합니다. DeepSeekMoE는 두 가지 핵심 아이디어를 가지고 있습니다. 첫째, 더 높은 전문가 특화와 더 정확한 지식 습득을 위해 전문가를 더 세밀한 단위로 분할하는 것이고, 둘째, 라우팅된 전문가들 간의 지식 중복을 완화하기 위해 일부 공유 전문가를 격리하는 것입니다. 동일한 수의 활성화된 전문가 파라미터와 총 전문가 파라미터로 DeepSeekMoE는 GShard와 같은 기존 MoE 아키텍처를 큰 폭으로 능가할 수 있습니다.

#### 기본 아키텍처

$\mathbf{u}_t$를 $t$번째 토큰의 FFN 입력이라고 하면, FFN 출력 $\mathbf{h}_t'$를 다음과 같이 계산합니다.

$$\mathbf{h}_t' = \mathbf{u}_t + \sum_{i=1}^{N_s} \text{FFN}_i^{(s)}(\mathbf{u}_t) + \sum_{i=1}^{N_r} g_{i,t} \text{FFN}_i^{(r)}(\mathbf{u}_t)$$

이 식을 직관적으로 이해하면, 최종 출력은 세 부분의 합으로 구성됩니다. 첫 번째는 원본 입력 $\mathbf{u}_t$로 잔차 연결의 역할을 합니다. 두 번째는 모든 토큰이 공통으로 사용하는 공유 전문가들의 출력이고, 세 번째는 토큰별로 선택적으로 활성화되는 라우팅된 전문가들의 가중 출력입니다.

게이트 값 $g_{i,t}$는 다음과 같이 계산됩니다.

$$g_{i,t} = \begin{cases}
s_{i,t}, & s_{i,t} \in \text{Topk}(\{s_{j,t}|1 \leqslant j \leqslant N_r\}, K_r) \\
0, & \text{otherwise}
\end{cases}$$

$$s_{i,t} = \text{Softmax}_i(\mathbf{u}_t^T \mathbf{e}_i)$$

여기서 $N_s$와 $N_r$는 각각 공유 전문가와 라우팅된 전문가의 수를 나타내고, $\text{FFN}\_i^{(s)}(\cdot)$와 $\text{FFN}\_i^{(r)}(\cdot)$는 각각 $i$번째 공유 전문가와 $i$번째 라우팅된 전문가를 나타냅니다. $K_r$는 활성화된 라우팅된 전문가의 수이고, $g_{i,t}$는 $i$번째 전문가에 대한 게이트 값입니다. $s_{i,t}$는 토큰-전문가 친화도이고, $\mathbf{e}_i$는 이 레이어에서 $i$번째 라우팅된 전문가의 중심점입니다.

이 메커니즘의 핵심은 각 토큰이 모든 공유 전문가의 출력을 받으면서 동시에 자신에게 가장 적합한 소수의 라우팅된 전문가만을 선택적으로 활용한다는 것입니다. 이는 마치 모든 학생이 공통 기초 과목을 수강하면서 동시에 자신의 관심사에 맞는 전공 과목을 선택하는 것과 유사합니다.

#### 장치 제한 라우팅

전문가 병렬성이 사용될 때 MoE 관련 통신 비용을 제한하기 위해 장치 제한 라우팅 메커니즘을 설계했습니다. 전문가 병렬성이 사용되면 라우팅된 전문가들이 여러 장치에 분산됩니다. 각 토큰에 대해 MoE 관련 통신 빈도는 대상 전문가들이 분포하는 장치 수에 비례합니다.

DeepSeekMoE의 세밀한 전문가 분할로 인해 활성화된 전문가의 수가 클 수 있으므로, 전문가 병렬성을 적용하면 MoE 관련 통신이 더 비용이 많이 듭니다. DeepSeek-V2의 경우, 라우팅된 전문가의 순수한 top-K 선택 외에도 각 토큰의 대상 전문가들이 최대 $M$개의 장치에 분산되도록 추가로 보장합니다.

구체적으로, 각 토큰에 대해 먼저 가장 높은 친화도 점수를 가진 전문가들이 있는 $M$개의 장치를 선택합니다. 그 다음 이 $M$개 장치의 전문가들 중에서 top-K 선택을 수행합니다. 실제로 $M \geq 3$일 때 장치 제한 라우팅이 제한되지 않은 top-K 라우팅과 거의 일치하는 좋은 성능을 달성할 수 있음을 발견했습니다.

#### 로드 밸런스를 위한 보조 손실

자동으로 학습된 라우팅 전략에 대해 로드 밸런스를 고려합니다. 첫째, 불균형한 로드는 라우팅 붕괴의 위험을 증가시켜 일부 전문가가 완전히 훈련되고 활용되는 것을 방해합니다. 둘째, 전문가 병렬성이 사용될 때 불균형한 로드는 계산 효율성을 감소시킵니다.

DeepSeek-V2의 훈련 중에 전문가 수준 로드 밸런스($\mathcal{L}\_{\text{ExpBal}}$), 장치 수준 로드 밸런스($\mathcal{L}\_{\text{DevBal}}$), 통신 밸런스($\mathcal{L}\_{\text{CommBal}}$)를 각각 제어하기 위한 세 가지 보조 손실을 설계했습니다.

**전문가 수준 밸런스 손실**

라우팅 붕괴의 위험을 완화하기 위해 전문가 수준 밸런스 손실을 사용합니다.

$$\mathcal{L}_{\text{ExpBal}} = \alpha_1 \sum_{i=1}^{N_r} f_i P_i$$

$$f_i = \frac{N_r}{K_r T} \sum_{t=1}^T \mathbf{1}(\text{Token } t \text{ selects Expert } i)$$

$$P_i = \frac{1}{T} \sum_{t=1}^T s_{i,t}$$

여기서 $\alpha_1$은 전문가 수준 밸런스 인수라는 하이퍼파라미터이고, $\mathbf{1}(\cdot)$는 지시 함수이며, $T$는 시퀀스의 토큰 수를 나타냅니다. $f_i$는 전문가 $i$가 선택되는 빈도를 나타내고, $P_i$는 전문가 $i$에 대한 평균 친화도를 나타냅니다.

**장치 수준 밸런스 손실**

전문가 수준 밸런스 손실 외에도 서로 다른 장치 간의 균형 잡힌 계산을 보장하기 위해 장치 수준 밸런스 손실을 추가로 설계했습니다. DeepSeek-V2의 훈련 과정에서 모든 라우팅된 전문가를 $D$개의 그룹 $\{\mathcal{E}_1, \mathcal{E}_2, ..., \mathcal{E}_D\}$로 분할하고, 각 그룹을 단일 장치에 배포합니다.

장치 수준 밸런스 손실은 다음과 같이 계산됩니다.

$$\mathcal{L}_{\text{DevBal}} = \alpha_2 \sum_{i=1}^D f_i' P_i'$$

$$f_i' = \frac{1}{|\mathcal{E}_i|} \sum_{j \in \mathcal{E}_i} f_j$$

$$P_i' = \sum_{j \in \mathcal{E}_i} P_j$$

여기서 $\alpha_2$는 장치 수준 밸런스 인수라는 하이퍼파라미터입니다.

**통신 밸런스 손실**

마지막으로 각 장치의 통신이 균형을 이루도록 보장하기 위해 통신 밸런스 손실을 도입합니다. 장치 제한 라우팅 메커니즘이 각 장치의 송신 통신이 제한되도록 보장하지만, 특정 장치가 다른 장치보다 더 많은 토큰을 받으면 실제 통신 효율성도 영향을 받습니다.

이 문제를 완화하기 위해 다음과 같은 통신 밸런스 손실을 설계했습니다.

$$\mathcal{L}_{\text{CommBal}} = \alpha_3 \sum_{i=1}^D f_i'' P_i''$$

$$f_i'' = \frac{D}{MT} \sum_{t=1}^T \mathbf{1}(\text{Token } t \text{ is sent to Device } i)$$

$$P_i'' = \sum_{j \in \mathcal{E}_i} P_j$$

여기서 $\alpha_3$는 통신 밸런스 인수라는 하이퍼파라미터입니다.

장치 제한 라우팅 메커니즘은 각 장치가 최대 $MT$개의 숨겨진 상태를 다른 장치로 전송하도록 보장하는 원리로 작동합니다. 동시에 통신 밸런스 손실은 각 장치가 다른 장치로부터 약 $MT$개의 숨겨진 상태를 받도록 장려하는 데 사용됩니다. 통신 밸런스 손실은 장치 간의 균형 잡힌 정보 교환을 보장하여 효율적인 통신을 촉진합니다.

#### 토큰 드롭핑 전략

밸런스 손실이 균형 잡힌 로드를 장려하는 것을 목표로 하지만, 엄격한 로드 밸런스를 보장할 수는 없다는 점을 인정하는 것이 중요합니다. 불균형한 로드로 인한 계산 낭비를 더욱 완화하기 위해 훈련 중 장치 수준 토큰 드롭핑 전략을 도입합니다.

이 접근법은 먼저 각 장치의 평균 계산 예산을 계산하는데, 이는 각 장치의 용량 인수가 1.0과 동일함을 의미합니다. 그 다음 Riquelme et al.(2021)에서 영감을 받아 계산 예산에 도달할 때까지 각 장치에서 가장 낮은 친화도 점수를 가진 토큰을 드롭합니다. 또한 훈련 시퀀스의 약 10%에 속하는 토큰은 절대 드롭되지 않도록 보장합니다.

이러한 방식으로 효율성 요구사항에 따라 추론 중에 토큰을 드롭할지 여부를 유연하게 결정할 수 있으며, 항상 훈련과 추론 간의 일관성을 보장할 수 있습니다.

이 토큰 드롭핑 전략은 실제 배포에서 매우 중요한 의미를 가집니다. 훈련 중에 이미 토큰 드롭핑을 경험한 모델은 추론 시에도 유사한 상황에서 안정적인 성능을 유지할 수 있습니다. 이는 마치 훈련 중에 다양한 조건에 노출된 모델이 실제 환경에서도 더 강건한 성능을 보이는 것과 같은 원리입니다.
## 사전 훈련

DeepSeek-V2의 사전 훈련 과정은 8.1T 토큰으로 구성된 고품질 다중 소스 코퍼스를 활용하여 수행되었습니다. 이 과정에서는 데이터 품질 향상, 하이퍼파라미터 최적화, 인프라 구축, 그리고 긴 컨텍스트 확장 등 다양한 기술적 혁신이 적용되었습니다.

### 실험 설정

#### 데이터 구축

DeepSeek-V2의 사전 훈련을 위한 데이터 구축 과정은 이전 DeepSeek 67B 모델과 동일한 데이터 처리 단계를 유지하면서도 데이터 양을 확장하고 품질을 크게 향상시켰습니다. 이러한 개선은 여러 차원에서 이루어졌습니다.

먼저 사전 훈련 코퍼스를 확장하기 위해 인터넷 데이터의 잠재력을 탐구하고 정제 과정을 최적화하여 이전에 잘못 삭제되었던 대량의 데이터를 복구했습니다. 이는 마치 광산에서 놓쳤던 귀중한 광물을 다시 발굴하는 것과 같은 과정으로, 기존 필터링 알고리즘의 한계를 극복하여 유용한 데이터를 더 많이 확보할 수 있었습니다. 특히 중국어 데이터를 더 많이 포함시켜 중국 인터넷에서 이용 가능한 코퍼스를 더 잘 활용하고자 했습니다.

데이터 양뿐만 아니라 품질에도 중점을 두었습니다. 다양한 소스에서 고품질 데이터로 사전 훈련 코퍼스를 풍부하게 만들었으며, 동시에 품질 기반 필터링 알고리즘을 개선했습니다. 개선된 알고리즘은 대량의 비유익한 데이터를 제거하면서도 가치 있는 데이터는 대부분 보존하도록 보장합니다. 이는 정교한 체질 과정과 같아서, 불순물은 걸러내면서 영양분은 최대한 보존하는 것과 유사합니다.

또한 특정 지역 문화에서 비롯된 데이터 편향을 완화하기 위해 사전 훈련 코퍼스에서 논란이 될 수 있는 콘텐츠를 필터링했습니다. 이러한 필터링 전략의 영향에 대한 자세한 논의는 부록에서 제시되어 있습니다.

토크나이저는 DeepSeek 67B에서 사용된 것과 동일한 것을 채택했으며, 이는 Byte-level Byte-Pair Encoding(BBPE) 알고리즘을 기반으로 구축되었고 어휘 크기는 100K입니다. 토큰화된 사전 훈련 코퍼스는 총 8.1T 토큰을 포함하며, 중국어 토큰이 영어 토큰보다 약 12% 더 많습니다. 이러한 언어 분포는 DeepSeek-V2가 진정한 이중 언어 모델로서 기능할 수 있도록 하는 중요한 기반이 됩니다.

#### 하이퍼파라미터

**모델 하이퍼파라미터**

DeepSeek-V2의 모델 아키텍처는 정교하게 설계된 하이퍼파라미터를 통해 구현됩니다. 트랜스포머 레이어 수는 60개로 설정되었으며, 숨겨진 차원은 5120으로 구성되었습니다. 모든 학습 가능한 파라미터는 표준편차 0.006으로 무작위 초기화되었습니다.

MLA(Multi-head Latent Attention)에서는 어텐션 헤드 수 $n_h$를 128로, 헤드당 차원 $d_h$를 128로 설정했습니다. 이는 총 $n_h \times d_h = 128 \times 128 = 16,384$차원의 어텐션 공간을 만들어냅니다. KV 압축 차원 $d_c$는 512로 설정되었고, 쿼리 압축 차원 $d_c'$는 1536으로 설정되었습니다. 분리된 쿼리와 키의 경우, 헤드당 차원 $d_h^R$을 64로 설정했습니다.

이러한 압축 차원들의 선택은 메모리 효율성과 성능 간의 균형을 맞추기 위한 것입니다. KV 압축 차원 $d_c = 512$는 원래 차원 $n_h \times d_h = 16,384$보다 훨씬 작아서 약 32배의 압축률을 달성합니다. 이는 마치 고해상도 이미지를 효율적으로 압축하면서도 중요한 정보는 보존하는 것과 같은 원리입니다.

Dai et al.(2024)의 연구를 따라 첫 번째 레이어를 제외한 모든 FFN을 MoE 레이어로 대체했습니다. 각 MoE 레이어는 2개의 공유 전문가와 160개의 라우팅된 전문가로 구성되며, 각 전문가의 중간 숨겨진 차원은 1536입니다. 라우팅된 전문가 중에서는 각 토큰당 6개의 전문가가 활성화됩니다.

저랭크 압축과 세밀한 전문가 분할이 레이어의 출력 스케일에 영향을 미치기 때문에, 실제로는 압축된 잠재 벡터 이후에 추가적인 RMS Norm 레이어를 사용하고, 폭 병목 지점(즉, 압축된 잠재 벡터와 라우팅된 전문가의 중간 숨겨진 상태)에서 추가적인 스케일링 인수를 곱하여 안정적인 훈련을 보장합니다.

이러한 구성 하에서 DeepSeek-V2는 총 236B개의 파라미터를 포함하며, 이 중 각 토큰당 21B개가 활성화됩니다. 이는 전체 모델의 약 8.9%만이 각 토큰 처리에 사용된다는 의미로, 매우 효율적인 희소 아키텍처를 구현했음을 보여줍니다.

**훈련 하이퍼파라미터**

훈련 과정에서는 AdamW 옵티마이저를 사용했으며, 이는 Loshchilov and Hutter(2017)에서 제안된 방법입니다. AdamW는 기존 Adam 옵티마이저의 개선된 버전으로, 가중치 감쇠(weight decay)를 그래디언트 기반 업데이트와 분리하여 더 나은 일반화 성능을 달성합니다. 하이퍼파라미터는 $\beta_1 = 0.9$, $\beta_2 = 0.95$, $\text{weight\_decay} = 0.1$로 설정되었습니다.

학습률은 warmup-and-step-decay 전략을 사용하여 스케줄링되었습니다. 이는 DeepSeek-AI(2024)에서 사용된 방법과 동일합니다. 초기에는 학습률이 첫 2K 스텝 동안 0에서 최대값까지 선형적으로 증가합니다. 이후 약 60%의 토큰을 훈련한 후 학습률에 0.316을 곱하고, 약 90%의 토큰을 훈련한 후 다시 0.316을 곱합니다. 최대 학습률은 $2.4 \times 10^{-4}$로 설정되었으며, 그래디언트 클리핑 노름은 1.0으로 설정되었습니다.

배치 크기 스케줄링 전략도 사용했는데, 첫 225B 토큰 훈련에서 배치 크기를 2304에서 9216으로 점진적으로 증가시킨 후, 나머지 훈련에서는 9216을 유지했습니다. 이러한 점진적 배치 크기 증가는 훈련 초기의 불안정성을 줄이면서도 후반부에서는 더 효율적인 훈련을 가능하게 합니다.

최대 시퀀스 길이는 4K로 설정되었으며, DeepSeek-V2는 총 8.1T 토큰에서 훈련되었습니다. 파이프라인 병렬성을 활용하여 모델의 서로 다른 레이어를 서로 다른 장치에 배포했으며, 각 레이어에 대해 라우팅된 전문가들은 8개 장치에 균등하게 배포되었습니다($D = 8$). 장치 제한 라우팅의 경우, 각 토큰은 최대 3개 장치로 전송됩니다($M = 3$).

밸런스 손실의 경우, $\alpha_1$을 0.003, $\alpha_2$를 0.05, $\alpha_3$을 0.02로 설정했습니다. 이러한 값들은 전문가 수준, 장치 수준, 통신 밸런스 간의 적절한 균형을 맞추기 위해 실험적으로 결정되었습니다. 훈련 중에는 가속화를 위해 토큰 드롭핑 전략을 사용했지만, 평가 시에는 어떤 토큰도 드롭하지 않았습니다.

#### 인프라

DeepSeek-V2는 내부 엔지니어들이 개발한 효율적이고 경량화된 훈련 프레임워크인 HAI-LLM 프레임워크를 기반으로 훈련되었습니다. 이 프레임워크는 16-way zero-bubble 파이프라인 병렬성, 8-way 전문가 병렬성, 그리고 ZeRO-1 데이터 병렬성을 사용합니다.

Zero-bubble 파이프라인 병렬성은 Qi et al.(2023)에서 제안된 혁신적인 기술로, 기존 파이프라인 병렬성에서 발생하는 버블(idle time)을 제거하여 GPU 활용률을 크게 향상시킵니다. 이는 마치 공장의 생산 라인에서 유휴 시간을 최소화하여 전체 처리량을 극대화하는 것과 같은 원리입니다.

전문가 병렬성은 Lepikhin et al.(2021)에서 소개된 방법으로, MoE 모델의 서로 다른 전문가들을 여러 장치에 분산시켜 병렬 처리를 가능하게 합니다. ZeRO-1 데이터 병렬성은 Rajbhandari et al.(2020)에서 제안된 메모리 최적화 기술로, 옵티마이저 상태를 여러 장치에 분할하여 메모리 사용량을 줄입니다.

DeepSeek-V2는 상대적으로 적은 수의 활성화된 파라미터를 가지고 있고, 활성화 메모리를 절약하기 위해 연산자의 일부가 재계산되기 때문에, 텐서 병렬성 없이도 훈련이 가능하여 통신 오버헤드를 줄일 수 있습니다. 이는 MoE 아키텍처의 희소성이 가져다주는 중요한 이점 중 하나입니다.

훈련 효율성을 더욱 향상시키기 위해 공유 전문가의 계산을 전문가 병렬 all-to-all 통신과 겹치도록 했습니다. 또한 통신, 라우팅 알고리즘, 그리고 서로 다른 전문가 간의 융합된 선형 계산을 위한 더 빠른 CUDA 커널을 맞춤 제작했습니다. MLA 역시 FlashAttention-2의 개선된 버전을 기반으로 최적화되었습니다.

모든 실험은 NVIDIA H800 GPU가 장착된 클러스터에서 수행되었습니다. H800 클러스터의 각 노드는 NVLink와 NVSwitch를 사용하여 노드 내에서 연결된 8개의 GPU를 포함합니다. 노드 간에는 InfiniBand 인터커넥트를 활용하여 통신을 촉진합니다. 이러한 고성능 인프라는 대규모 모델 훈련에 필수적인 높은 대역폭과 낮은 지연시간을 제공합니다.

#### 긴 컨텍스트 확장

DeepSeek-V2의 초기 사전 훈련 후, YaRN(Peng et al., 2023)을 사용하여 기본 컨텍스트 윈도우 길이를 4K에서 128K로 확장했습니다. YaRN은 RoPE(Rotary Position Embedding)를 사용하는 트랜스포머 기반 언어 모델의 컨텍스트 윈도우를 효율적으로 확장하는 혁신적인 방법입니다.

YaRN은 RoPE를 담당하는 분리된 공유 키 $\mathbf{k}_t^R$에 특별히 적용되었습니다. YaRN의 핵심 아이디어는 "NTK-by-parts" 보간과 어텐션 스케일링 기법을 결합하는 것입니다. 이 방법은 저주파 차원은 선형적으로 보간하고 고주파 차원은 변경하지 않는 방식으로 작동합니다.

YaRN 설정에서는 스케일 $s$를 40, $\alpha$를 1, $\beta$를 32로 설정했으며, 목표 최대 컨텍스트 길이를 160K로 설정했습니다. 이러한 설정 하에서 모델이 128K의 컨텍스트 길이에서 잘 응답할 것으로 예상할 수 있습니다.

원래 YaRN과 약간 다르게, 독특한 어텐션 메커니즘으로 인해 어텐션 엔트로피를 조절하기 위해 길이 스케일링 인수를 조정했습니다. 인수 $\sqrt{t}$는 $\sqrt{t} = 0.0707 \ln s + 1$로 계산되며, 이는 퍼플렉시티를 최소화하는 것을 목표로 합니다.

추가로 시퀀스 길이 32K, 배치 크기 576 시퀀스로 1000 스텝 동안 모델을 훈련했습니다. 훈련이 32K의 시퀀스 길이에서만 수행되었음에도 불구하고, 모델은 128K의 컨텍스트 길이에서 평가될 때도 강건한 성능을 보여줍니다.

![Needle In A Haystack 테스트 결과](https://arxiv.org/html/2405.04434/x5.png)

위 그림은 "Needle In A Haystack"(NIAH) 테스트에서 DeepSeek-V2 모델의 성능을 보여주는 선 그래프입니다. 이 그래프는 1K에서 128K 토큰까지의 다양한 컨텍스트 윈도우 길이에 대해 DeepSeek-V2 모델이 달성한 문서 깊이 백분율을 나타냅니다. 이 그림의 연구적 의의는 DeepSeek-V2 모델이 128K 토큰까지의 큰 컨텍스트 윈도우 크기에서도 높은 정확도를 유지한다는 것을 보여주어, "Needle In A Haystack" 작업에서 장거리 의존성을 처리하는 효과를 입증한다는 것입니다.

NIAH 테스트 결과는 DeepSeek-V2가 128K까지의 모든 컨텍스트 윈도우 길이에서 우수한 성능을 보인다는 것을 나타냅니다. 이는 긴 컨텍스트 확장이 성공적으로 이루어졌음을 보여주는 중요한 증거입니다.
### 평가

#### 평가 벤치마크

DeepSeek-V2는 이중 언어 코퍼스에서 사전 훈련되었기 때문에 영어와 중국어의 다양한 벤치마크에서 평가되었습니다. 평가는 HAI-LLM 프레임워크에 통합된 내부 평가 프레임워크를 기반으로 수행되었습니다.

포함된 벤치마크들은 다음과 같이 분류되며, 밑줄 친 벤치마크는 중국어입니다. 다중 주제 객관식 데이터셋에는 MMLU(Hendrycks et al., 2020), C-Eval(Huang et al., 2023), CMMLU(Li et al., 2023)가 포함됩니다. 언어 이해 및 추론 데이터셋에는 HellaSwag(Zellers et al., 2019), PIQA(Bisk et al., 2020), ARC(Clark et al., 2018), BigBench Hard(BBH)(Suzgun et al., 2022)가 포함됩니다.

폐쇄형 질문 답변 데이터셋에는 TriviaQA(Joshi et al., 2017)와 NaturalQuestions(Kwiatkowski et al., 2019)가 포함됩니다. 독해 데이터셋에는 RACE(Lai et al., 2017), DROP(Dua et al., 2019), C3(Sun et al., 2019), CMRC(Cui et al., 2019)가 포함됩니다. 참조 중의성 해소 데이터셋에는 WinoGrande(Sakaguchi et al., 2019)와 CLUEWSC(Xu et al., 2020)가 포함됩니다.

언어 모델링 데이터셋에는 Pile(Gao et al., 2020)이 포함됩니다. 중국어 이해 및 문화 데이터셋에는 CHID(Zheng et al., 2019)와 CCPM(Li et al., 2021)이 포함됩니다. 수학 데이터셋에는 GSM8K(Cobbe et al., 2021), MATH(Hendrycks et al., 2021), CMath(Wei et al., 2023)가 포함됩니다. 코드 데이터셋에는 HumanEval(Chen et al., 2021), MBPP(Austin et al., 2021), CRUXEval(Gu et al., 2024)이 포함됩니다. 표준화된 시험에는 AGIEval(Zhong et al., 2023)이 포함되며, 이는 영어와 중국어 하위 집합을 모두 포함합니다.

이전 연구(DeepSeek-AI, 2024)를 따라 HellaSwag, PIQA, WinoGrande, RACE-Middle, RACE-High, MMLU, ARC-Easy, ARC-Challenge, CHID, C-Eval, CMMLU, C3, CCPM을 포함한 데이터셋에 대해서는 퍼플렉시티 기반 평가를 채택했고, TriviaQA, NaturalQuestions, DROP, MATH, GSM8K, HumanEval, MBPP, CRUXEval, BBH, AGIEval, CLUEWSC, CMRC, CMath에 대해서는 생성 기반 평가를 채택했습니다.

또한 Pile-test에 대해서는 언어 모델링 기반 평가를 수행하고 서로 다른 토크나이저를 가진 모델들 간의 공정한 비교를 보장하기 위해 Bits-Per-Byte(BPB)를 메트릭으로 사용했습니다. 이러한 벤치마크들에 대한 직관적인 개요를 위해 각 벤치마크에 대한 평가 형식을 부록에 추가로 제공했습니다.

#### 평가 결과

| 벤치마크 (메트릭)     | # Shots | DeepSeek 67B | Qwen1.5 72B | Mixtral 8x22B | LLaMA 3 70B | DeepSeek-V2 |
| --------------------- | ------- | ------------ | ----------- | ------------- | ----------- | ----------- |
| 아키텍처              | -       | Dense        | Dense       | MoE           | Dense       | MoE         |
| # 활성화된 파라미터   | -       | 67B          | 72B         | 39B           | 70B         | 21B         |
| # 총 파라미터         | -       | 67B          | 72B         | 141B          | 70B         | 236B        |
| **영어**              |         |              |             |               |             |             |
| Pile-test (BPB)       | -       | 0.642        | 0.637       | 0.623         | 0.602       | 0.606       |
| BBH (EM)              | 3-shot  | 68.7         | 59.9        | 78.9          | 81.0        | 78.9        |
| MMLU (Acc.)           | 5-shot  | 71.3         | 77.2        | 77.6          | 78.9        | 78.5        |
| DROP (F1)             | 3-shot  | 69.7         | 71.5        | 80.4          | 82.5        | 80.1        |
| ARC-Easy (Acc.)       | 25-shot | 95.3         | 97.1        | 97.3          | 97.9        | 97.6        |
| ARC-Challenge (Acc.)  | 25-shot | 86.4         | 92.8        | 91.2          | 93.3        | 92.4        |
| HellaSwag (Acc.)      | 10-shot | 86.3         | 85.8        | 86.6          | 87.9        | 84.2        |
| PIQA (Acc.)           | 0-shot  | 83.6         | 83.3        | 83.6          | 85.0        | 83.7        |
| WinoGrande (Acc.)     | 5-shot  | 84.9         | 82.4        | 83.7          | 85.7        | 84.9        |
| RACE-Middle (Acc.)    | 5-shot  | 69.9         | 63.4        | 73.3          | 73.3        | 73.1        |
| RACE-High (Acc.)      | 5-shot  | 50.7         | 47.0        | 56.7          | 57.9        | 52.7        |
| TriviaQA (EM)         | 5-shot  | 78.9         | 73.1        | 82.1          | 81.6        | 79.9        |
| NaturalQuestions (EM) | 5-shot  | 36.6         | 35.6        | 39.6          | 40.2        | 38.7        |
| AGIEval (Acc.)        | 0-shot  | 41.3         | 64.4        | 43.4          | 49.8        | 51.2        |
| **코드**              |         |              |             |               |             |             |
| HumanEval (Pass@1)    | 0-shot  | 45.1         | 43.9        | 53.1          | 48.2        | 48.8        |
| MBPP (Pass@1)         | 3-shot  | 57.4         | 53.6        | 64.2          | 68.6        | 66.6        |
| CRUXEval-I (Acc.)     | 2-shot  | 42.5         | 44.3        | 52.4          | 49.4        | 52.8        |
| CRUXEval-O (Acc.)     | 2-shot  | 41.0         | 42.3        | 52.8          | 54.3        | 49.8        |
| **수학**              |         |              |             |               |             |             |
| GSM8K (EM)            | 8-shot  | 63.4         | 77.9        | 80.3          | 83.0        | 79.2        |
| MATH (EM)             | 4-shot  | 18.7         | 41.4        | 42.5          | 42.2        | 43.6        |
| CMath (EM)            | 3-shot  | 63.0         | 77.8        | 72.3          | 73.9        | 78.7        |
| **중국어**            |         |              |             |               |             |             |
| CLUEWSC (EM)          | 5-shot  | 81.0         | 80.5        | 77.5          | 78.3        | 82.2        |
| C-Eval (Acc.)         | 5-shot  | 66.1         | 83.7        | 59.6          | 67.5        | 81.7        |
| CMMLU (Acc.)          | 5-shot  | 70.8         | 84.3        | 60.0          | 69.3        | 84.0        |
| CMRC (EM)             | 1-shot  | 73.4         | 66.6        | 73.1          | 73.3        | 77.5        |
| C3 (Acc.)             | 0-shot  | 75.3         | 78.2        | 71.4          | 74.0        | 77.4        |
| CHID (Acc.)           | 0-shot  | 92.1         | -           | 57.0          | 83.2        | 92.7        |
| CCPM (Acc.)           | 0-shot  | 88.5         | 88.1        | 61.0          | 68.1        | 93.1        |

위 표에서 DeepSeek-V2와 다른 대표적인 오픈소스 모델들을 비교했습니다. 모든 모델은 내부 평가 프레임워크에서 평가되었으며 동일한 평가 설정을 공유합니다. 굵은 글씨는 최고 성능을, 밑줄은 두 번째 성능을 나타냅니다. 0.3 미만의 차이를 가진 점수는 동일한 수준으로 간주됩니다. 단 21B개의 활성화된 파라미터로 DeepSeek-V2는 오픈소스 모델 중 최고 수준의 성능을 달성했습니다.

DeepSeek-V2를 이전 릴리스인 DeepSeek 67B, Qwen1.5 72B, LLaMA3 70B, Mixtral 8x22B를 포함한 여러 대표적인 오픈소스 모델과 비교했습니다. 모든 모델을 내부 평가 프레임워크로 평가하여 동일한 평가 설정을 공유하도록 보장했습니다. 전반적으로 단 21B개의 활성화된 파라미터로 DeepSeek-V2는 거의 모든 벤치마크에서 DeepSeek 67B를 크게 능가하며, 오픈소스 모델 중 최고 수준의 성능을 달성했습니다.

DeepSeek-V2를 오픈소스 대응 모델들과 하나씩 정교하게 비교해보겠습니다. 첫째, 중국어와 영어를 모두 지원하는 또 다른 모델인 Qwen1.5 72B와 비교하면, DeepSeek-V2는 대부분의 영어, 코드, 수학 벤치마크에서 압도적인 우위를 보여줍니다. 중국어 벤치마크의 경우, Qwen1.5 72B는 다중 주제 객관식 작업에서 더 나은 성능을 보이는 반면 DeepSeek-V2는 다른 작업에서 비슷하거나 더 나은 성능을 보입니다. CHID 벤치마크의 경우, Qwen1.5 72B의 토크나이저가 평가 프레임워크에서 오류를 발생시켜 CHID 점수를 공백으로 남겨두었습니다.

둘째, Mixtral 8x22B와 비교하면, DeepSeek-V2는 영어 상식 지식과 밀접한 관련이 있는 TriviaQA, NaturalQuestions, HellaSwag를 제외하고는 비슷하거나 더 나은 영어 성능을 달성합니다. 특히 DeepSeek-V2는 MMLU에서 Mixtral 8x22B를 능가합니다. 코드와 수학 벤치마크에서 DeepSeek-V2는 Mixtral 8x22B와 비슷한 성능을 보여줍니다. Mixtral 8x22B는 중국어 데이터에 특별히 훈련되지 않았기 때문에 중국어 능력이 DeepSeek-V2에 크게 뒤처집니다.

셋째, LLaMA3 70B와 비교하면, DeepSeek-V2는 영어 토큰의 4분의 1도 안 되는 양으로 훈련되었습니다. 따라서 DeepSeek-V2가 기본적인 영어 능력에서 LLaMA3 70B와 약간의 격차가 있음을 인정합니다. 그러나 훨씬 적은 훈련 토큰과 활성화된 파라미터에도 불구하고 DeepSeek-V2는 여전히 LLaMA3 70B와 비슷한 코드 및 수학 능력을 보여줍니다. 또한 이중 언어 모델로서 DeepSeek-V2는 중국어 벤치마크에서 LLaMA3 70B를 압도적으로 능가합니다.

마지막으로, 특정 이전 연구들(Hu et al., 2024)이 사전 훈련 단계에서 SFT 데이터를 포함하는 반면, DeepSeek-V2는 사전 훈련 중에 SFT 데이터에 노출된 적이 없다는 점을 언급할 가치가 있습니다.

#### 훈련 및 추론 효율성

**훈련 비용**

DeepSeek-V2는 각 토큰에 대해 더 적은 파라미터를 활성화하고 DeepSeek 67B보다 더 적은 FLOP을 필요로 하기 때문에, 이론적으로 DeepSeek-V2를 훈련하는 것이 DeepSeek 67B를 훈련하는 것보다 더 경제적입니다. MoE 모델을 훈련하면 추가적인 통신 오버헤드가 발생하지만, 연산자 및 통신 최적화를 통해 DeepSeek-V2의 훈련은 상대적으로 높은 Model FLOPs Utilization(MFU)을 달성할 수 있습니다.

H800 클러스터에서의 실제 훈련에서, 각 1조 토큰 훈련에 대해 DeepSeek 67B는 300.6K GPU 시간이 필요한 반면, DeepSeek-V2는 단 172.8K GPU 시간만 필요합니다. 즉, 희소한 DeepSeek-V2는 밀집된 DeepSeek 67B와 비교하여 42.5%의 훈련 비용을 절약할 수 있습니다.

**추론 효율성**

DeepSeek-V2를 서비스에 효율적으로 배포하기 위해 먼저 파라미터를 FP8 정밀도로 변환했습니다. 또한 DeepSeek-V2에 대해 KV 캐시 양자화(Hooper et al., 2024; Zhao et al., 2023)를 수행하여 KV 캐시의 각 요소를 평균 6비트로 추가 압축했습니다.

MLA와 이러한 최적화의 혜택으로, 실제 배포된 DeepSeek-V2는 DeepSeek 67B보다 훨씬 적은 KV 캐시를 필요로 하므로 훨씬 더 큰 배치 크기를 서비스할 수 있습니다. 실제 배포된 DeepSeek 67B 서비스의 프롬프트 및 생성 길이 분포를 기반으로 DeepSeek-V2의 생성 처리량을 평가했습니다. 8개의 H800 GPU가 있는 단일 노드에서 DeepSeek-V2는 초당 50K 토큰을 초과하는 생성 처리량을 달성하며, 이는 DeepSeek 67B의 최대 생성 처리량의 5.76배입니다. 또한 DeepSeek-V2의 프롬프트 입력 처리량은 초당 100K 토큰을 초과합니다.

이러한 결과들은 DeepSeek-V2가 단순히 성능 면에서만 우수한 것이 아니라, 실제 배포 환경에서도 매우 효율적이고 경제적임을 보여줍니다. 특히 MLA 아키텍처의 혁신적인 KV 캐시 압축과 MoE의 희소 활성화가 결합되어 이전 모델 대비 획기적인 효율성 개선을 달성했습니다.
## 정렬

DeepSeek-V2의 정렬 과정은 사전 훈련된 기본 모델을 인간의 선호도와 일치시키기 위한 체계적인 접근법을 제시합니다. 이 과정은 지도 학습 기반 미세 조정(Supervised Fine-Tuning, SFT)과 강화 학습(Reinforcement Learning, RL)의 두 단계로 구성되어 있으며, 각 단계는 모델의 서로 다른 측면을 개선하는 데 중점을 둡니다.

### 지도 학습 기반 미세 조정

DeepSeek-V2의 지도 학습 기반 미세 조정은 이전 연구를 바탕으로 하여 총 150만 개의 인스턴스로 구성된 명령어 튜닝 데이터셋을 구축했습니다. 이 데이터셋은 유용성을 위한 120만 개의 인스턴스와 안전성을 위한 30만 개의 인스턴스로 구성되어 있습니다. 초기 버전과 비교하여 환각 응답을 완화하고 작문 능력을 향상시키기 위해 데이터 품질을 개선했습니다.

미세 조정 과정에서는 DeepSeek-V2를 2 에포크 동안 훈련했으며, 학습률은 $5 \times 10^{-6}$으로 설정했습니다. 이러한 하이퍼파라미터 설정은 모델이 기존 지식을 유지하면서도 새로운 명령어 수행 능력을 효과적으로 학습할 수 있도록 균형을 맞춘 것입니다.

DeepSeek-V2 Chat(SFT)의 평가를 위해서는 주로 생성 기반 벤치마크를 포함했으며, 몇 가지 대표적인 객관식 작업(MMLU 및 ARC)도 예외적으로 포함했습니다. 또한 명령어 수행 평가(IFEval)를 수행하여 프롬프트 수준의 느슨한 정확도를 메트릭으로 사용했습니다. 이는 모델이 주어진 명령어를 얼마나 정확하게 따르는지를 객관적으로 측정하는 중요한 지표입니다.

코드 생성 능력 평가를 위해서는 2023년 9월 1일부터 2024년 4월 1일까지의 LiveCodeBench 문제를 사용했습니다. LiveCodeBench는 데이터 오염 문제를 방지하기 위해 지속적으로 새로운 문제를 수집하는 혁신적인 벤치마크로, 모델의 실제 코드 생성 능력을 더욱 정확하게 평가할 수 있게 합니다.

표준 벤치마크 외에도 MT-Bench, AlpacaEval 2.0, AlignBench를 포함한 개방형 대화 벤치마크에서 모델을 추가로 평가했습니다. 이러한 벤치마크들은 모델의 실제 대화 능력과 인간과의 상호작용 품질을 측정하는 데 중요한 역할을 합니다. 비교를 위해 Qwen1.5 72B Chat, LLaMA-3-70B Instruct, Mistral-8x22B Instruct도 동일한 평가 프레임워크와 설정에서 평가했습니다.

### 강화 학습

DeepSeek-V2의 잠재력을 더욱 발휘하고 인간 선호도와 정렬하기 위해 강화 학습을 수행하여 모델의 선호도를 조정했습니다. 이 과정은 모델이 단순히 정확한 답변을 생성하는 것을 넘어서 인간이 선호하는 방식으로 응답하도록 학습시키는 중요한 단계입니다.

#### 강화 학습 알고리즘

RL 훈련 비용을 절약하기 위해 Group Relative Policy Optimization(GRPO)을 채택했습니다. GRPO는 일반적으로 정책 모델과 동일한 크기를 가지는 비평 모델을 사용하지 않고, 대신 그룹 점수에서 기준선을 추정하는 혁신적인 접근법입니다.

구체적으로, 각 질문 $q$에 대해 GRPO는 이전 정책 $\pi_{\theta_{old}}$에서 출력 그룹 $\{o_1, o_2, \cdots, o_G\}$를 샘플링한 다음, 다음 목적 함수를 최대화하여 정책 모델 $\pi_\theta$를 최적화합니다.

$$\mathcal{J}_{GRPO}(\theta) = \mathbb{E}[q \sim P(Q), \{o_i\}_{i=1}^G \sim \pi_{\theta_{old}}(O|q)] \frac{1}{G}\sum_{i=1}^G\left(\min\left(\frac{\pi_\theta(o_i|q)}{\pi_{\theta_{old}}(o_i|q)}A_i, \text{clip}\left(\frac{\pi_\theta(o_i|q)}{\pi_{\theta_{old}}(o_i|q)}, 1-\varepsilon, 1+\varepsilon\right)A_i\right) - \beta \mathbb{D}_{KL}(\pi_\theta || \pi_{ref})\right)$$

이 목적 함수에서 KL 발산은 다음과 같이 계산됩니다.

$$\mathbb{D}_{KL}(\pi_\theta || \pi_{ref}) = \frac{\pi_{ref}(o_i|q)}{\pi_\theta(o_i|q)} - \log\frac{\pi_{ref}(o_i|q)}{\pi_\theta(o_i|q)} - 1$$

여기서 $\varepsilon$과 $\beta$는 하이퍼파라미터이며, $A_i$는 각 그룹 내 출력에 해당하는 보상 그룹 $\{r_1, r_2, \ldots, r_G\}$를 사용하여 계산되는 이점(advantage)입니다.

$$A_i = \frac{r_i - \text{mean}(\{r_1, r_2, \cdots, r_G\})}{\text{std}(\{r_1, r_2, \cdots, r_G\})}$$

이 이점 계산 방식은 각 출력의 상대적 품질을 그룹 내에서 정규화하여 평가하는 것으로, 절대적인 보상 값보다는 상대적인 우수성에 기반하여 학습이 이루어지도록 합니다. 이는 보상 모델의 스케일 변화에 더욱 강건한 학습을 가능하게 합니다.

#### 훈련 전략

예비 실험에서 코드 및 수학 프롬프트와 같은 추론 데이터에 대한 RL 훈련이 일반 데이터 훈련과는 구별되는 독특한 특성을 보인다는 것을 발견했습니다. 예를 들어, 모델의 수학 및 코딩 능력은 더 긴 훈련 단계에 걸쳐 지속적으로 향상될 수 있었습니다. 따라서 먼저 추론 정렬을 수행한 다음 인간 선호도 정렬을 수행하는 2단계 RL 훈련 전략을 채택했습니다.

첫 번째 추론 정렬 단계에서는 코드 및 수학 추론 작업을 위한 보상 모델 $RM_{reasoning}$을 훈련하고, $RM_{reasoning}$의 피드백으로 정책 모델을 최적화합니다.

$$r_i = RM_{reasoning}(o_i)$$

이 단계에서는 모델이 논리적 추론과 문제 해결 능력을 집중적으로 개발하도록 합니다. 추론 능력은 다른 능력들의 기반이 되므로, 이를 먼저 강화하는 것이 전체적인 성능 향상에 효과적입니다.

두 번째 인간 선호도 정렬 단계에서는 다중 보상 프레임워크를 채택하여 유용한 보상 모델 $RM_{helpful}$, 안전 보상 모델 $RM_{safety}$, 규칙 기반 보상 모델 $RM_{rule}$에서 보상을 획득합니다. 응답 $o_i$의 최종 보상은 다음과 같이 계산됩니다.

$$r_i = c_1 \cdot RM_{helpful}(o_i) + c_2 \cdot RM_{safety}(o_i) + c_3 \cdot RM_{rule}(o_i)$$

여기서 $c_1$, $c_2$, $c_3$는 각각의 계수입니다. 이러한 다중 보상 접근법은 모델이 단순히 유용한 답변을 생성하는 것뿐만 아니라 안전성과 규칙 준수도 동시에 고려하도록 합니다.

신뢰할 수 있는 보상 모델을 얻기 위해 선호도 데이터를 신중하게 수집하고, 품질 필터링과 비율 조정을 세심하게 수행했습니다. 컴파일러 피드백을 기반으로 코드 선호도 데이터를 얻었고, 정답 레이블을 기반으로 수학 선호도 데이터를 얻었습니다. 보상 모델 훈련을 위해서는 DeepSeek-V2 Chat(SFT)로 보상 모델을 초기화하고 점별 또는 쌍별 손실로 훈련했습니다.

실험에서 RL 훈련이 모델의 잠재력을 완전히 활용하고 활성화하여 가능한 응답 중에서 정확하고 만족스러운 답변을 선택할 수 있게 한다는 것을 관찰했습니다. 이는 모델이 단순히 하나의 답변을 생성하는 것이 아니라, 여러 가능한 답변 중에서 가장 적절한 것을 선택하는 능력을 개발했음을 의미합니다.

#### 훈련 효율성을 위한 최적화

극도로 큰 모델에서 RL 훈련을 수행하는 것은 훈련 프레임워크에 높은 요구사항을 제시합니다. GPU 메모리와 RAM 압력을 관리하면서 동시에 빠른 훈련 속도를 유지하기 위해서는 신중한 엔지니어링 최적화가 필요합니다.

이러한 목표를 위해 다음과 같은 엔지니어링 최적화를 구현했습니다. 첫째, 더 높은 GPU 활용률을 달성하기 위해 훈련과 추론에 각각 다른 병렬 전략을 채택하는 하이브리드 엔진을 제안했습니다. 둘째, 추론 속도를 가속화하기 위해 큰 배치 크기를 가진 vLLM을 추론 백엔드로 활용했습니다. 셋째, 훈련 속도와 메모리 소비 간의 거의 최적의 균형을 달성하는 모델을 CPU로 오프로딩하고 GPU로 다시 로딩하는 스케줄링 전략을 신중하게 설계했습니다.

이러한 최적화들은 대규모 모델의 RL 훈련을 실용적으로 가능하게 만드는 중요한 기술적 기여입니다. 특히 메모리 관리와 계산 효율성의 균형을 맞추는 것은 실제 배포 환경에서 매우 중요한 고려사항입니다.

### 평가 결과

#### 표준 벤치마크에서의 평가

먼저 표준 벤치마크에서 DeepSeek-V2 Chat(SFT)와 DeepSeek-V2 Chat(RL)을 평가했습니다. 주목할 만한 점은 DeepSeek-V2 Chat(SFT)가 기본 버전과 비교하여 GSM8K, MATH, HumanEval 평가에서 상당한 개선을 보여준다는 것입니다. 이러한 진전은 상당한 양의 수학 및 코드 관련 콘텐츠를 포함하는 SFT 데이터의 포함에 기인할 수 있습니다. 또한 DeepSeek-V2 Chat(RL)은 수학 및 코드 벤치마크에서 성능을 더욱 향상시켰습니다.

| 벤치마크            | # Shots | DeepSeek 67B Chat | Qwen1.5 72B Chat | LLaMA3 70B Inst. | Mixtral 8x22B Inst. | DeepSeek-V2 Chat (SFT) | DeepSeek-V2 Chat (RL) |
| ------------------- | ------- | ----------------- | ---------------- | ---------------- | ------------------- | ---------------------- | --------------------- |
| 컨텍스트 길이       | -       | 4K                | 32K              | 8K               | 64K                 | 128K                   | 128K                  |
| 아키텍처            | -       | Dense             | Dense            | Dense            | MoE                 | MoE                    | MoE                   |
| # 활성화된 파라미터 | -       | 67B               | 72B              | 70B              | 39B                 | 21B                    | 21B                   |
| # 총 파라미터       | -       | 67B               | 72B              | 70B              | 141B                | 236B                   | 236B                  |
| **영어**            |         |                   |                  |                  |                     |                        |                       |
| TriviaQA            | 5-shot  | 81.5              | 79.6             | 69.1             | 80.0                | 85.4                   | 86.7                  |
| NaturalQuestions    | 5-shot  | 47.0              | 46.9             | 44.6             | 54.9                | 51.9                   | 53.4                  |
| MMLU                | 5-shot  | 71.1              | 76.2             | 80.3             | 77.8                | 78.4                   | 77.8                  |
| ARC-Easy            | 25-shot | 96.6              | 96.8             | 96.9             | 97.1                | 97.6                   | 98.1                  |
| ARC-Challenge       | 25-shot | 88.9              | 91.7             | 92.6             | 90.0                | 92.5                   | 92.3                  |
| BBH                 | 3-shot  | 71.7              | 65.9             | 80.1             | 78.4                | 81.3                   | 79.7                  |
| AGIEval             | 0-shot  | 46.4              | 62.8             | 56.6             | 41.4                | 63.2                   | 61.4                  |
| IFEval              | 0-shot  | 55.5              | 57.3             | 79.7             | 72.1                | 64.1                   | 63.8                  |
| **코드**            |         |                   |                  |                  |                     |                        |                       |
| HumanEval           | 0-shot  | 73.8              | 68.9             | 76.2             | 75.0                | 76.8                   | 81.1                  |
| MBPP                | 3-shot  | 61.4              | 52.2             | 69.8             | 64.4                | 70.4                   | 72.0                  |
| CRUXEval-I-COT      | 2-shot  | 49.1              | 51.4             | 61.1             | 59.4                | 59.5                   | 61.5                  |
| CRUXEval-O-COT      | 2-shot  | 50.9              | 56.5             | 63.6             | 63.6                | 60.7                   | 63.0                  |
| LiveCodeBench       | 0-shot  | 18.3              | 18.8             | 30.5             | 25.0                | 28.7                   | 32.5                  |
| **수학**            |         |                   |                  |                  |                     |                        |                       |
| GSM8K               | 8-shot  | 84.1              | 81.9             | 93.2             | 87.9                | 90.8                   | 92.2                  |
| MATH                | 4-shot  | 32.6              | 40.6             | 48.5             | 49.8                | 52.7                   | 53.9                  |
| CMath               | 0-shot  | 80.3              | 82.8             | 79.2             | 75.1                | 82.0                   | 81.9                  |
| **중국어**          |         |                   |                  |                  |                     |                        |                       |
| CLUEWSC             | 5-shot  | 78.5              | 90.1             | 85.4             | 75.8                | 88.6                   | 89.9                  |
| C-Eval              | 5-shot  | 65.2              | 82.2             | 67.9             | 60.0                | 80.9                   | 78.0                  |
| CMMLU               | 5-shot  | 67.8              | 82.9             | 70.7             | 61.0                | 82.4                   | 81.6                  |

다른 모델들과의 비교에서, 먼저 DeepSeek-V2 Chat(SFT)를 Qwen1.5 72B Chat과 비교하면, DeepSeek-V2 Chat(SFT)가 거의 모든 영어, 수학, 코드 벤치마크에서 Qwen1.5 72B Chat을 능가한다는 것을 발견했습니다. 중국어 벤치마크에서는 DeepSeek-V2 Chat(SFT)가 다중 주제 객관식 작업에서 Qwen1.5 72B Chat보다 약간 낮은 점수를 보여주며, 이는 기본 버전에서 관찰된 성능과 일치합니다.

최첨단 오픈소스 MoE 모델인 Mixtral 8x22B Instruct와 비교할 때, DeepSeek-V2 Chat(SFT)는 NaturalQuestions와 IFEval을 제외한 대부분의 벤치마크에서 더 나은 성능을 보입니다. 또한 최첨단 오픈소스 모델인 LLaMA3 70B Chat과 비교하면, DeepSeek-V2 Chat(SFT)는 코드 및 수학 관련 벤치마크에서 유사한 성능을 보입니다. LLaMA3 70B Chat은 MMLU와 IFEval에서 더 나은 성능을 보이는 반면, DeepSeek-V2 Chat(SFT)는 중국어 작업에서 더 강한 성능을 보여줍니다.

궁극적으로 DeepSeek-V2 Chat(RL)은 DeepSeek-V2 Chat(SFT)와 비교하여 수학 및 코딩 작업 모두에서 더욱 향상된 성능을 보여줍니다. 이러한 비교는 다양한 도메인과 언어에서 다른 언어 모델들과 관련하여 DeepSeek-V2 Chat의 강점을 강조합니다.

#### 개방형 생성에서의 평가

표준 벤치마크 외에도 개방형 대화 벤치마크에서 모델들을 추가로 평가했습니다. 영어 개방형 대화 생성을 위해서는 MT-Bench와 AlpacaEval 2.0을 벤치마크로 활용했습니다.

| 모델                        | MT-Bench | AlpacaEval 2.0 |
| --------------------------- | -------- | -------------- |
| DeepSeek 67B Chat           | 8.35     | 16.6           |
| Mistral 8x22B Instruct v0.1 | 8.66     | 30.9           |
| Qwen1.5 72B Chat            | 8.61     | 36.6           |
| LLaMA3 70B Instruct         | 8.95     | 34.4           |
| DeepSeek-V2 Chat (SFT)      | 8.62     | 30.0           |
| DeepSeek-V2 Chat (RL)       | 8.97     | 38.9           |

평가 결과는 DeepSeek-V2 Chat(RL)이 DeepSeek-V2 Chat(SFT)에 비해 상당한 성능 우위를 보여준다는 것을 나타냅니다. 이러한 결과는 개선된 정렬을 달성하는 데 있어서 RL 훈련의 효과를 보여줍니다. 다른 오픈소스 모델들과 비교하면, DeepSeek-V2 Chat(RL)은 두 벤치마크 모두에서 Mistral 8x22B Instruct와 Qwen1.5 72B Chat보다 우수한 성능을 보여줍니다. LLaMA3 70B Instruct와 비교할 때, DeepSeek-V2 Chat(RL)은 MT-Bench에서 경쟁력 있는 성능을 보이고 AlpacaEval 2.0에서 현저히 뛰어난 성능을 보입니다.

이러한 결과들은 특히 명령어 기반 대화 작업에서 고품질이고 맥락적으로 관련성 있는 응답을 생성하는 DeepSeek-V2 Chat(RL)의 강력한 성능을 강조합니다.

또한 AlignBench를 기반으로 중국어 개방형 생성 능력을 평가했습니다. DeepSeek-V2 Chat(RL)은 DeepSeek-V2 Chat(SFT)에 비해 약간의 우위를 보입니다. 주목할 만한 점은 DeepSeek-V2 Chat(SFT)가 모든 오픈소스 중국어 모델을 상당한 차이로 능가한다는 것입니다. 중국어 추론과 언어 모두에서 두 번째로 좋은 오픈소스 모델인 Qwen1.5 72B Chat을 크게 능가합니다.

더욱이 DeepSeek-V2 Chat(SFT)와 DeepSeek-V2 Chat(RL) 모두 GPT-4-0613과 ERNIEBot 4.0을 능가하여 중국어를 지원하는 최고 수준의 LLM에서 모델들의 위치를 확고히 합니다. 특히 DeepSeek-V2 Chat(RL)은 GPT-4-Turbo-1106-Preview를 포함한 모든 모델을 능가하는 중국어 언어 이해에서 놀라운 성능을 보입니다. 반면 DeepSeek-V2 Chat(RL)의 추론 능력은 여전히 Erniebot-4.0과 GPT-4s와 같은 거대 모델들에 뒤처집니다.

### 논의

#### SFT 데이터의 양

대규모 SFT 코퍼스의 필요성을 둘러싼 논의는 격렬한 논쟁의 주제였습니다. 이전 연구들은 10K 미만의 SFT 데이터 인스턴스만으로도 만족스러운 결과를 얻기에 충분하다고 주장했습니다. 그러나 실험에서는 10K 미만의 인스턴스를 사용할 경우 IFEval 벤치마크에서 상당한 성능 저하를 관찰했습니다.

가능한 설명은 언어 모델이 특정 기술을 개발하기 위해서는 일정량의 데이터가 필요하다는 것입니다. 모델 크기가 증가함에 따라 필요한 데이터 양이 줄어들 수 있지만, 완전히 제거될 수는 없습니다. 이러한 관찰은 LLM에 원하는 능력을 갖추기 위해서는 충분한 데이터가 중요하다는 필요성을 강조합니다.

더욱이 SFT 데이터의 품질도 중요하며, 특히 작문이나 개방형 질문과 관련된 작업에서 그렇습니다. 데이터의 양과 품질 사이의 균형을 맞추는 것이 효과적인 모델 정렬의 핵심입니다.

#### 강화 학습의 정렬 세금

인간 선호도 정렬 과정에서 AI와 인간 평가자 모두가 평가한 점수 측면에서 개방형 생성 벤치마크에서 상당한 성능 향상을 관찰했습니다. 그러나 "정렬 세금" 현상도 주목했는데, 즉 정렬 과정이 BBH와 같은 일부 표준 벤치마크의 성능에 부정적인 영향을 미칠 수 있다는 것입니다.

정렬 세금을 완화하기 위해 RL 단계에서 데이터 처리와 훈련 전략 개선에 상당한 노력을 기울여 표준 벤치마크와 개방형 벤치마크의 성능 간에 허용 가능한 절충점을 달성했습니다. 일반적인 성능을 손상시키지 않으면서 모델을 인간 선호도와 정렬하는 방법을 탐구하는 것은 향후 연구를 위한 가치 있는 방향을 제시합니다.

#### 온라인 강화 학습

선호도 정렬 실험에서 온라인 접근법이 오프라인 접근법을 크게 능가한다는 것을 발견했습니다. 따라서 DeepSeek-V2를 정렬하기 위한 온라인 RL 프레임워크 구현에 엄청난 노력을 투자했습니다. 온라인 또는 오프라인 선호도 정렬에 대한 결론은 다양한 맥락에서 달라질 수 있으며, 이들 간의 더 철저한 비교와 분석은 향후 작업을 위해 남겨둡니다.

온라인 RL의 장점은 실시간으로 모델의 행동을 관찰하고 조정할 수 있다는 점에 있습니다. 이는 모델이 더 동적이고 적응적인 학습을 할 수 있게 하며, 특히 복잡한 대화 상황에서 더 나은 성능을 보일 수 있습니다.
## 결론, 한계, 그리고 향후 연구

DeepSeek-V2는 128K 컨텍스트 길이를 지원하는 대규모 MoE 언어 모델로서, 강력한 성능과 함께 경제적인 훈련과 효율적인 추론을 특징으로 합니다. 이 모델은 혁신적인 아키텍처인 MLA(Multi-head Latent Attention)와 DeepSeekMoE를 통해 이러한 장점을 실현했습니다.

### 주요 성과와 기술적 혁신

DeepSeek-V2의 가장 주목할 만한 성과는 효율성과 성능의 동시 달성입니다. 이전 모델인 DeepSeek 67B와 비교했을 때, DeepSeek-V2는 훨씬 강력한 성능을 달성하면서도 동시에 42.5%의 훈련 비용 절감, 93.3%의 KV 캐시 감소, 그리고 5.76배의 최대 생성 처리량 향상을 이루어냈습니다. 이러한 개선은 단순한 점진적 발전이 아니라 아키텍처 혁신을 통한 근본적인 효율성 향상을 의미합니다.

특히 주목할 점은 단 21B개의 활성화된 파라미터만으로도 DeepSeek-V2가 오픈소스 모델 중 최고 수준의 성능을 달성하고 가장 강력한 오픈소스 MoE 모델이 되었다는 것입니다. 이는 MoE 아키텍처의 희소성과 MLA의 효율적인 어텐션 메커니즘이 결합되어 만들어낸 시너지 효과의 결과입니다.

평가 결과에서도 이러한 성과가 명확히 드러납니다. AlpacaEval 2.0에서 38.9의 길이 제어 승률, MT-Bench에서 8.97의 전체 점수, AlignBench에서 7.91의 전체 점수를 달성한 것은 DeepSeek-V2 Chat(RL)이 오픈소스 채팅 모델 중 최고 수준의 성능을 가지고 있음을 보여줍니다. 특히 AlignBench 평가에서는 중국어 능력에서 DeepSeek-V2 Chat(RL)이 모든 오픈소스 모델을 능가하고 심지어 대부분의 폐쇄형 모델도 이긴다는 결과를 보여주었습니다.

### 모델의 한계와 제약사항

DeepSeek-V2와 그 채팅 버전들은 다른 대규모 언어 모델들에서 공통적으로 발견되는 인정된 한계점들을 공유합니다. 첫째, 사전 훈련 이후 지속적인 지식 업데이트가 부족하다는 점입니다. 이는 모델이 훈련 데이터의 시점 이후에 발생한 새로운 정보나 변화를 반영하지 못한다는 의미입니다. 이러한 지식 컷오프 문제는 현재 대부분의 언어 모델이 직면한 공통적인 과제로, 실시간 정보 업데이트나 동적 지식 통합 메커니즘의 부재로 인해 발생합니다.

둘째, 검증되지 않은 조언과 같은 사실이 아닌 정보를 생성할 가능성이 있습니다. 이는 모델이 훈련 데이터에서 학습한 패턴을 바탕으로 그럴듯하지만 정확하지 않은 정보를 생성할 수 있음을 의미합니다. 특히 전문적인 조언이나 의학적, 법적 정보와 같은 민감한 영역에서는 이러한 한계가 더욱 중요한 고려사항이 됩니다.

셋째, 환각(hallucination) 현상을 일으킬 가능성이 있습니다. 환각은 모델이 존재하지 않는 사실이나 정보를 마치 실제인 것처럼 생성하는 현상으로, 대규모 언어 모델의 고질적인 문제 중 하나입니다. 이는 모델이 확률적 생성 과정을 통해 작동하며, 때로는 훈련 데이터에 없는 내용을 그럴듯하게 조합하여 생성할 수 있기 때문입니다.

또한 DeepSeek-V2는 주로 중국어와 영어 콘텐츠로 구성된 데이터에서 훈련되었기 때문에, 다른 언어에서는 제한된 능력을 보일 수 있습니다. 중국어와 영어 이외의 시나리오에서는 주의해서 사용해야 합니다. 이러한 언어적 제약은 모델의 글로벌 활용도를 제한하는 요소가 될 수 있으며, 다국어 지원을 위해서는 추가적인 훈련이나 특화된 접근법이 필요할 것입니다.

### 향후 연구 방향과 발전 계획

DeepSeek은 장기적인 관점에서 오픈소스 대규모 모델에 지속적으로 투자하여 점진적으로 인공일반지능(AGI)의 목표에 접근하고자 합니다. 이러한 비전을 실현하기 위한 구체적인 연구 방향들이 제시되었습니다.

첫째, 지속적인 탐구에서 경제적인 훈련과 추론 비용을 유지하면서 MoE 모델을 더욱 확장할 수 있는 방법을 고안하는 데 전념하고 있습니다. 다음 단계의 목표는 향후 릴리스에서 GPT-4와 동등한 성능을 달성하는 것입니다. 이는 단순히 모델 크기를 늘리는 것이 아니라, 아키텍처 혁신과 효율성 개선을 통해 더 나은 성능을 달성하겠다는 의미입니다. MLA와 DeepSeekMoE 아키텍처의 추가적인 최적화와 새로운 기술적 혁신을 통해 이러한 목표를 달성할 계획입니다.

둘째, 정렬 팀은 모델을 지속적으로 개선하여 전 세계 사용자들에게 도움이 될 뿐만 아니라 정직하고 안전한 모델을 개발하는 것을 목표로 하고 있습니다. 궁극적인 목표는 인간의 감독 필요성을 최소화하면서 모델의 가치를 인간의 가치와 일치시키는 것입니다. 윤리적 고려사항과 책임감 있는 개발을 우선시함으로써, 사회에 긍정적이고 유익한 영향을 미치는 것에 전념하고 있습니다. 이는 기술적 성능 향상뿐만 아니라 AI 안전성과 인간 가치 정렬이라는 더 넓은 관점에서의 발전을 추구한다는 것을 의미합니다.

셋째, 현재 DeepSeek-V2는 텍스트 모달리티만을 지원하도록 설계되었습니다. 미래 지향적인 계획에서는 모델이 다중 모달리티를 지원할 수 있도록 하여 더 넓은 범위의 시나리오에서 다양성과 유용성을 향상시킬 계획입니다. 이는 텍스트뿐만 아니라 이미지, 오디오, 비디오 등 다양한 형태의 데이터를 처리할 수 있는 통합된 모델로의 발전을 의미합니다. 다중 모달리티 지원은 현재 AI 연구의 중요한 트렌드 중 하나로, 더욱 포괄적이고 실용적인 AI 시스템 구축을 위한 필수적인 발전 방향입니다.

### 기술적 기여의 의의

DeepSeek-V2의 기술적 혁신은 대규모 언어 모델 분야에서 중요한 이정표를 제시합니다. MLA 아키텍처는 어텐션 메커니즘의 효율성 문제를 근본적으로 해결하는 새로운 접근법을 제시했으며, DeepSeekMoE는 희소 모델의 전문가 특화를 극대화하는 혁신적인 방법을 보여주었습니다. 이러한 기술적 기여들은 단순히 성능 향상에 그치지 않고, 대규모 모델의 실용적 배포와 광범위한 채택을 위한 중요한 진전을 나타냅니다.

특히 경제적인 훈련 비용과 효율적인 추론 처리량의 동시 달성은 AI 기술의 민주화와 접근성 향상에 중요한 기여를 합니다. 이는 더 많은 연구자와 개발자들이 대규모 언어 모델을 활용할 수 있는 기회를 제공하며, 오픈소스 AI 생태계의 발전에도 긍정적인 영향을 미칠 것으로 기대됩니다.

DeepSeek-V2는 강력한 성능, 경제적인 훈련, 효율적인 추론이라는 세 가지 핵심 목표를 동시에 달성함으로써, 차세대 대규모 언어 모델의 새로운 패러다임을 제시했습니다. 이러한 성과는 향후 AI 연구와 개발에 중요한 방향성을 제공하며, 인공일반지능을 향한 여정에서 의미 있는 진전을 나타냅니다.
## 부록

### DeepSeek-V2-Lite: MLA와 DeepSeekMoE를 갖춘 16B 모델

#### 모델 설명

**아키텍처**

DeepSeek-V2-Lite는 MLA와 DeepSeekMoE 아키텍처의 효과를 더 작은 규모에서 검증하기 위해 개발된 모델입니다. 이 모델은 27개의 레이어와 2048의 숨겨진 차원을 가지고 있으며, MLA를 채택하여 16개의 어텐션 헤드를 사용하고 각 헤드의 차원은 128입니다.

KV 압축 차원은 512로 설정되었지만, DeepSeek-V2와 약간 다르게 쿼리는 압축하지 않습니다. 분리된 쿼리와 키의 경우 헤드당 차원을 64로 설정했습니다. 이러한 설정은 더 작은 모델에서도 MLA의 핵심 원리를 유지하면서 구현 복잡성을 줄이기 위한 것입니다.

DeepSeek-V2-Lite도 DeepSeekMoE를 채택하며, 첫 번째 레이어를 제외한 모든 FFN이 MoE 레이어로 대체됩니다. 각 MoE 레이어는 2개의 공유 전문가와 64개의 라우팅된 전문가로 구성되며, 각 전문가의 중간 숨겨진 차원은 1408입니다. 라우팅된 전문가 중에서는 각 토큰당 6개의 전문가가 활성화됩니다.

이러한 구성 하에서 DeepSeek-V2-Lite는 총 15.7B개의 파라미터를 포함하며, 이 중 각 토큰당 2.4B개가 활성화됩니다. 이는 전체 모델의 약 15.3%가 각 토큰 처리에 사용된다는 의미로, 효율적인 희소 아키텍처를 구현했음을 보여줍니다.

**훈련 세부사항**

DeepSeek-V2-Lite는 DeepSeek-V2와 동일한 사전 훈련 코퍼스에서 처음부터 훈련되었으며, 이 코퍼스는 SFT 데이터로 오염되지 않았습니다. AdamW 옵티마이저를 사용했으며, 하이퍼파라미터는 $\beta_1 = 0.9$, $\beta_2 = 0.95$, $\text{weight\_decay} = 0.1$로 설정되었습니다.

학습률은 warmup-and-step-decay 전략을 사용하여 스케줄링되었습니다. 초기에는 학습률이 첫 2K 스텝 동안 0에서 최대값까지 선형적으로 증가합니다. 이후 약 80%의 토큰을 훈련한 후 학습률에 0.316을 곱하고, 약 90%의 토큰을 훈련한 후 다시 0.316을 곱합니다. 최대 학습률은 $4.2 \times 10^{-4}$로 설정되었으며, 그래디언트 클리핑 노름은 1.0으로 설정되었습니다.

배치 크기 스케줄링 전략은 사용하지 않았으며, 4608 시퀀스의 일정한 배치 크기로 훈련되었습니다. 사전 훈련 중 최대 시퀀스 길이는 4K로 설정되었으며, DeepSeek-V2-Lite는 5.7T 토큰에서 훈련되었습니다.

파이프라인 병렬성을 활용하여 서로 다른 레이어를 서로 다른 장치에 배포했지만, 각 레이어에 대해 모든 전문가는 동일한 장치에 배포됩니다. 따라서 $\alpha_1 = 0.001$의 작은 전문가 수준 밸런스 손실만 사용하고, 장치 수준 밸런스 손실과 통신 밸런스 손실은 사용하지 않습니다.

사전 훈련 후에는 DeepSeek-V2-Lite에 대해서도 긴 컨텍스트 확장과 SFT를 수행하여 DeepSeek-V2-Lite Chat이라는 채팅 모델을 얻었습니다.

#### 성능 평가

**기본 모델**

| 벤치마크            | DeepSeek 7B | DeepSeekMoE 16B | DeepSeek-V2-Lite |
| ------------------- | ----------- | --------------- | ---------------- |
| 아키텍처            | MHA+Dense   | MHA+MoE         | MLA+MoE          |
| 컨텍스트 길이       | 4K          | 4K              | 32K              |
| # 활성화된 파라미터 | 6.9B        | 2.8B            | 2.4B             |
| # 총 파라미터       | 6.9B        | 16.4B           | 15.7B            |
| # 훈련 토큰         | 2T          | 2T              | 5.7T             |
| **영어**            |             |                 |                  |
| MMLU                | 48.2        | 45.0            | 58.3             |
| BBH                 | 39.5        | 38.9            | 44.1             |
| TriviaQA            | 59.7        | 64.8            | 64.2             |
| NaturalQuestions    | 22.2        | 25.5            | 26.0             |
| ARC-Easy            | 67.9        | 68.1            | 70.9             |
| ARC-Challenge       | 48.1        | 49.8            | 51.2             |
| AGIEval             | 26.4        | 17.4            | 33.2             |
| **코드**            |             |                 |                  |
| HumanEval           | 26.2        | 26.8            | 29.9             |
| MBPP                | 39.0        | 39.2            | 43.2             |
| **수학**            |             |                 |                  |
| GSM8K               | 17.4        | 18.8            | 41.1             |
| MATH                | 3.3         | 4.3             | 17.1             |
| CMath               | 34.5        | 40.4            | 58.4             |
| **중국어**          |             |                 |                  |
| CLUEWSC             | 73.1        | 72.1            | 74.3             |
| C-Eval              | 45.0        | 40.6            | 60.3             |
| CMMLU               | 47.2        | 42.5            | 64.3             |

DeepSeek-V2-Lite의 성능을 이전 소규모 기본 모델들과 비교한 결과, DeepSeek-V2-Lite는 압도적인 성능 우위를 보여줍니다. 특히 추론, 코딩, 수학 분야에서 현저한 개선을 보입니다.

영어 벤치마크에서 DeepSeek-V2-Lite는 MMLU에서 58.3점을 달성하여 DeepSeek 7B의 48.2점과 DeepSeekMoE 16B의 45.0점을 크게 능가합니다. BBH에서도 44.1점으로 이전 모델들의 39.5점과 38.9점보다 우수한 성능을 보입니다.

수학 분야에서의 개선이 특히 두드러집니다. GSM8K에서 DeepSeek-V2-Lite는 41.1점을 달성하여 이전 모델들의 17.4점과 18.8점을 2배 이상 능가합니다. MATH 벤치마크에서는 17.1점으로 이전 모델들의 3.3점과 4.3점보다 4-5배 향상된 성능을 보입니다.

중국어 능력에서도 상당한 개선을 보여줍니다. C-Eval에서 60.3점, CMMLU에서 64.3점을 달성하여 이전 모델들을 크게 능가합니다. 이는 MLA와 DeepSeekMoE 아키텍처가 더 작은 규모에서도 효과적으로 작동함을 보여주는 중요한 증거입니다.

**채팅 모델**

| 벤치마크            | DeepSeek 7B Chat | DeepSeekMoE 16B Chat | DeepSeek-V2-Lite Chat |
| ------------------- | ---------------- | -------------------- | --------------------- |
| 아키텍처            | MHA+Dense        | MHA+MoE              | MLA+MoE               |
| 컨텍스트 길이       | 4K               | 4K                   | 32K                   |
| # 활성화된 파라미터 | 6.9B             | 2.8B                 | 2.4B                  |
| # 총 파라미터       | 6.9B             | 16.4B                | 15.7B                 |
| # 훈련 토큰         | 2T               | 2T                   | 5.7T                  |
| **영어**            |                  |                      |                       |
| MMLU                | 49.7             | 47.2                 | 55.7                  |
| BBH                 | 43.1             | 42.2                 | 48.1                  |
| TriviaQA            | 59.5             | 63.3                 | 65.2                  |
| NaturalQuestions    | 32.7             | 35.1                 | 35.5                  |
| ARC-Easy            | 70.2             | 69.9                 | 74.3                  |
| ARC-Challenge       | 50.2             | 50.0                 | 51.5                  |
| AGIEval             | 17.6             | 19.7                 | 42.8                  |
| **코드**            |                  |                      |                       |
| HumanEval           | 45.1             | 45.7                 | 57.3                  |
| MBPP                | 39.0             | 46.2                 | 45.8                  |
| **수학**            |                  |                      |                       |
| GSM8K               | 62.6             | 62.2                 | 72.0                  |
| MATH                | 14.7             | 15.2                 | 27.9                  |
| CMath               | 66.4             | 67.9                 | 71.7                  |
| **중국어**          |                  |                      |                       |
| CLUEWSC             | 66.2             | 68.2                 | 80.0                  |
| C-Eval              | 44.7             | 40.0                 | 60.1                  |
| CMMLU               | 51.2             | 49.3                 | 62.5                  |

채팅 모델 버전에서도 DeepSeek-V2-Lite Chat은 이전 소규모 채팅 모델들을 큰 폭으로 능가합니다. 특히 코드 생성 능력에서 HumanEval에서 57.3점을 달성하여 이전 모델들의 45.1점과 45.7점보다 현저히 우수한 성능을 보입니다.

수학 능력에서도 GSM8K에서 72.0점, MATH에서 27.9점을 달성하여 이전 모델들을 크게 능가합니다. 이는 SFT와 정렬 과정을 거친 후에도 MLA와 DeepSeekMoE 아키텍처의 장점이 유지됨을 보여줍니다.

중국어 능력에서는 CLUEWSC에서 80.0점을 달성하여 이전 모델들의 66.2점과 68.2점보다 10점 이상 향상된 성능을 보입니다. 이러한 결과들은 DeepSeek-V2-Lite가 더 작은 규모에서도 혁신적인 아키텍처의 효과를 성공적으로 구현했음을 보여줍니다.

### MLA의 완전한 수식

MLA의 완전한 계산 과정을 보여주기 위해 전체 수식을 제공합니다. 이는 MLA 메커니즘의 구현과 최적화 전략을 이해하는 데 도움이 됩니다.

쿼리 계산:

$$\mathbf{c}_t^Q = W^{DQ}\mathbf{h}_t$$

$$[\mathbf{q}_{t,1}^C; \mathbf{q}_{t,2}^C; ...; \mathbf{q}_{t,n_h}^C] = \mathbf{q}_t^C = W^{UQ}\mathbf{c}_t^Q$$

$$[\mathbf{q}_{t,1}^R; \mathbf{q}_{t,2}^R; ...; \mathbf{q}_{t,n_h}^R] = \mathbf{q}_t^R = \text{RoPE}(W^{QR}\mathbf{c}_t^Q)$$

$$\mathbf{q}_{t,i} = [\mathbf{q}_{t,i}^C; \mathbf{q}_{t,i}^R]$$

키-값 계산:

$$\boxed{\mathbf{c}_t^{KV}} = W^{DKV}\mathbf{h}_t$$

$$[\mathbf{k}_{t,1}^C; \mathbf{k}_{t,2}^C; ...; \mathbf{k}_{t,n_h}^C] = \mathbf{k}_t^C = W^{UK}\mathbf{c}_t^{KV}$$

$$\boxed{\mathbf{k}_t^R} = \text{RoPE}(W^{KR}\mathbf{h}_t)$$

$$\mathbf{k}_{t,i} = [\mathbf{k}_{t,i}^C; \mathbf{k}_t^R]$$

$$[\mathbf{v}_{t,1}^C; \mathbf{v}_{t,2}^C; ...; \mathbf{v}_{t,n_h}^C] = \mathbf{v}_t^C = W^{UV}\mathbf{c}_t^{KV}$$

어텐션 출력 계산:

$$\mathbf{o}_{t,i} = \sum_{j=1}^t \text{Softmax}_j\left(\frac{\mathbf{q}_{t,i}^T\mathbf{k}_{j,i}}{\sqrt{d_h+d_h^R}}\right)\mathbf{v}_{j,i}^C$$

$$\mathbf{u}_t = W^O[\mathbf{o}_{t,1}; \mathbf{o}_{t,2}; ...; \mathbf{o}_{t,n_h}]$$

박스로 표시된 벡터들은 생성을 위해 캐시되어야 하는 요소들입니다. 추론 중에는 순진한 수식이 어텐션을 위해 $\mathbf{c}_t^{KV}$에서 $\mathbf{k}_t^C$와 $\mathbf{v}_t^C$를 복구해야 합니다.

다행히 행렬 곱셈의 결합법칙으로 인해 $W^{UK}$를 $W^{UQ}$에 흡수시킬 수 있고, $W^{UV}$를 $W^O$에 흡수시킬 수 있습니다. 따라서 각 쿼리에 대해 키와 값을 실제로 계산할 필요가 없습니다. 이러한 최적화를 통해 추론 중 $\mathbf{k}_t^C$와 $\mathbf{v}_t^C$를 재계산하는 계산 오버헤드를 피할 수 있습니다.

이러한 수식들은 MLA가 어떻게 효율적인 추론을 달성하면서도 강력한 성능을 유지하는지를 보여주는 핵심적인 수학적 기반을 제공합니다.
- - -
### References
* [DeepSeek-V2: A Strong, Economical, and Efficient Mixture-of-Experts Language Model](http://arxiv.org/pdf/2405.04434v5)
