---
layout: post
title: "AgentInstruct: Toward Generative Teaching with Agentic Flows"
date: 2024-07-03 21:01:12
author: "Microsoft Research"
categories: ["Paper Reviews", "Language-Models"]
tags: ["Generative-Teaching", "Agentic-Workflow-Generation", "Large-Scale-Agentic-Data-Synthesis", "Content-Transformation-Agents", "Seed-Instruction-Creation-Flow", "Instruction-Refinement-Flow", "Suggester-Editor-Agent-Pairs", "Taxonomy-Driven-Instruction-Diversity", "Skill-Specific-Synthetic-Data-Generation", "Multi-Stage-Instruction-Refinement"]
cover: /assets/images/language-models.jpg
use_math: true
---
### TL;DR
# AgentInstruct: 에이전틱 플로우를 활용한 생성적 교육 - 종합 기술 요약

## 이 연구를 시작하게 된 배경과 동기는 무엇입니까?

합성 데이터는 대규모 언어 모델(LLM)과 소규모 언어 모델(SLM) 모두의 발전을 가속화하는 데 있어 점점 더 중요한 역할을 하고 있습니다. 사전 훈련부터 인스트럭션 튜닝, 강화학습 기반 인간 피드백(RLHF)에 이르기까지 모든 훈련 단계에서 합성 데이터가 모델 개발을 크게 진전시켜 왔으며, 특히 소규모 언어 모델의 발전에 있어 그 역할은 매우 중요했습니다. 그러나 이러한 성공에도 불구하고 연구자들은 심각한 우려를 제기해왔습니다. 다른 모델이 생성한 합성 데이터로 모델을 사전 훈련시키면 **모델 붕괴(model collapse)** 현상이 발생할 수 있으며, 이는 모델이 점진적으로 퇴화하는 결과를 초래합니다. 또한 사후 훈련을 위한 합성 데이터 사용에 대해서도 유사한 주장이 제기되었는데, 훈련된 모델이 실제 능력이 아닌 문체적 특성만을 학습하는 단순한 모방 과정에 불과할 수 있다는 점입니다.

이러한 불일치는 고품질이고 다양한 합성 데이터를 생성하는 것이 근본적으로 어렵다는 관찰로 설명될 수 있습니다. 합성 데이터의 성공적인 활용 사례들을 살펴보면, 데이터의 품질을 보장하기 위해 큐레이션과 필터링에 상당한 인간의 노력이 투입되었음을 알 수 있습니다. 가장 널리 사용되는 접근법은 프롬프트 세트로 시작하여 GPT-4와 같은 강력한 모델을 사용해 이러한 프롬프트에 대한 응답을 생성하는 것이지만, 이 방법은 기존 프롬프트에 의존하므로 데이터의 다양성이 제한됩니다. 지난해 우리가 목격한 또 다른 주요 발전은 **에이전틱(Agentic) 워크플로우**, 특히 멀티 에이전트 워크플로우의 부상입니다. CAMEL 프레임워크와 AutoGen과 같은 에이전틱 워크플로우는 반성(reflection)과 반복(iteration)을 포함하는 플로우를 사용하여 기본 LLM의 능력을 뛰어넘는 고품질 데이터를 생성할 수 있으며, 도구(검색 API, 계산기, 코드 인터프리터)를 사용하여 LLM의 한계를 해결할 수 있습니다.

## 이 연구에서 제시하는 새로운 해결 방법은 무엇입니까?

본 연구는 **생성적 교육(Generative Teaching)**이라는 새로운 개념을 제시합니다. 이는 강력한 모델이 데이터를 생성하여 다른 모델에게 새로운 기술이나 행동을 가르치는 설정을 의미합니다. 이 개념을 구현하기 위해 저자들은 **AgentInstruct**라는 확장 가능한 에이전틱 프레임워크를 소개합니다. AgentInstruct는 텍스트 문서와 코드 파일과 같은 원시 데이터 소스만을 시드로 사용하여 프롬프트와 응답을 모두 생성할 수 있습니다. 이 접근법의 핵심 혁신은 **세 가지 계층적 에이전트 플로우**의 조합입니다. 첫째, **콘텐츠 변환 플로우**는 원시 시드를 특정 목표에 맞춤화된 인스트럭션 생성을 단순화하는 중간 표현으로 변환합니다. 예를 들어, 일반적인 텍스트 문서를 논증 구절, 대화, 회의록, 시 등 다양한 형태로 변환함으로써 동일한 원시 콘텐츠로부터 서로 다른 특성을 가진 인스트럭션을 생성할 수 있는 기반을 마련합니다.

둘째, **시드 인스트럭션 생성 플로우**는 변환된 콘텐츠로부터 다양한 인스트럭션 세트를 생성합니다. 이 플로우는 사전 정의되었지만 확장 가능한 분류 체계(taxonomy)에 의존하며, 각 기술에 대해 100개 이상의 하위 카테고리를 포함합니다. 예를 들어, 독해 능력을 위한 분류 체계는 문자적 이해, 비판적 분석, 논리적 추론 등 여러 카테고리로 구성되며, 각 카테고리는 다시 세부 질문 유형으로 나뉩니다. 셋째, **인스트럭션 정제 플로우**는 시드 인스트럭션 플로우로부터 생성된 인스트럭션을 입력으로 받아 복잡성과 품질을 반복적으로 향상시킵니다. 이를 위해 **제안자-편집자 에이전트(Suggester-Editor Agents)** 개념을 사용합니다. 제안자 에이전트는 초기 인스트럭션의 복잡도를 높이기 위한 다양한 접근법을 제안하며, 편집자 에이전트는 이러한 제안에 따라 인스트럭션을 실제로 수정합니다.

AgentInstruct의 핵심 강점은 **원시 데이터를 시드로 사용**한다는 점입니다. 이는 두 가지 중요한 이점을 제공합니다. 첫째, 이러한 데이터는 풍부하게 사용 가능하여 AgentInstruct가 대량의 다양한 데이터를 생성할 수 있게 합니다. 둘째, 기존 프롬프트를 그대로 사용하거나 패러프레이징한 후 사용하는 것을 피하고 원시 데이터를 시드로 사용함으로써, 벤치마크 특화 능력이 아닌 더 일반적인 능력을 학습하도록 촉진할 수 있습니다. 이는 모델이 특정 벤치마크에 과적합되지 않고 실제 세계의 다양한 상황에 대응할 수 있는 근본적인 능력을 개발하도록 유도합니다.

## 제안된 방법은 어떻게 구현되었습니까?

AgentInstruct의 유용성을 입증하기 위해 저자들은 **2,500만 쌍의 사후 훈련 데이터셋**을 생성했습니다. 이 데이터셋은 텍스트 편집, 창의적 글쓰기, 도구 사용, 코딩, 독해 등 **17개의 서로 다른 기술**을 가르치기 위해 설계되었습니다. 시드 데이터로는 KnowledgePile, AutoMathText, OpenStax의 일부 자료, 그리고 Apache-2.0 라이선스를 가진 소스 코드 파일의 일부가 활용되었습니다. 독해 능력을 위한 구현을 예로 들면, 콘텐츠 변환 플로우는 9개의 콘텐츠 변환 에이전트를 사용하여 원시 텍스트를 다양한 형태로 변환합니다. 논증 구절 생성기는 일반 텍스트를 논리적 주장과 근거를 포함하는 논증 형태로 변환하며, 토론 구절 생성기는 상반된 관점을 제시하는 토론 형식으로 변환합니다. 시드 인스트럭션 생성 플로우는 43개의 질문 유형을 포함하는 분류 체계를 사용하여 문자적 이해, 비판적 분석, 논리적 추론 등 다양한 범위의 질문을 생성합니다.

정제 플로우에서는 제안자-편집자 에이전트 쌍이 초기 질문의 복잡도를 높입니다. 예를 들어, "저자의 주요 주장은 무엇인가?"라는 단순한 질문은 "저자의 명시적 주장과 암묵적 가정을 구별하고, 이러한 가정이 논증의 타당성에 어떤 영향을 미치는지 분석하시오"와 같은 복잡한 질문으로 발전할 수 있습니다. 텍스트 수정을 위한 플로우는 18개의 작업 유형을 다루며, 패러프레이징, 텍스트 단순화, 확장, 번역, 형식 변환, 감정 수정 등을 포함합니다. 도구 사용을 위한 플로우는 소스 코드 스니펫이나 API 설명을 시드로 사용하며, 콘텐츠 변환 에이전트가 원시 코드나 API 문서를 구조화된 API 명세로 변환합니다. 시드 인스트럭션 생성 플로우는 단일 API 사용과 다중 API 사용을 모두 다루는 작업을 생성하며, 정제 플로우는 다중 턴 대화로 확장하거나 오류 처리를 요구하거나 최적화 제약 조건을 추가하여 복잡도를 높입니다.

생성된 데이터셋으로 **Mistral-7b-v0.1**을 파인튜닝하여 **Orca-3** 모델을 만들었습니다. 훈련은 19개의 NVIDIA A100 노드(총 152개의 GPU)를 사용하여 수행되었으며, 각 GPU는 배치 크기 10으로 설정되어 전체 글로벌 배치 크기는 1,520개의 샘플이 됩니다. 최대 시퀀스 길이는 8192 토큰으로 설정되었으며, 패킹(packing) 기법이 적용되었습니다. 훈련 손실은 프롬프트가 아닌 응답 부분에 대해서만 계산되도록 레이블 마스킹(label masking)이 적용되었습니다. 옵티마이저로는 AdamW가 사용되었으며, 초기 학습률은 $8 \times 10^{-6}$으로 설정되었습니다. 학습률 스케줄로는 코사인 학습률 스케줄이 사용되었으며, 초기 500 스텝 동안 선형 학습률 워밍업이 적용되었습니다. 가중치 감쇠는 0.1로 설정되었으며, 모델은 총 3 에포크 동안 훈련되었고 전체 훈련 과정은 약 200시간이 소요되었습니다.

## 이 연구의 결과가 가지는 의미는 무엇입니까?

AgentInstruct 데이터의 효과는 광범위한 벤치마크에서 관찰된 상당한 성능 향상으로 입증됩니다. Orca-3는 **Orca-Bench 데이터셋**에서 9.55점을 달성하여 Orca-2.5(7.13점) 대비 33.94%, Mistral-Instruct-7B(8.31점) 대비 14.92%의 향상을 보였습니다. 표준 벤치마크에서도 인상적인 결과를 달성했습니다. AGIEval에서 40.2%의 향상, MMLU에서 19.4%의 향상, BBH에서 38.3%의 향상, GSM8K에서 53.7%의 향상, AlpacaEval에서 45.0%의 향상을 달성했습니다. 특히 독해 능력 평가에서 LSAT 논리적 추론(lsat-lr)에서 45%의 향상을 보였으며, 이는 AgentInstruct의 논증 강화/약화 질문 생성 플로우가 효과적으로 작동했음을 보여줍니다. 수학 능력 평가에서는 BBH 다단계 산술에서 1418%의 극적인 향상을 보였으며, 이는 AgentInstruct의 수학 문제 생성 플로우가 복잡한 다단계 추론 능력을 효과적으로 가르쳤음을 보여줍니다.

요약 능력 평가에서 AgentInstruct 접근법을 통해 환각을 31.34% 감소시키면서 GPT-4(교사)와 비슷한 품질 수준을 달성했습니다. RAG(검색 증강 생성) 능력 평가에서는 MIRAGE 벤치마크의 PubMedQA에서 Mistral-Instruct 대비 92.71%의 상대적 향상을 달성했습니다. 형식 준수 능력 평가에서 FoFo 벤치마크에서 84.01점을 달성하여 Gemini Pro(80.25)를 능가하고 GPT-4(87.45)에 근접한 성능을 보였습니다. 이러한 결과들은 AgentInstruct가 생성한 합성 데이터가 모델의 다양한 능력을 효과적으로 향상시킬 수 있음을 명확히 보여줍니다.

본 연구의 이론적 의의는 **합성 데이터 생성의 자동화 가능성**을 입증했다는 점입니다. 기존의 많은 접근법들이 인간의 광범위한 개입을 필요로 했던 반면, AgentInstruct는 에이전틱 플로우를 통해 대규모의 고품질 데이터를 자동으로 생성할 수 있음을 보여주었습니다. 실제 응용 측면에서 이 접근법은 모든 기본 LLM의 지속적인 학습과 개선을 가능하게 할 수 있습니다. 원시 자료(일반 모델 훈련을 위한 웹 데이터 또는 전문 모델을 위한 도메인 특화 데이터)로 시작하여 사후 훈련 및 파인튜닝을 위한 데이터를 생성함으로써, 모든 기본 LLM의 지속적인 학습과 개선을 가능하게 할 수 있습니다. 또한 AgentInstruct 접근법은 더 크고 능력 있는 모델의 자기 개선(self-improvement)에 사용될 수 있습니다. 새로운 프롬프트를 생성할 수 있는 능력과 도구, 반성 등의 사용으로 인해 에이전틱 플로우에 사용된 LLM의 품질을 초과하는 응답을 생성할 수 있기 때문입니다.

그러나 본 연구는 여러 한계점을 가지고 있습니다. **확장성 측면**에서 서로 다른 기술에 대한 에이전틱 플로우를 생성하는 것은 플로우 구축을 위한 인간의 노력에 의존합니다. **정확성 측면**에서 합성 데이터는 실제 세계 데이터의 복잡성과 미묘한 차이를 완벽하게 재현하지 못할 수 있습니다. **비용 측면**에서 여러 에이전트와 도구를 사용하는 LLM으로 합성 데이터를 생성하는 것은 자원 집약적입니다. **편향 측면**에서 합성 데이터를 생성하는 데 사용된 원래 시드 데이터에 편향이 포함되어 있다면, 이러한 편향은 합성 데이터에 반영되고 심지어 증폭될 수 있습니다. 향후 연구에서는 사용자 명세로부터 에이전틱 플로우의 구축을 자동화하는 방법, 합성 데이터 품질 평가 방법의 개선, 편향 완화 전략의 개발, 그리고 더 효율적인 데이터 생성 메커니즘의 연구가 필요합니다.
- - -
# AgentInstruct: 에이전틱 플로우를 활용한 생성적 교육

## 초록

합성 데이터는 대규모 언어 모델과 소규모 언어 모델 모두의 개발을 가속화하는 데 있어 점점 더 중요한 역할을 하고 있습니다. 여러 성공적인 활용 사례가 있음에도 불구하고, 연구자들은 모델 붕괴(model collapse) 현상과 다른 모델을 모방하는 것의 단점에 대한 우려를 제기해왔습니다. 이러한 불일치는 합성 데이터의 품질과 다양성이 매우 다양하다는 사실에 기인합니다. 합성 데이터를 효과적으로 활용하기 위해서는 일반적으로 데이터를 큐레이션하는 데 상당한 인간의 노력이 필요합니다.

본 연구는 사후 훈련을 위한 합성 데이터 활용에 초점을 맞추고 있으며, 특히 강력한 모델이 데이터를 생성하여 다른 모델에게 새로운 기술이나 행동을 가르치는 설정을 다룹니다. 이러한 설정을 생성적 교육(Generative Teaching)이라고 부릅니다. 본 논문에서는 대량의 다양하고 고품질의 합성 데이터를 자동으로 생성하기 위한 확장 가능한 에이전틱 프레임워크인 AgentInstruct를 소개합니다. AgentInstruct는 텍스트 문서와 코드 파일과 같은 원시 데이터 소스만을 시드로 사용하여 프롬프트와 응답을 모두 생성할 수 있습니다.

AgentInstruct의 유용성을 입증하기 위해, 텍스트 편집, 창의적 글쓰기, 도구 사용, 코딩, 독해 등 다양한 기술을 가르치기 위한 2,500만 쌍의 사후 훈련 데이터셋을 생성했습니다. 이 데이터셋은 모든 기본 모델의 인스트럭션 튜닝에 사용될 수 있습니다. 본 연구에서는 이 데이터로 Mistral-7b를 사후 훈련시켰으며, 결과 모델인 Orca-3를 동일한 기본 모델을 사용하는 Mistral-7b-Instruct와 비교했을 때 여러 벤치마크에서 상당한 개선을 관찰했습니다.

![AgentInstruct 데이터를 사용한 사후 훈련 효과](/assets/2025-10-19-agentinstruct--toward-generative-teaching-with-agentic-flows/0.png)

위 그래프는 Mistral-7B를 AgentInstruct 데이터로 사후 훈련시킨 결과를 보여줍니다. AGIEval에서 40.2%의 향상, MMLU에서 19.4%의 향상, BBH에서 38.3%의 향상, GSM8K에서 53.7%의 향상, AlpacaEval에서 45.0%의 향상, FoFo에서 38.3%의 향상을 달성했습니다. 또한 MIRAGE-RAG 벤치마크에서도 상당한 성능 개선을 보였습니다. 이러한 결과는 AgentInstruct가 생성한 합성 데이터가 모델의 다양한 능력을 효과적으로 향상시킬 수 있음을 보여줍니다.

## 서론

### 합성 데이터가 대규모 언어 모델 발전을 가속화하다

합성 데이터는 지난 한 해 동안 대규모 언어 모델(LLM) 훈련에서 중요한 발전을 이루었습니다. 합성 데이터는 사전 훈련(예: [Phi-2 모델](https://arxiv.org/pdf/2306.02707))부터 인스트럭션 튜닝(예: [Self-Instruct](https://arxiv.org/pdf/2304.03277), [Alpaca](https://arxiv.org/pdf/2304.03277)), 그리고 강화학습 기반 인간 피드백(RLHF)(예: [Constitutional AI](https://arxiv.org/pdf/2309.00267), [RLAIF](https://arxiv.org/pdf/2309.00267))에 이르기까지 모든 훈련 단계에서 모델 훈련의 진전을 크게 가속화하는 데 사용되었습니다. 특히 소규모 언어 모델(SLM)의 발전에 있어 합성 데이터의 역할은 매우 중요했습니다.

### 고품질 합성 데이터 생성의 어려움

그러나 다른 한편으로는, 다른 모델이 생성한 합성 데이터로 모델을 사전 훈련시키면 모델 붕괴(model collapse)로 이어질 수 있다는 연구 결과도 있습니다. [The Curse of Recursion 연구](https://arxiv.org/pdf/2305.17493)에 따르면, 이는 모델이 점진적으로 퇴화하는 결과를 초래할 수 있습니다. 사후 훈련을 위한 합성 데이터 사용에 대해서도 유사한 주장이 제기되었는데, [The False Promise of Imitating Proprietary LLMs](https://arxiv.org/pdf/2305.15717)에서는 이것이 훈련된 모델이 실제 능력이 아닌 문체적 특성만을 학습하는 모방 과정에 불과할 수 있다고 지적했습니다.

이러한 불일치는 고품질이고 다양한 합성 데이터를 생성하는 것이 어렵다는 관찰로 설명될 수 있습니다. 합성 데이터의 성공적인 활용 사례들을 살펴보면, 데이터의 품질을 보장하기 위해 큐레이션과 필터링에 상당한 인간의 노력이 투입되었음을 알 수 있습니다. 사후 훈련 합성 데이터에 초점을 맞추면, 가장 널리 사용되는 접근법은 프롬프트 세트로 시작하여 GPT-4와 같은 강력한 모델을 사용해 이러한 프롬프트에 대한 응답을 생성하거나 확장된 프롬프트 세트에 대한 응답을 생성하는 것입니다. 이 방법은 교사 모델로부터 설명이나 단계별 지침을 이끌어내거나, 더 복잡한 프롬프팅 기법을 사용하여 더 높은 품질의 답변을 얻음으로써 더욱 개선되었습니다.

### 합성 데이터와 에이전트의 만남

지난 해 우리가 목격한 또 다른 주요 발전은 에이전틱(Agentic) 워크플로우, 특히 멀티 에이전트 워크플로우의 부상입니다. [CAMEL 프레임워크](https://arxiv.org/pdf/2303.17760)와 [AutoGen](https://arxiv.org/pdf/2308.08155)과 같은 에이전틱 워크플로우는 반성(reflection)과 반복(iteration)을 포함하는 플로우를 사용하여 기본 LLM의 능력을 뛰어넘는 고품질 데이터를 생성할 수 있습니다. 이러한 플로우에서 에이전트는 솔루션을 되돌아보고, 비평을 생성하며, 솔루션을 개선할 수 있습니다. 또한 도구(예: 검색 API, 계산기, 코드 인터프리터)를 사용하여 LLM의 한계를 해결할 수 있습니다.

멀티 에이전트 워크플로우는 새로운 프롬프트와 해당 응답을 모두 생성할 수 있는 시나리오를 시뮬레이션할 수 있다는 추가적인 이점을 제공합니다. 또한 일부 작업에서 인간의 개입 필요성을 줄이거나 제거하여 데이터 생성 워크플로우의 자동화를 가능하게 합니다.

### 생성적 교육과 Orca AgentInstruct

사후 훈련을 위한 합성 데이터 생성은 종종 그대로 사용되거나 더 많은 인스트럭션을 생성하기 위한 시드로 사용되는 기존 프롬프트 세트에 의존합니다. 본 연구에서는 문제 설정을 더 넓은 목표로 일반화하여, AI 모델에게 특정 기술을 가르치기 위해 풍부한 양의 다양하고 도전적이며 고품질의 데이터를 생성하는 것을 목표로 합니다. 이러한 설정을 생성적 교육(Generative Teaching)이라고 부릅니다.

AgentInstruct는 생성적 교육을 위한 에이전틱 솔루션입니다. AgentInstruct는 시연(demonstration) 데이터와 피드백 데이터를 생성하는 데 초점을 맞추며, 원시 문서만을 입력으로 필요로 합니다. 일반적인 데이터를 시드로 사용할 때, AgentInstruct는 LLM에게 일반적인 능력(예: 수학, 추론, RAG 등)을 가르치는 데 사용될 수 있습니다. 도메인 특화 데이터(예: 게임, 금융)도 시드로 사용하여 특정 전문 분야에서 모델을 개선할 수 있습니다.

AgentInstruct는 다음을 생성할 수 있습니다.

첫째, 고품질 데이터를 생성합니다. GPT-4와 같은 강력한 모델과 검색 및 코드 인터프리터와 같은 도구를 결합하여 사용합니다. 둘째, 다양한 데이터를 생성합니다. AgentInstruct는 프롬프트와 응답을 모두 생성하며, 다수의 에이전트(강력한 LLM, 도구, 반성 플로우를 갖춘)와 100개 이상의 하위 카테고리로 구성된 분류 체계를 사용하여 다양하고 고품질의 프롬프트와 응답을 생성합니다. 셋째, 대량의 데이터를 생성합니다. AgentInstruct는 자율적으로 실행될 수 있으며 검증 및 데이터 필터링을 위한 플로우를 적용할 수 있습니다. 시드 프롬프트가 필요하지 않으며 원시 문서를 시딩에 사용합니다.

원시 데이터(비구조화된 텍스트 문서 또는 소스 코드)를 시드로 사용하는 것은 두 가지 이점이 있습니다. 첫째, 이러한 데이터는 풍부하게 사용 가능하여 AgentInstruct가 대량의 다양한 데이터를 생성할 수 있게 합니다. 둘째, 기존 프롬프트를 그대로 사용하거나 패러프레이징한 후 사용하는 것을 피하고 원시 데이터를 시드로 사용함으로써, 벤치마크 특화 능력이 아닌 더 일반적인 능력을 학습하도록 촉진할 수 있습니다.

본 연구에서는 AgentInstruct의 유용성을 입증하기 위해 2,500만 개의 프롬프트-응답 쌍으로 구성된 포괄적인 합성 사후 훈련 데이터셋을 생성했습니다. 이 데이터셋은 창의적 글쓰기, 추론, 수학, RAG, 도구 사용 등 광범위한 기술을 다룹니다. 데이터의 가치를 평가하기 위해 Mistral-7B 모델을 파인튜닝하는 데 사용했습니다. 파인튜닝된 Mistral 모델(Orca-3)은 동일한 기본 모델을 사용하는 다른 인스트럭션 튜닝 모델에 비해 상당한 개선을 보여줍니다.

예를 들어, Mistral-Instruct-7B와 비교했을 때 AGIEval에서 40% 개선, MMLU에서 19% 개선, GSM8K에서 54% 개선, BBH에서 38% 개선, AlpacaEval에서 45% 개선, 그리고 여러 요약 벤치마크에서 환각(hallucination)이 31.34% 감소했습니다. 또한 LLAMA-8B-instruct 및 GPT-3.5와 같은 다른 모델들을 여러 벤치마크에서 능가합니다. 사용된 유일한 시드 데이터는 공개적으로 사용 가능한 원시 자료이며, 작업별 또는 벤치마크 데이터는 시드로 사용되지 않았습니다.

본 연구에서는 일반적인 사후 훈련 합성 데이터셋을 생성하여 AgentInstruct의 유용성을 입증했지만, 에이전트가 합성 데이터 생성을 서비스로 제공할 수 있다고 믿습니다. 원시 자료(일반 모델 훈련을 위한 웹 데이터 또는 전문 모델을 위한 도메인 특화 데이터)로 시작하여 사후 훈련 및 파인튜닝을 위한 데이터를 생성함으로써, 모든 기본 LLM의 지속적인 학습과 개선을 가능하게 할 수 있습니다.

또한 AgentInstruct 접근법은 다음과 같은 이유로 더 크고 능력 있는 모델의 자기 개선(self-improvement)에 사용될 수 있다고 믿습니다. (1) 새로운 프롬프트를 생성할 수 있는 능력과 (2) 도구, 반성 등의 사용으로 인해 에이전틱 플로우에 사용된 LLM의 품질을 초과하는 응답을 생성할 수 있는 능력입니다.
## 생성적 교육: AgentInstruct

### AgentInstruct 방법론의 핵심 과제

지난 한 해 동안 지도 학습 파인튜닝과 인스트럭션 튜닝을 위한 합성 데이터셋 생성은 상당한 진전을 이루었습니다. 이러한 데이터셋의 품질은 꾸준히 향상되어 왔으며, 강력한 프론티어 모델이나 이러한 모델을 기반으로 한 에이전틱 플로우를 사용하여 응답을 생성함으로써 높은 품질을 달성할 수 있게 되었습니다. 그러나 합성 데이터를 생성할 때 품질 외에도 고려해야 할 몇 가지 근본적인 질문들이 있습니다.

첫 번째 질문은 어떻게 방대한 양의 데이터를 생성할 수 있는가입니다. 대규모 언어 모델의 효과적인 사후 훈련을 위해서는 수백만 개의 고품질 인스트럭션-응답 쌍이 필요하며, 이를 수동으로 생성하거나 큐레이션하는 것은 현실적으로 불가능합니다. 두 번째 질문은 생성된 데이터가 다양성을 갖추도록 어떻게 보장할 수 있는가입니다. 모델이 특정 패턴이나 스타일에 과적합되지 않고 일반화 능력을 갖추기 위해서는 다양한 형태와 난이도의 데이터가 필수적입니다. 세 번째 질문은 복잡하거나 미묘한 차이를 가진 데이터 포인트를 어떻게 생성할 수 있는가입니다. 단순한 질문-답변 쌍을 넘어서 모델의 추론 능력과 이해도를 실질적으로 향상시킬 수 있는 도전적인 데이터가 필요합니다.

AgentInstruct 방법론은 이러한 과제들을 해결하기 위한 구조화된 접근법을 제시합니다. 이 방법론의 핵심은 원시 시드 데이터(교과서 챕터, 웹 기사, 코드 스니펫 등)를 수집하고, 각 시드에 대해 일련의 에이전트 기반 변환 과정을 적용하는 것입니다. 구체적으로, 하나 이상의 콘텐츠 변환 에이전트를 활용하여 시드를 변환하고, 일련의 인스트럭션 생성 에이전트를 통해 다양한 인스트럭션 세트를 생성하며, 정제 에이전트 그룹을 활용하여 시드 인스트럭션의 복잡성과 품질을 반복적으로 개선합니다.

![AgentInstruct 방법론 개요](/assets/2025-10-19-agentinstruct--toward-generative-teaching-with-agentic-flows/2.png)

위 그림은 AgentInstruct 방법론의 간결한 요약을 보여줍니다. 이 방법론은 에이전틱 플로우를 사용하여 생성 과정을 자동화하고, 원시 기사를 시드로 활용하여 다양성을 촉진하며, 서로 다른 반복에서 생성된 문제들이 구별되고 광범위한 범위를 갖도록 보장합니다. 이를 통해 에이전틱 플로우의 자동화로부터 대규모 데이터 생성의 이점을, 광범위하고 다양한 시드로부터 높은 다양성의 이점을, 그리고 에이전틱 플로우가 지원하는 반복 및 정제 패턴으로부터 다양한 복잡도의 이점을 얻을 수 있습니다.

### 콘텐츠 변환 플로우의 역할과 구조

콘텐츠 변환 플로우(Content Transformation Flow)는 원시 시드를 특정 목표에 맞춤화된 인스트럭션 생성을 단순화하는 중간 표현으로 변환합니다. 이 플로우는 여러 에이전트로 구성되며, 고품질 데이터 생성에 중요한 역할을 하고 다양성을 도입하는 추가적인 수단으로 작용합니다. 예를 들어, 일반적인 텍스트 문서를 논증 구절, 대화, 회의록, 시 등 다양한 형태로 변환함으로써, 동일한 원시 콘텐츠로부터 서로 다른 특성과 구조를 가진 인스트럭션을 생성할 수 있는 기반을 마련합니다.

이러한 변환 과정은 단순히 형식을 바꾸는 것을 넘어서, 각 변환된 형태가 특정 유형의 인스트럭션 생성에 최적화되도록 설계되었습니다. 논증 구절로 변환된 콘텐츠는 논리적 추론과 비판적 분석을 요구하는 질문 생성에 적합하며, 대화 형태로 변환된 콘텐츠는 맥락 이해와 화용론적 추론을 평가하는 인스트럭션 생성에 유리합니다. 이처럼 콘텐츠 변환 플로우는 원시 데이터의 잠재력을 최대한 활용하여 다양한 학습 목표에 부합하는 데이터를 생성할 수 있는 토대를 제공합니다.

### 시드 인스트럭션 생성 플로우의 다양성 확보 전략

시드 인스트럭션 생성 플로우(Seed Instruction Generation Flow)는 여러 에이전트로 구성되며, 콘텐츠 변환 플로우로부터 변환된 시드를 입력으로 받아 다양한 인스트럭션 세트를 생성합니다. 이 플로우의 유일한 목표는 다양성을 도입하는 것이며, 이를 위해 사전 정의되었지만 확장 가능한 분류 체계(taxonomy)에 의존합니다. 분류 체계는 생성할 인스트럭션의 유형을 체계적으로 정의하여, 에이전트들이 특정 카테고리에 속하는 인스트럭션을 생성하도록 안내합니다.

이러한 접근법의 핵심은 분류 체계가 제공하는 구조적 가이드라인입니다. 예를 들어, 독해 능력을 위한 분류 체계는 문자적 이해, 비판적 분석, 논리적 추론 등 여러 카테고리로 구성될 수 있으며, 각 카테고리는 다시 세부 질문 유형으로 나뉩니다. 에이전트들은 이 분류 체계를 따라 각 카테고리에서 인스트럭션을 생성함으로써, 자연스럽게 다양한 형태와 난이도의 데이터를 생성하게 됩니다. 분류 체계의 확장 가능성은 새로운 기술이나 작업 유형이 추가될 때 유연하게 대응할 수 있게 해줍니다.

### 인스트럭션 정제 플로우의 복잡도 향상 메커니즘

인스트럭션 정제 플로우(Instruction Refinement Flow)는 시드 인스트럭션 플로우로부터 생성된 인스트럭션을 입력으로 받아 복잡성과 품질을 반복적으로 향상시킵니다. 이를 위해 제안자-편집자 에이전트(Suggester-Editor Agents) 개념을 사용합니다. 제안자 에이전트는 초기 인스트럭션의 복잡도를 높이기 위한 다양한 접근법을 제안하며, 이는 인스트럭션을 더 복잡하게 만들거나, 해결 불가능하게 만들거나, 까다롭게 만드는 방법을 포함합니다. 편집자 에이전트는 이러한 제안에 따라 인스트럭션을 실제로 수정합니다.

이 반복적 정제 과정은 단순한 인스트럭션을 점진적으로 발전시켜 모델의 능력을 실질적으로 시험할 수 있는 도전적인 문제로 변환합니다. 제안자 에이전트는 여러 차원에서 복잡도를 높일 수 있는 전략을 제시합니다. 예를 들어, 추가적인 제약 조건을 도입하거나, 다단계 추론을 요구하도록 만들거나, 미묘한 함정을 포함시키거나, 여러 개념을 통합하도록 요구할 수 있습니다. 편집자 에이전트는 이러한 제안을 구체적인 수정 사항으로 구현하면서도, 인스트럭션이 여전히 명확하고 해결 가능하며 원래의 학습 목표와 일치하도록 보장합니다.

![에이전트 역할의 주제별 개요](/assets/2025-10-19-agentinstruct--toward-generative-teaching-with-agentic-flows/3.png)

위 그림은 서로 다른 에이전트 그룹이 수행하는 역할의 주제별 개요를 제공합니다. 콘텐츠 변환 플로우는 시드를 고품질의 다양한 데이터를 생성하기 쉬운 중간 표현으로 변환합니다. 시드 인스트럭션 생성 플로우는 분류 체계를 따라 대상 작업의 인스턴스를 생성합니다. 정제 플로우는 이러한 초기 데이터 포인트로부터 시작하여 주변 영역을 탐색합니다. 무작위 시드를 선택함으로써 전체 데이터 포인트 영역을 커버할 수 있을 것으로 기대됩니다.

### 에이전트의 정의와 구성

각 플로우는 여러 에이전트로 구성됩니다. 본 연구에서는 에이전트를 일반적으로 정의하는데, 에이전트는 LLM에 의해 구동되며 선택적으로 검색 API, 코드 인터프리터, 계산기와 같은 도구를 사용할 수 있는 능력을 가집니다. 각 에이전트는 기본 LLM 시스템 메시지의 일부로 지정된 특정 역할과 인스트럭션 세트를 가지고 있습니다. 이러한 에이전트 정의는 유연성과 확장성을 제공하여, 다양한 작업과 기술에 맞게 에이전트를 구성하고 조정할 수 있게 합니다.

에이전트가 도구를 사용할 수 있다는 점은 특히 중요합니다. 검색 API를 통해 에이전트는 최신 정보나 특정 도메인 지식에 접근할 수 있으며, 코드 인터프리터를 통해 복잡한 계산이나 데이터 처리를 수행할 수 있고, 계산기를 통해 정확한 수치 연산을 보장할 수 있습니다. 이러한 도구 사용 능력은 에이전트가 생성하는 데이터의 품질과 정확성을 크게 향상시키며, 기본 LLM만으로는 달성하기 어려운 복잡한 작업을 수행할 수 있게 합니다.

### 구현된 기술 범위와 다양성

본 연구에서는 이러한 플로우들을 17개의 서로 다른 기술에 대해 구현했으며, 각 기술은 여러 하위 카테고리를 가지고 있습니다. 구현된 기술에는 독해, 질문 응답, 코딩, 검색 증강 생성(RAG), 창의적 글쓰기, 도구/API 사용, 웹 제어 등이 포함됩니다. 이러한 광범위한 기술 범위는 AgentInstruct가 범용 언어 모델의 다양한 능력을 향상시킬 수 있는 포괄적인 데이터셋을 생성할 수 있음을 보여줍니다.

각 기술은 고유한 특성과 요구사항을 가지고 있으며, 이에 따라 콘텐츠 변환, 인스트럭션 생성, 정제 플로우가 각 기술에 맞게 조정됩니다. 예를 들어, 코딩 기술을 위한 플로우는 소스 코드를 시드로 사용하고 프로그래밍 문제를 생성하는 데 특화된 에이전트를 사용하는 반면, 창의적 글쓰기를 위한 플로우는 다양한 문학적 스타일과 장르를 다루는 에이전트를 활용합니다. 이러한 기술별 맞춤화는 각 영역에서 고품질의 관련성 높은 데이터를 생성하는 데 필수적입니다.

### 독해 능력을 위한 AgentInstruct 구현

독해 능력은 서면 텍스트를 이해하고, 처리하고, 해석하는 능력을 의미합니다. 독해를 위한 AgentInstruct 플로우는 9개의 콘텐츠 변환 에이전트를 사용하여 원시 텍스트를 다양한 형태로 변환합니다. 논증 구절 생성기(Argument Passage Generator)는 일반 텍스트를 논리적 주장과 근거를 포함하는 논증 형태로 변환하며, 토론 구절 생성기(Debate Passage Generator)는 상반된 관점을 제시하는 토론 형식으로 변환합니다. 대화 구절 생성기(Conversation Passage Generator)는 대화체로 변환하고, 회의록 생성기(Meeting Transcript Generator)는 회의 기록 형식으로 변환합니다.

시 생성기(Poem Generator)는 시적 형태로 변환하고, 풍자 구절 생성기(Satirical Passage Generator)는 풍자적 스타일로 변환하며, 교육용 구절 생성기(Instructional Passage Generator)는 단계별 지침 형식으로 변환합니다. 긴 텍스트 생성기(Long Text Generator)는 원시 콘텐츠를 확장하여 더 긴 형태로 만들고, 정체성 에이전트(Identity Agent)는 원본 텍스트를 그대로 유지합니다. 이러한 다양한 변환은 동일한 원시 콘텐츠로부터 서로 다른 독해 과제를 생성할 수 있는 풍부한 기반을 제공합니다.

시드 인스트럭션 생성 플로우는 43개의 질문 유형을 포함하는 분류 체계를 사용합니다. 이 질문 유형들은 세 가지 주요 카테고리로 분류됩니다. 문자적 이해(Literal Comprehension) 카테고리는 텍스트에 명시적으로 제시된 정보를 직접 추출하는 질문을 포함하며, 주요 아이디어 식별, 세부 사항 회상, 순서 파악 등의 유형이 있습니다. 비판적 분석(Critical Analysis) 카테고리는 텍스트를 평가하고 판단하는 질문을 포함하며, 저자의 의도 분석, 편향 식별, 논증의 강점과 약점 평가 등이 포함됩니다.

논리적 추론(Logical Reasoning) 카테고리는 텍스트의 논리적 구조를 분석하는 질문을 포함합니다. 이 카테고리에는 논증 강화(strengthen) 질문과 논증 약화(weaken) 질문이 포함되는데, 이는 LSAT 독해 섹션에서 자주 사용되는 고난이도 질문 유형입니다. 논증 강화 질문은 주어진 논증을 더 설득력 있게 만드는 추가 정보나 가정을 식별하도록 요구하며, 논증 약화 질문은 논증의 타당성을 훼손하는 반례나 대안적 설명을 찾도록 요구합니다. 이러한 질문들은 깊은 논리적 사고와 추론 능력을 평가합니다.

정제 플로우에서는 제안자-편집자 에이전트 쌍이 초기 질문의 복잡도를 높입니다. 제안자 에이전트는 여러 텍스트 구절을 통합하도록 요구하거나, 암묵적 정보를 추론하도록 만들거나, 미묘한 언어적 단서를 파악하도록 요구하는 등의 방법을 제안합니다. 편집자 에이전트는 이러한 제안을 구현하여 원래의 간단한 질문을 다층적 추론을 요구하는 복잡한 질문으로 변환합니다. 예를 들어, "저자의 주요 주장은 무엇인가?"라는 단순한 질문은 "저자의 명시적 주장과 암묵적 가정을 구별하고, 이러한 가정이 논증의 타당성에 어떤 영향을 미치는지 분석하시오"와 같은 복잡한 질문으로 발전할 수 있습니다.

### 텍스트 수정을 위한 AgentInstruct 구현

텍스트 수정은 서로 다른 목적에 맞게 텍스트를 변경하는 과정을 의미합니다. 텍스트 수정을 위한 AgentInstruct 플로우는 18개의 작업 유형을 다루는 분류 체계를 사용합니다. 패러프레이징(Paraphrasing)은 의미를 유지하면서 표현을 바꾸는 작업이며, 텍스트 단순화(Text Simplification)는 복잡한 텍스트를 더 이해하기 쉽게 만드는 작업입니다. 확장(Expansion)은 텍스트에 추가 정보나 세부 사항을 더하는 작업이고, 번역(Translation)은 한 언어에서 다른 언어로 변환하는 작업입니다.

형식 변환(Formatting)은 텍스트의 구조나 레이아웃을 변경하는 작업이며, 감정 수정(Sentiment Modification)은 텍스트의 감정적 톤을 바꾸는 작업입니다. 주석 달기(Annotation)는 텍스트에 설명이나 메타데이터를 추가하는 작업이고, 키워드 교체(Keyword Replacement)는 특정 단어나 구를 다른 것으로 바꾸는 작업입니다. 제거(Removing)는 특정 요소를 삭제하는 작업이며, 대문자화(Capitalization)는 대소문자 규칙을 적용하는 작업입니다.

스타일링(Styling)은 특정 문체나 스타일을 적용하는 작업이고, 콘텐츠 재작성(Content Rewriting)은 내용을 완전히 다시 쓰는 작업입니다. 데이터 정규화(Data Normalization)는 일관된 형식으로 데이터를 표준화하는 작업이며, 표절 재작성(Plagiarism Rewording)은 표절을 피하기 위해 텍스트를 재구성하는 작업입니다. 코드 스위칭(Code Switching)은 여러 언어를 혼합하는 작업이고, 텍스트 난독화(Text Obfuscation)는 의도적으로 텍스트를 모호하게 만드는 작업입니다. 텍스트 함의(Textual Entailment)는 한 텍스트가 다른 텍스트를 논리적으로 함의하는지 판단하는 작업이며, 어휘 제한 재작성(Vocabulary-Limited Rewriting)은 제한된 어휘만을 사용하여 텍스트를 다시 쓰는 작업입니다.

콘텐츠 변환 플로우는 원시 텍스트를 이러한 다양한 수정 작업에 적합한 형태로 준비합니다. 시드 인스트럭션 생성 플로우는 각 작업 유형에 대해 구체적인 인스트럭션을 생성하며, 입력 텍스트, 수정 목표, 제약 조건 등을 명확히 지정합니다. 정제 플로우에서는 제안자 에이전트가 복잡도를 높이는 방법을 제안합니다. 예를 들어, 여러 수정 작업을 순차적으로 적용하도록 요구하거나, 상충하는 제약 조건을 동시에 만족시키도록 요구하거나, 특정 문체적 특성을 유지하면서 수정하도록 요구할 수 있습니다. 편집자 에이전트는 이러한 제안을 구현하여 단순한 수정 작업을 다차원적 변환 과제로 발전시킵니다.

### 도구 사용을 위한 AgentInstruct 구현

도구 사용은 작업을 수행하거나 문제를 해결하기 위해 함수나 API를 활용하는 능력을 의미합니다. 도구 사용을 위한 AgentInstruct 플로우는 소스 코드 스니펫이나 API 설명을 시드로 사용합니다. 콘텐츠 변환 플로우는 원시 코드나 API 문서를 구조화된 API 명세로 변환합니다. 이 명세에는 함수 이름, 매개변수, 반환 값, 사용 예시 등이 포함되며, 이는 인스트럭션 생성을 위한 명확한 기반을 제공합니다.

시드 인스트럭션 생성 플로우는 단일 API 사용과 다중 API 사용을 모두 다루는 작업을 생성합니다. 단일 API 사용 작업은 하나의 함수나 API를 호출하여 문제를 해결하도록 요구하며, 매개변수의 완전성에 따라 난이도가 달라집니다. 모든 매개변수가 명시적으로 제공되는 경우는 상대적으로 간단하지만, 일부 매개변수를 추론하거나 기본값을 사용해야 하는 경우는 더 복잡합니다. 다중 API 사용 작업은 여러 함수나 API를 조합하여 복잡한 작업을 수행하도록 요구하며, API 호출의 순서와 각 호출의 출력을 다음 호출의 입력으로 사용하는 방법을 결정해야 합니다.

정제 플로우는 초기 작업의 복잡도를 여러 방법으로 높입니다. 제안자 에이전트는 다중 턴 대화로 확장하거나, 오류 처리를 요구하거나, 최적화 제약 조건을 추가하거나, 불완전한 정보로부터 추론하도록 요구하는 등의 방법을 제안합니다. 예를 들어, 단순한 API 호출 작업은 사용자가 여러 번의 상호작용을 통해 점진적으로 정보를 제공하는 대화형 시나리오로 발전할 수 있습니다. 편집자 에이전트는 이러한 제안을 구현하여 실제 사용 사례를 반영하는 현실적이고 도전적인 도구 사용 작업을 생성합니다. 이러한 복잡한 작업은 모델이 단순히 API를 호출하는 것을 넘어서, 맥락을 이해하고, 적절한 도구를 선택하며, 여러 단계의 추론을 수행하는 능력을 개발하도록 돕습니다.
## 독해 능력을 위한 AgentInstruct 플로우

독해 능력은 텍스트를 처리하고 이해하는 핵심 기술로서, 학습에 필수적이며 해독, 유창성, 어휘 지식을 포괄합니다. 독해 테스트는 일반적으로 다양한 길이와 주제의 텍스트 구절을 제시한 후, 독자의 이해도를 평가하는 질문들을 제시합니다. 독해 질문은 명시적 정보를 묻는 문자적 이해부터 추론, 맥락 속 어휘 이해, 텍스트 구조와 논증 분석, 내용의 비판적 평가, 그리고 텍스트의 여러 부분이나 여러 텍스트로부터의 정보 종합에 이르기까지 다양한 범위를 다룹니다.

독해 능력을 위한 AgentInstruct 플로우는 세 가지 핵심 단계로 구성됩니다. 첫 번째는 콘텐츠 변환 플로우로, 원시 웹 크롤링 데이터를 다양한 독해 질문 생성에 적합한 형태로 변환합니다. 두 번째는 시드 인스트럭션 생성 플로우로, 변환된 텍스트로부터 43개의 질문 유형에 따라 체계적으로 질문을 생성합니다. 세 번째는 인스트럭션 정제 플로우로, 제안자-편집자 에이전트 쌍을 활용하여 초기 질문의 복잡도를 반복적으로 높입니다.

### 콘텐츠 변환 플로우의 전략적 설계

웹 크롤링 데이터는 인간이 생성한 텍스트의 방대한 컬렉션을 포함하고 있어 독해 자료 생성의 잠재력을 가지고 있습니다. 그러나 이러한 소스들은 본질적으로 독해 기술 교육을 촉진하도록 구조화되어 있지 않습니다. 따라서 포괄적인 독해 평가에 필요한 다양한 질문 유형의 일관된 생성을 지원하지 못합니다. 예를 들어, LSAT 논리적 추론 테스트는 가정(assumption), 강화/약화(strengthening/weakening), 결함(flaw), 추론(inference) 질문을 포함하는 특화된 질문 카테고리를 특징으로 합니다. 이러한 질문들을 만들기 위해서는 특정한 문체적 및 논리적 프레임워크를 가진 구절이 필요합니다.

콘텐츠 변환 플로우의 목표는 임의의 기사를 광범위한 독해 질문 유형의 공식화에 도움이 되는 잘 구성된 작품으로 변환하는 것입니다. 현재 독해를 위한 플로우는 논증 구절, 토론과 대화, 긴 구절, 회의록, 시, 풍자적 콘텐츠 등을 생성하기 위한 9개의 콘텐츠 변환 에이전트 모음을 포함합니다. 주어진 시드 기사에 대해, 플로우는 무작위로 콘텐츠 변환 에이전트 중 하나를 선택하여 시드 기사를 평가하고 텍스트 구절을 생성하려고 시도합니다.

논증 구절 생성기의 작동 방식을 구체적인 예시를 통해 살펴보겠습니다. 원시 시드는 요산에 관한 일반적인 정보를 담고 있습니다. 이 텍스트는 요산이 퓨린이라는 식이 단백질의 분해로 자연적으로 생성되는 물질이며, 체내에 과다할 때 결정이 형성되어 주로 관절과 신장에 침착되어 통증과 다른 악화를 유발한다고 설명합니다. 체내 요산의 부족이나 과다는 백혈병, 비만, 신장 질환, 빈혈과 같은 일부 질병과 알코올 및 가공식품 섭취와 같은 생활 방식 관련 요인에 의해 발생합니다.

논증 구절 생성기는 이 원시 시드를 논리적 구조를 가진 논증 형태로 변환합니다. 변환된 구절은 다음과 같습니다. "최근 연구들은 혈중 요산 수치가 높은 고요산혈증이 심혈관 질환의 위험을 증가시킬 수 있다고 지적했습니다. 요산은 퓨린 대사의 부산물이며, 체내에서 자연적으로 생성되지만 과도한 양은 건강 합병증을 초래할 수 있습니다. 고요산혈증은 일반적으로 여성의 경우 6 mg/dL 이상, 남성의 경우 7 mg/dL 이상의 수치로 정의됩니다. 이 상태는 요산의 증가된 생산이나 소변을 통한 불충분한 배출로 인해 발생할 수 있습니다. 높은 요산에 기여하는 요인으로는 붉은 고기와 해산물에서 발견되는 퓨린이 풍부한 식단, 그리고 알코올 섭취와 신체 활동 부족과 같은 생활 방식 선택이 포함됩니다. 반대로, 낮은 요산 수치 또는 저요산혈증은 덜 흔하며 일반적으로 증상을 나타내지 않습니다. 그럼에도 불구하고, 이는 기저 신장이나 간 문제를 나타낼 수 있습니다. 두 상태 중 하나를 진단하려면 실험실 혈액 및 소변 검사가 필요합니다. 높은 요산 수치가 심혈관 질환의 증가된 위험과 연관되어 있지만, 인과 관계는 아직 결정적으로 확립되지 않았다는 점을 주목하는 것이 중요합니다."

이 변환은 단순한 정보 제공 텍스트를 주장과 근거를 포함하는 논증 구조로 재구성합니다. 변환된 구절은 명확한 주장("고요산혈증이 심혈관 질환 위험을 증가시킬 수 있다")을 제시하고, 이를 뒷받침하는 증거들을 제공하며, 동시에 인과 관계가 아직 확립되지 않았다는 제한점도 인정합니다. 이러한 논증 구조는 LSAT 스타일의 논리적 추론 질문, 특히 논증 강화나 약화 질문을 생성하기에 이상적인 형태입니다.

### 시드 인스트럭션 생성 플로우의 체계적 접근

시드 인스트럭션 생성 플로우는 현재 43개의 독해 질문 유형 컬렉션을 컴파일했습니다. 이 목록에는 문자적 이해 질문, 비판적 이해 질문, 평가적 이해 질문, 추론, 가정 식별, 논증을 강화/약화시키는 정보 식별, 사건 순서 정하기 등이 포함됩니다. 이러한 카테고리들을 대상으로 하는 여러 에이전트를 정의했습니다. 각 에이전트는 텍스트 조각을 입력으로 받아 사전 정의된 질문 유형에 기반한 질문 목록을 생성합니다. 오케스트레이션 프로세스는 이전 단계의 콘텐츠 변환 에이전트에 의해 결정된 이러한 에이전트들의 하위 집합을 참여시킵니다. 이 단계가 완료되면, 다음 단계의 입력을 구성할 (구절, 질문) 쌍의 컬렉션을 얻게 됩니다.

논증 강화(strengthen) 유형 질문의 구체적인 예시를 살펴보겠습니다. 앞서 변환된 요산 관련 논증 구절로부터 다음과 같은 질문이 생성됩니다. "다음 중 사실이라면, 높은 요산 수치가 심혈관 질환의 위험을 증가시킨다는 논증을 가장 강화하는 것은 무엇입니까?" 선택지는 다음과 같습니다. (A) 고요산혈증을 가진 일부 개인은 심혈관 질환이 발생하지 않습니다. (B) 신체 활동은 혈중 요산 수치에 유의미한 영향을 미치지 않는 것으로 밝혀졌습니다. (C) 식이 보충제는 혈중 요산 수치를 감소시키는 것으로 나타났습니다. (D) 심혈관 질환을 가진 상당수의 환자들이 고요산혈증에 대해 정의된 임계값 이상의 요산 수치를 가진 것으로 밝혀졌습니다. (E) 심혈관 질환의 가족력이 있는 개인은 높은 요산 수치를 가질 가능성이 더 높습니다.

이 질문은 LSAT 논리적 추론 섹션의 전형적인 논증 강화 질문입니다. 정답은 (D)인데, 이는 심혈관 질환 환자들 중 상당수가 높은 요산 수치를 가지고 있다는 직접적인 상관관계 증거를 제공하여 논증을 강화하기 때문입니다. (A)는 논증을 약화시키는 반례를 제시하고, (B)는 관련성이 없으며, (C)는 치료 가능성을 시사하지만 인과 관계를 강화하지는 않고, (E)는 가족력이라는 혼란 변수를 도입하여 직접적인 인과 관계를 불명확하게 만듭니다.

### 인스트럭션 정제 플로우의 복잡도 증대 메커니즘

정제 플로우는 각 (구절, 질문) 쌍을 검토하고 다음 목표를 가진 더 많은 쌍을 생성하는 여러 제안자-편집자 에이전트를 포함합니다. (1) 질문을 답할 수 없도록 구절을 수정하기, (2) 가능하다면 반대 방향으로 답을 변경하도록 구절을 수정하기, 또는 (3) 질문이나 답 선택지를 더 복잡하게 만들기입니다.

제안자 에이전트가 시험 응시자를 혼란스럽게 하기 위해 어려운 방해 선택지를 추가하려고 시도하는 예시를 살펴보겠습니다. 제안자는 세 가지 제안을 제시합니다. 첫 번째 제안은 논증을 잠재적으로 강화할 수 있는 가상의 연구나 발견을 도입하여, 시험 응시자가 요산 수치와 심혈관 질환 간의 관계에 대한 그것의 영향을 추론하도록 요구하는 것입니다. 두 번째 제안은 고요산혈증에 대한 유전적 소인과 증가된 심혈관 사건과의 상관관계를 제안하여 복잡성의 층을 추가하는 것으로, 이는 시험 응시자가 유전적 및 생리학적 요인 모두를 고려하도록 요구합니다. 세 번째 제안은 논증을 강화하는 것처럼 보이지만 자세히 검토하면 요산 수치와 심혈관 질환 간의 인과 관계와 직접적으로 관련되지 않는 방해 선택지를 포함하여, 시험 응시자의 관련 정보와 무관한 정보를 구별하는 능력을 테스트하는 것입니다.

편집자 에이전트는 세 번째 제안을 구현하여 다음과 같이 질문을 수정합니다. "다음 중 사실이라면, 높은 요산 수치가 심혈관 질환의 위험을 증가시킨다는 논증을 가장 강화하는 것은 무엇입니까?" 수정된 선택지는 다음과 같습니다. (A) 고요산혈증을 가진 일부 개인은 심혈관 질환이 발생하지 않습니다. (B) 신체 활동은 혈중 요산 수치에 유의미한 영향을 미치지 않는 것으로 밝혀졌습니다. (C) 위약 대조 시험에서 요산 저하 약물을 복용하는 개인들이 위약 그룹에 비해 심혈관 질환의 발생률이 감소하지 않는 것으로 나타났습니다. (D) 심혈관 질환을 가진 상당수의 환자들이 고요산혈증에 대해 정의된 임계값 이상의 요산 수치를 가진 것으로 밝혀졌습니다. (E) 횡단면 연구에서 높은 요산 수치가 고혈압 및 당뇨병과 같은 심혈관 질환의 다른 위험 요인과 연관되어 있지만, 직접적인 인과 관계를 확립하지는 않는 것으로 밝혀졌습니다.

이 수정은 질문의 복잡도를 크게 증가시킵니다. 새로운 선택지 (C)는 교묘한 방해 선택지로, 요산 저하 약물이 심혈관 질환을 감소시키지 않는다는 것은 실제로 논증을 약화시키는 증거입니다. 선택지 (E)도 정교한 방해 선택지로, 상관관계는 있지만 인과관계가 확립되지 않았다고 명시적으로 언급하여, 논증을 강화하기보다는 오히려 인과관계의 불확실성을 강조합니다. 이러한 방해 선택지들은 시험 응시자가 단순히 관련성 있어 보이는 정보를 선택하는 것이 아니라, 논증의 핵심 주장을 실제로 강화하는 증거가 무엇인지 깊이 분석하도록 요구합니다.

이러한 세 단계의 플로우를 통해 AgentInstruct는 원시 웹 데이터로부터 시작하여 다양한 형태의 텍스트 구절을 생성하고, 체계적인 분류 체계에 따라 광범위한 질문 유형을 생성하며, 반복적인 정제를 통해 질문의 복잡도와 품질을 지속적으로 향상시킵니다. 이 과정은 완전히 자동화되어 있으면서도 고품질의 다양한 독해 평가 자료를 대량으로 생성할 수 있습니다.

## 텍스트 수정을 위한 AgentInstruct 플로우

텍스트 수정은 품질을 개선하거나, 톤을 수정하거나, 특정 맥락이나 청중에 맞추기 위해 기존 텍스트를 변경하는 과정을 의미합니다. 이는 콘텐츠 생성 및 편집에서 일반적인 작업입니다. 텍스트 수정을 위한 AgentInstruct 플로우는 18개의 작업 유형을 다루는 포괄적인 분류 체계를 사용합니다.

분류 체계에 포함된 작업 유형들은 다음과 같습니다. 패러프레이징(Paraphrasing)은 의미를 유지하면서 표현을 바꾸는 작업입니다. 텍스트 단순화(Text Simplification)는 복잡한 텍스트를 더 이해하기 쉽게 만드는 작업이며, 확장(Expansion)은 텍스트에 추가 정보나 세부 사항을 더하는 작업입니다. 번역(Translation)은 한 언어에서 다른 언어로 변환하는 작업이고, 형식 변환(Formatting)은 텍스트의 구조나 레이아웃을 변경하는 작업입니다.

감정 수정(Sentiment Modification)은 텍스트의 감정적 톤을 바꾸는 작업이며, 주석 달기(Annotation)는 텍스트에 설명이나 메타데이터를 추가하는 작업입니다. 키워드 교체(Keyword Replacement)는 특정 단어나 구를 다른 것으로 바꾸는 작업이고, 제거(Removing)는 특정 요소를 삭제하는 작업입니다. 대문자화(Capitalization)는 대소문자 규칙을 적용하는 작업이며, 스타일링(Styling)은 특정 문체나 스타일을 적용하는 작업입니다.

콘텐츠 재작성(Content Rewriting)은 내용을 완전히 다시 쓰는 작업이고, 데이터 정규화(Data Normalization)는 일관된 형식으로 데이터를 표준화하는 작업입니다. 표절 재작성(Plagiarism Rewording)은 표절을 피하기 위해 텍스트를 재구성하는 작업이며, 코드 스위칭(Code Switching)은 여러 언어를 혼합하는 작업입니다. 텍스트 난독화(Text Obfuscation)는 의도적으로 텍스트를 모호하게 만드는 작업이고, 텍스트 함의(Textual Entailment)는 한 텍스트가 다른 텍스트를 논리적으로 함의하는지 판단하는 작업입니다. 어휘 제한 재작성(Vocabulary-Limited Rewriting)은 제한된 어휘만을 사용하여 텍스트를 다시 쓰는 작업입니다.

콘텐츠 변환 플로우는 원시 텍스트를 이러한 다양한 수정 작업에 적합한 형태로 준비합니다. 시드 인스트럭션 생성 플로우는 각 작업 유형에 대해 구체적인 인스트럭션을 생성하며, 입력 텍스트, 수정 목표, 제약 조건 등을 명확히 지정합니다. 정제 플로우에서는 제안자-편집자 에이전트 쌍이 초기 인스트럭션의 복잡도를 높입니다.

제안자 에이전트는 여러 수정 작업을 순차적으로 적용하도록 요구하거나, 상충하는 제약 조건을 동시에 만족시키도록 요구하거나, 특정 문체적 특성을 유지하면서 수정하도록 요구하는 등의 방법을 제안합니다. 예를 들어, 단순한 패러프레이징 작업은 "학술적 톤을 유지하면서 텍스트를 단순화하되, 핵심 전문 용어는 보존하고, 전체 길이는 원문의 80% 이내로 유지하시오"와 같은 다차원적 제약 조건을 가진 복잡한 작업으로 발전할 수 있습니다. 편집자 에이전트는 이러한 제안을 구현하여 실제 콘텐츠 편집 시나리오를 반영하는 현실적이고 도전적인 텍스트 수정 작업을 생성합니다.

## 도구 사용을 위한 AgentInstruct 플로우

도구 사용은 작업을 수행하거나 문제를 해결하기 위해 함수나 API를 활용하는 능력을 의미합니다. 도구 사용을 위한 AgentInstruct 플로우는 소스 코드 스니펫이나 API 설명을 시드로 사용합니다. 콘텐츠 변환 플로우는 원시 코드나 API 문서를 구조화된 API 명세로 변환합니다. 이 명세에는 함수 이름, 매개변수, 반환 값, 사용 예시 등이 포함되며, 이는 인스트럭션 생성을 위한 명확한 기반을 제공합니다.

시드 인스트럭션 생성 플로우는 단일 API 사용과 다중 API 사용을 모두 다루는 작업을 생성합니다. 단일 API 사용 작업은 하나의 함수나 API를 호출하여 문제를 해결하도록 요구하며, 매개변수의 완전성에 따라 난이도가 달라집니다. 모든 매개변수가 명시적으로 제공되는 경우는 상대적으로 간단하지만, 일부 매개변수를 추론하거나 기본값을 사용해야 하는 경우는 더 복잡합니다. 다중 API 사용 작업은 여러 함수나 API를 조합하여 복잡한 작업을 수행하도록 요구하며, API 호출의 순서와 각 호출의 출력을 다음 호출의 입력으로 사용하는 방법을 결정해야 합니다.

정제 플로우는 초기 작업의 복잡도를 여러 방법으로 높입니다. 제안자 에이전트는 다중 턴 대화로 확장하거나, 오류 처리를 요구하거나, 최적화 제약 조건을 추가하거나, 불완전한 정보로부터 추론하도록 요구하는 등의 방법을 제안합니다. 예를 들어, 단순한 API 호출 작업은 사용자가 여러 번의 상호작용을 통해 점진적으로 정보를 제공하는 대화형 시나리오로 발전할 수 있습니다. 편집자 에이전트는 이러한 제안을 구현하여 실제 사용 사례를 반영하는 현실적이고 도전적인 도구 사용 작업을 생성합니다. 이러한 복잡한 작업은 모델이 단순히 API를 호출하는 것을 넘어서, 맥락을 이해하고, 적절한 도구를 선택하며, 여러 단계의 추론을 수행하는 능력을 개발하도록 돕습니다.
## 텍스트 수정을 위한 AgentInstruct 플로우

텍스트 수정은 서면 콘텐츠를 편집하고 정제하여 품질과 효과성을 향상시키거나 속성을 변경하는 과정입니다. 이는 맞춤법과 문법 교정, 아이디어 명확화, 더 나은 흐름을 위한 콘텐츠 재구성, 톤 조정, 스타일 일관성 보장, 사실 확인, 중복 제거, 형식 지정, 콘텐츠 개발, 그리고 특정 청중에 맞춘 적응을 포함합니다. 이는 콘텐츠 작성을 돕는 대규모 언어 모델에게 유용한 기술입니다. 여러 콘텐츠 변환 에이전트를 도입하여 의도적으로 텍스트를 수정할 수 있지만, 여기서는 인스트럭션이 어떻게 생성되고 정제되는지를 보여주는 데 초점을 맞춥니다.

### 시드 인스트럭션 생성 플로우의 구조와 작동

현재 패러프레이징, 확장, 단순화, 콘텐츠 삭제 또는 제거, 스타일링, 코드 스위칭 등을 포함한 18가지 유형의 텍스트 수정 작업 컬렉션이 컴파일되어 있습니다. 전체 목록은 부록 A에 제시되어 있습니다. 각 작업 유형에 대해 에이전트가 정의되어 있으며, 각 에이전트는 텍스트 조각을 입력으로 받아 해당 유형의 여러 텍스트 수정 작업을 생성합니다.

구체적인 예시로 패러프레이징 에이전트의 작동 방식을 살펴보겠습니다. 무작위 시드는 2017년 4월 6-8일 아이오와 대학교에서 개최되는 학술 행사에 관한 정보를 담고 있습니다. 이 텍스트는 행사 날짜, 장소, 초록 마감일(2016년 12월 1일)과 함께 금융화(financialization)에 관한 학술적 논의를 포함하고 있습니다. 금융화는 최근 몇 년간 금융 담론, 시장, 행위자, 제도의 증가하는 사회적 영향과 상호연결을 설명하는 광범위한 개념으로 이해되어 왔습니다. Natascha van der Zwan은 금융화를 접근하는 세 가지 구별되는 연구 흐름을 식별했는데, 이는 (1) 축적 체제로서의 금융화, (2) 비금융 기업과 은행 및 금융 산업에 대한 금융 시장과 도구의 영향, (3) 사람들을 투자 주체로 변화시키는 위험 감수, 자기 관리, 자기 실현의 담론입니다.

패러프레이징 에이전트는 이 원시 시드로부터 다음과 같은 작업을 생성합니다. "행사 세부 정보(날짜, 장소, 초록 마감일)를 더 캐주얼한 톤으로 다시 작성하시오." 이 작업은 원본 텍스트의 형식적이고 학술적인 톤을 유지하면서도, 특정 요소들을 더 친근하고 접근하기 쉬운 방식으로 변환하도록 요구합니다.

시드 인스트럭션 생성 플로우는 무작위 시드가 주어지면 18개 에이전트 중 하나를 무작위로 선택하고, 이를 사용하여 시드 (텍스트, 텍스트 수정 인스트럭션) 쌍을 얻습니다. 이러한 무작위 선택 메커니즘은 생성되는 데이터의 다양성을 자연스럽게 보장하며, 특정 작업 유형에 편향되지 않도록 합니다.

```python
class TextModificationFlow:
    def __init__(self, agents):
        # 18개의 텍스트 수정 에이전트 초기화
        self.agents = agents  # [ParaphrasingAgent, SimplificationAgent, ...]
        
    def generate_seed_instruction(self, random_seed_text):
        # 무작위로 에이전트 선택
        selected_agent = random.choice(self.agents)
        
        # 선택된 에이전트로 작업 생성
        task = selected_agent.create_task(random_seed_text)
        
        return {
            'input_text': random_seed_text,
            'instruction': task,
            'agent_type': selected_agent.task_type
        }

class ParaphrasingAgent:
    def __init__(self):
        self.task_type = 'paraphrasing'
        
    def create_task(self, text):
        # 텍스트 분석 및 패러프레이징 작업 생성
        key_elements = self.extract_key_elements(text)
        return f"Rewrite the {key_elements} in a more casual tone."
```

### 인스트럭션 정제 플로우의 복잡도 증대 메커니즘

정제 플로우는 단 하나의 제안자-편집자(Suggester-Editor) 쌍으로 구성됩니다. 제안자-편집자 듀오는 텍스트와 작업 수정 인스트럭션을 입력으로 받아 생성된 인스트럭션의 복잡성을 증가시킵니다. 제안자 에이전트는 초기 인스트럭션을 더 도전적이고 복잡하게 만들기 위한 여러 방법을 제안하며, 편집자 에이전트는 이러한 제안을 구체적인 수정된 인스트럭션으로 구현합니다.

앞서 생성된 패러프레이징 작업에 대해 제안자 에이전트는 세 가지 제안을 제시합니다. 첫 번째 제안은 "가상의 내러티브를 통합하시오. 구어체 언어를 사용한 대화 스타일을 사용하고 유머러스한 요소를 포함하시오"입니다. 이는 단순한 톤 변경을 넘어서 창의적인 스토리텔링 요소를 추가하도록 요구합니다. 두 번째 제안은 "행사 세부 정보를 시적 형식으로 번역하시오. 각운이 맞는 이행련(rhyming couplets)을 사용하면서 정확한 정보를 유지하고 톤은 가볍고 매력적으로 유지하시오"입니다. 이는 정보의 정확성을 유지하면서도 완전히 다른 문학적 형식으로 변환하는 고난이도 작업을 요구합니다. 세 번째 제안은 "행사 세부 정보를 소셜 미디어 게시물로 구성하시오. 인터넷 슬랭과 이모지를 사용하시오. 메시지를 280자 이내로 유지하시오"입니다. 이는 형식적 제약과 현대적 커뮤니케이션 스타일을 동시에 요구합니다.

편집자 에이전트는 이러한 제안들을 받아 구체적인 수정된 인스트럭션으로 변환합니다. 첫 번째 수정된 인스트럭션은 "행사 세부 정보(날짜, 장소, 초록 마감일)를 친구에게 재미있는 이야기를 하듯이 캐주얼하고 구어체 언어를 사용하여 다시 작성하되, 필요한 정보를 여전히 전달하는 가상의 내러티브를 통합하시오"가 됩니다. 두 번째 수정된 인스트럭션은 "행사 세부 정보(날짜, 장소, 초록 마감일)를 각운이 맞는 이행련을 사용한 경쾌한 시로 변환하되, 필수 정보가 시적 형식으로 정확하게 전달되도록 하시오"입니다. 세 번째 수정된 인스트럭션은 "인터넷 슬랭, 이모지, 캐주얼한 톤을 사용하여 행사 세부 정보(날짜, 장소, 초록 마감일)를 포함하는 소셜 미디어 게시물을 작성하되, 메시지를 간결하게 280자 이내로 유지하시오"입니다.

```python
class SuggesterEditorPair:
    def __init__(self, suggester, editor):
        self.suggester = suggester
        self.editor = editor
        
    def refine_instruction(self, text, initial_instruction):
        # 제안자가 복잡도를 높이는 방법 제안
        suggestions = self.suggester.generate_suggestions(
            text, 
            initial_instruction
        )
        
        # 편집자가 제안을 구현하여 수정된 인스트럭션 생성
        modified_instructions = []
        for suggestion in suggestions:
            modified = self.editor.apply_suggestion(
                text,
                initial_instruction,
                suggestion
            )
            modified_instructions.append(modified)
            
        return modified_instructions

class ComplexitySuggester:
    def generate_suggestions(self, text, instruction):
        suggestions = []
        
        # 창의적 요소 추가 제안
        suggestions.append({
            'type': 'creative_narrative',
            'description': 'Incorporate a fictional narrative with humor'
        })
        
        # 형식 변환 제안
        suggestions.append({
            'type': 'format_transformation',
            'description': 'Transform into poetic format with rhyming'
        })
        
        # 제약 조건 추가 제안
        suggestions.append({
            'type': 'constraint_addition',
            'description': 'Add length constraint and style requirements'
        })
        
        return suggestions
```

이러한 정제 과정은 단순한 텍스트 수정 작업을 다차원적 제약 조건을 가진 복잡한 창작 과제로 변환합니다. 각 수정된 인스트럭션은 원래의 정보 전달 목표를 유지하면서도, 창의성, 형식적 제약, 스타일적 요구사항 등 여러 차원의 복잡성을 추가합니다. 이는 모델이 단순히 텍스트를 변환하는 것을 넘어서, 여러 제약 조건을 동시에 만족시키면서도 원본의 핵심 정보를 보존하는 고급 능력을 개발하도록 돕습니다.

제안자-편집자 메커니즘의 핵심은 체계적인 복잡도 증대에 있습니다. 제안자는 초기 작업을 분석하여 어떤 차원에서 복잡도를 높일 수 있는지 식별하고, 편집자는 이러한 제안을 실행 가능한 구체적 인스트럭션으로 변환합니다. 이 과정에서 원본 작업의 핵심 목표는 유지되면서도, 추가적인 창의성, 정확성, 형식적 제약이 도입되어 모델의 다면적 능력을 시험하는 도전적인 작업이 생성됩니다.
도구 사용을 위한 AgentInstruct 플로우는 대규모 언어 모델이 외부 도구나 서비스와 상호작용할 수 있는 능력을 개발하도록 설계되었습니다. 이 능력은 AI 시스템이 기능을 확장하고, 외부 데이터에 접근하며, 본래의 능력을 넘어서는 작업을 수행할 수 있게 합니다. 도구 사용 플로우는 소스 코드 스니펫이나 API 설명을 무작위 시드로 사용하며, 세 가지 핵심 단계를 통해 다양한 복잡도의 도구 사용 작업을 생성합니다.

### 콘텐츠 변환 플로우를 통한 API 명세 생성

콘텐츠 변환 플로우는 원시 시드로부터 API 목록을 합성하는 것을 목표로 합니다. 소스 코드 스니펫이 시드로 사용된 경우, 콘텐츠 변환 에이전트가 코드 스니펫으로부터 API 설명을 합성합니다. API 목록은 두 가지 방법으로 생성됩니다. 첫 번째 방법은 API 검색 에이전트를 사용하여 유사한 코드를 반복적으로 검색함으로써 API 목록을 확장하는 것입니다. 두 번째 방법은 에이전트가 LLM을 활용하여 라이브러리에 존재할 가능성이 높은 다른 API들을 가설화하는 것입니다.

논문에서는 라이브러리 재구성 시나리오의 예시를 제공합니다. 이 예시에서 생성된 API 목록은 시드 인스트럭션 생성 플로우의 입력으로 사용되며, 다양한 유형의 도구 사용 작업을 생성하는 기반이 됩니다. 이러한 변환 과정은 원시 코드나 API 문서를 구조화된 형태로 변환하여, 후속 단계에서 체계적인 작업 생성을 가능하게 합니다.

### 시드 인스트럭션 생성 플로우의 작업 유형 분류

시드 인스트럭션 생성 플로우는 API 목록을 입력으로 받아 다양한 에이전트를 활용하여 여러 유형의 작업을 생성합니다. 작업은 크게 네 가지 주요 카테고리로 분류됩니다.

첫 번째 카테고리는 단일 API 사용 작업입니다. 이 카테고리는 세 가지 하위 유형으로 나뉩니다. (a) 입력이 모든 필수 매개변수를 제공하는 작업, (b) 입력이 불필요한 매개변수를 포함하는 작업, (c) 입력이 일부 필수 매개변수를 누락한 작업입니다. 이러한 다양한 매개변수 완전성 수준은 모델이 불완전하거나 과도한 정보를 처리하는 능력을 개발하도록 돕습니다.

두 번째 카테고리는 다중 API 사용 작업입니다. 이 카테고리는 두 가지 하위 유형으로 구성됩니다. (a) 입력이 모든 필수 매개변수를 제공하는 작업, (b) 입력이 일부 필수 매개변수를 누락한 작업입니다. 다중 API 작업은 모델이 여러 도구를 조합하여 복잡한 문제를 해결하는 능력을 요구하며, API 호출의 순서와 각 호출의 출력을 다음 호출의 입력으로 사용하는 방법을 결정해야 합니다.

세 번째 카테고리는 제공된 API 목록에 없는 단일 API를 필요로 하는 작업입니다. 이러한 작업은 모델이 사용 가능한 도구의 한계를 인식하고 적절하게 대응하는 능력을 평가합니다. 네 번째 카테고리는 다중 API를 필요로 하지만 제공된 목록에 일부 필수 API가 없는 작업입니다. 이는 모델이 불완전한 도구 세트로 작업할 때의 문제 해결 능력을 시험합니다.

### 정제 플로우를 통한 복잡도 증대와 다중 턴 대화 생성

정제 플로우의 목표는 작업의 복잡성을 증가시키는 것입니다. 예를 들어, 작업과 대화를 검토하여 문제를 해결하는 데 필요한 단계 수를 증가시키는 정제를 제안합니다. 논문에서는 AgentInstruct 플로우에 의해 생성된 다중 턴 대화의 구체적인 예시를 제공합니다.

이 예시는 식단 계획 시나리오를 다루며, 시스템 메시지와 사용자 요청으로 구성됩니다. 시스템 메시지는 AI 어시스턴트의 역할과 작동 방식을 정의합니다. AI 어시스턴트는 사용자가 원하는 결과를 달성하도록 돕는 역할을 하며, 다양한 API를 활용할 수 있는 능력을 가지고 있습니다. 각 단계에서 마크다운 출력을 생성해야 하며, 두 가지 선택지 중 하나를 선택할 수 있습니다.

첫 번째 선택지는 API 호출을 시작하는 것입니다. API를 호출하기로 선택한 경우, API의 이름과 호출에 필요한 매개변수를 포함하는 마크다운을 생성해야 합니다. 응답을 생성한 후에는 시스템이 제공된 매개변수로 API를 실행하고 결과를 반환할 때까지 기다려야 합니다. 마크다운 출력은 다음과 같은 구조를 따릅니다.

```
ACTION_TYPE : API_CALL
ACTION: name(parameter_name=value, another_parameter_name=value, ....)
```

두 번째 선택지는 프로세스를 종료하는 것입니다. 프로세스를 종료하기로 결정하는 경우는 여러 가지가 있습니다. (a) 답을 성공적으로 얻은 경우, (b) 적절한 API가 사용 가능하지 않다고 판단한 경우, (c) 사용자가 일부 필수 매개변수에 대한 값을 제공하지 않았음을 발견한 경우입니다. 답을 성공적으로 얻은 경우에는 FINAL_ANSWER를 액션 이름으로 사용하고 최종 답변을 유일한 매개변수로 제공합니다. 다른 이유로 중단하기로 결정한 경우에는 FAILED를 액션으로 사용하고 중단 이유를 설명하는 매개변수를 제공합니다. 전체적으로 다음과 같은 구조를 따릅니다.

```
ACTION_TYPE : STOP
ACTION: [ACTION_NAME]([VALUE])
```

시스템 메시지는 또한 접근 가능한 API 목록을 제공합니다. 이 목록에는 라이브러리 구성 예시에서 생성된 시드 API와 생성된 API들이 모두 포함됩니다.

사용자 요청은 복잡한 다중 단계 작업을 제시합니다. 사용자는 다음 주 동안 새로운 식단 계획을 시작하고자 하며, 하루에 약 1500칼로리를 섭취하는 것을 목표로 하고 채식 식사를 선호합니다. 하루에 세 끼를 먹을 예정이며, 식단 계획을 생성해 달라고 요청합니다. 또한 매일 먹는 음식을 추적하고 새로운 음식 추천을 받고 싶어 합니다. 주말에는 영양 요약을 보고 싶어 합니다. 추가로 퀴노아 샐러드에 대한 훌륭한 레시피를 발견했으며 이를 데이터베이스에 추가하고 싶어 합니다. 또한 'Chana Masala'의 칼로리 수치가 잘못된 것 같으며 더 낮아야 한다고 지적합니다. 그리고 'Butter Chicken'을 목록에서 제거해 달라고 요청하는데, 더 이상 먹지 않기 때문입니다.

이 예시는 정제 플로우가 어떻게 단순한 단일 API 호출 작업을 복잡한 다중 턴 대화로 발전시키는지 보여줍니다. 사용자 요청은 여러 개의 서로 다른 API 호출을 필요로 하며(식단 계획 생성, 음식 추적, 추천 받기, 영양 요약 보기, 레시피 추가, 칼로리 정보 수정, 항목 삭제), 각 작업은 특정 매개변수와 순서를 요구합니다. 이러한 복잡한 시나리오는 모델이 사용자의 다면적 요구사항을 이해하고, 적절한 API를 선택하며, 올바른 순서로 작업을 수행하는 능력을 개발하도록 돕습니다.

도구 사용을 위한 AgentInstruct 플로우는 이러한 세 단계를 통해 원시 코드나 API 설명으로부터 시작하여 다양한 복잡도와 현실성을 가진 도구 사용 작업을 대량으로 생성할 수 있습니다. 이는 모델이 단순히 API를 호출하는 것을 넘어서, 맥락을 이해하고, 적절한 도구를 선택하며, 여러 단계의 추론을 수행하고, 불완전한 정보를 처리하는 포괄적인 도구 사용 능력을 개발하도록 지원합니다.
## Orca-3

Orca-3는 AgentInstruct 프레임워크를 통해 생성된 대규모 합성 데이터셋으로 사후 훈련된 모델입니다. 이 섹션에서는 Orca-3 모델의 훈련에 사용된 데이터셋의 구성과 구체적인 훈련 세부사항을 다룹니다.

### 데이터셋 구성과 생성 전략

Orca-3의 훈련을 위해 17개의 서로 다른 능력에 대한 AgentInstruct 플로우가 구현되었습니다. 이러한 플로우를 통해 약 2,200만 개의 인스트럭션이 생성되었으며, 이는 앞서 설명한 독해, 텍스트 수정, 도구 사용을 포함한 다양한 기술을 가르치기 위해 설계되었습니다. 데이터 생성의 시드로는 비구조화된 텍스트와 코드 파일이 사용되었는데, 구체적으로 [KnowledgePile](https://arxiv.org/pdf/2401.14624), [AutoMathText](https://arxiv.org/pdf/2402.07625), OpenStax의 일부 자료, 그리고 Apache-2.0 라이선스를 가진 소스 코드 파일의 일부가 활용되었습니다.

비구조화된 콘텐츠를 인스트럭션 데이터 생성의 시드로 사용하는 접근법은 여러 가지 중요한 이점을 제공합니다. 첫째, 이러한 데이터는 풍부하게 사용 가능하여 대규모의 다양한 인스트럭션 데이터를 생성할 수 있게 합니다. 웹에서 크롤링된 텍스트, 교과서, 학술 논문, 오픈소스 코드 등은 방대한 양으로 존재하며, 이들은 서로 다른 주제, 난이도, 스타일을 포괄합니다. 이러한 다양성은 모델이 광범위한 상황과 작업에 대응할 수 있는 능력을 개발하는 데 필수적입니다.

둘째, 벤치마크 특화 데이터를 시드로 사용하지 않음으로써 특정 벤치마크에 대한 최적화가 아닌 일반적인 능력 향상에 집중할 수 있습니다. 기존의 많은 접근법들은 특정 벤치마크의 문제 형식이나 데이터를 직접 사용하거나 이를 변형하여 훈련 데이터를 생성했습니다. 이러한 방식은 해당 벤치마크에서는 높은 성능을 보일 수 있지만, 실제 세계의 다양한 상황에 대한 일반화 능력은 제한적일 수 있습니다. 반면 원시 데이터로부터 시작하는 AgentInstruct 접근법은 모델이 근본적인 능력을 학습하도록 유도하며, 이는 다양한 평가 시나리오에서 더 강건한 성능으로 이어집니다.

KnowledgePile은 다양한 지식 도메인을 포괄하는 대규모 텍스트 컬렉션으로, STEM 분야, 인문학, 사회과학 등의 고품질 교육 자료를 포함합니다. 이 데이터셋은 자동화된 데이터 수집 파이프라인을 통해 Common Crawl 코퍼스로부터 추출되었으며, 교육적 가치가 높은 콘텐츠를 선별하기 위한 필터링 과정을 거쳤습니다. AutoMathText는 수학적 지능과 교육적 가치를 가진 텍스트를 자동으로 선별하기 위해 제로샷 생성 분류기를 활용한 데이터셋입니다. 이 데이터셋은 수학 관련 웹 페이지, arXiv 논문, 수학 교육 자료 등 1,126만 개 이상의 문서를 처리하여 생성되었으며, 수학적 추론 능력 향상에 특화되어 있습니다.

### 기존 데이터셋과의 통합

AgentInstruct를 통해 생성된 2,200만 개의 인스트럭션 외에도, 약 380만 개의 쌍으로 이루어진 인스트럭션이 추가로 통합되었습니다. 이러한 추가 데이터는 [Orca-1](https://arxiv.org/pdf/2306.02707), [Orca-2](https://arxiv.org/pdf/2311.11045), [Orca-Math](https://arxiv.org/pdf/2402.14830)와 같은 이전 Orca 시리즈 모델의 데이터셋과 다른 공개적으로 사용 가능한 소스들로부터 수집되었습니다. 이 380만 개의 인스트럭션 세트는 Orca-2.5-dataset으로 명명되었습니다.

Orca-1은 GPT-4의 복잡한 설명 추적으로부터 점진적 학습을 수행하는 접근법을 제시했으며, 이를 통해 생성된 데이터는 단계별 추론과 상세한 설명을 포함합니다. Orca-2는 소규모 언어 모델에게 다양한 추론 전략을 가르치는 데 초점을 맞췄으며, 특히 "Prompt Erasing" 기법을 통해 모델이 표면적인 패턴 모방이 아닌 근본적인 추론 능력을 학습하도록 유도했습니다. Orca-Math는 초등학교 수준의 수학 문제 해결에 특화된 데이터셋으로, 에이전트 기반 합성 데이터 생성과 반복적 학습 절차를 결합하여 높은 수학적 추론 능력을 달성했습니다.

이러한 기존 데이터셋들과 AgentInstruct로 생성된 새로운 데이터를 결합함으로써, 총 약 2,580만 개의 쌍으로 이루어진 인스트럭션이 Orca-3의 훈련에 사용되었습니다. 이 통합 접근법은 이전 연구들의 강점을 활용하면서도 AgentInstruct의 대규모 다양성과 자동화의 이점을 더하는 전략입니다.

### 비교 평가를 위한 Orca-2.5 모델

AgentInstruct를 통해 생성된 2,200만 개의 인스트럭션이 모델 성능에 미치는 영향을 평가하기 위해, 380만 개의 Orca-2.5-dataset만을 사용하여 별도의 모델인 Orca-2.5가 훈련되었습니다. 이 비교 모델은 AgentInstruct의 기여도를 정량적으로 측정할 수 있는 기준선을 제공합니다. Orca-2.5와 Orca-3의 성능 차이를 분석함으로써, AgentInstruct 프레임워크가 생성한 대규모 합성 데이터가 실제로 모델의 능력을 얼마나 향상시키는지 명확히 파악할 수 있습니다.

### 훈련 구성과 하이퍼파라미터

Orca-3 모델은 Mistral-7b-v0.1을 기본 모델로 사용하여 파인튜닝되었습니다. Mistral-7b-v0.1이 선택된 이유는 이 모델이 인스트럭션 튜닝이 적용되지 않은 기본 버전의 가중치를 공개적으로 제공하며, 재배포를 허용하는 관대한 라이선스를 가지고 있기 때문입니다. 인스트럭션 튜닝이 적용되지 않은 기본 모델을 사용하는 것은 AgentInstruct 데이터의 순수한 효과를 측정하는 데 중요합니다. 이미 인스트럭션 튜닝된 모델을 사용할 경우, 기존 튜닝의 영향과 새로운 데이터의 영향을 분리하기 어렵기 때문입니다.

훈련 과정에서 각 인스트럭션-응답 쌍은 Mistral 토크나이저를 사용하여 토큰화되었습니다. 최대 시퀀스 길이는 8192 토큰으로 설정되었으며, 패킹(packing) 기법이 적용되었습니다. 패킹은 여러 개의 짧은 시퀀스를 하나의 긴 시퀀스로 결합하여 GPU 메모리를 효율적으로 활용하는 기법입니다. 예를 들어, 2000 토큰, 3000 토큰, 2500 토큰의 세 개 시퀀스가 있다면, 이들을 하나의 8192 토큰 시퀀스로 패킹하여 처리할 수 있습니다. 이는 짧은 시퀀스들을 개별적으로 처리할 때 발생하는 패딩(padding)으로 인한 계산 낭비를 줄여줍니다.

훈련 손실은 프롬프트가 아닌 응답 부분에 대해서만 계산되도록 레이블 마스킹(label masking)이 적용되었습니다. 이는 모델이 주어진 프롬프트에 조건화된 적절한 응답을 생성하는 능력에 집중하도록 합니다. 구체적으로, 각 시퀀스에서 프롬프트에 해당하는 토큰들의 손실은 무시되고, 모델이 생성해야 하는 응답 토큰들에 대해서만 손실이 계산됩니다. 이러한 접근법은 인스트럭션 튜닝에서 표준적으로 사용되는 기법으로, 모델이 프롬프트를 단순히 복사하는 것이 아니라 의미 있는 응답을 생성하도록 유도합니다.

```python
def compute_loss_with_label_masking(model_output, input_ids, labels, prompt_length):
    """
    프롬프트 부분을 마스킹하여 응답 부분에 대해서만 손실 계산
    
    Args:
        model_output: 모델의 출력 로짓
        input_ids: 입력 토큰 ID
        labels: 정답 레이블
        prompt_length: 프롬프트의 길이
    """
    # 프롬프트 부분의 레이블을 -100으로 설정 (손실 계산에서 무시됨)
    masked_labels = labels.clone()
    masked_labels[:, :prompt_length] = -100
    
    # 크로스 엔트로피 손실 계산 (ignore_index=-100)
    loss_fct = torch.nn.CrossEntropyLoss(ignore_index=-100)
    
    # 응답 부분에 대해서만 손실 계산
    shift_logits = model_output[..., :-1, :].contiguous()
    shift_labels = masked_labels[..., 1:].contiguous()
    
    loss = loss_fct(
        shift_logits.view(-1, shift_logits.size(-1)),
        shift_labels.view(-1)
    )
    
    return loss
```

가중치 감쇠(weight decay)는 0.1로 설정되었습니다. 가중치 감쇠는 정규화 기법의 일종으로, 모델의 가중치가 과도하게 커지는 것을 방지하여 과적합을 완화합니다. 수학적으로 가중치 감쇠는 손실 함수에 $\lambda \sum_{i} w_i^2$ 항을 추가하는 것과 동일하며, 여기서 $\lambda$는 가중치 감쇠 계수(이 경우 0.1), $w_i$는 모델의 각 가중치입니다. 이는 모델이 더 작고 일반화 가능한 가중치 값을 학습하도록 유도합니다.

### 분산 훈련 인프라와 최적화 전략

훈련은 19개의 NVIDIA A100 노드를 사용하여 수행되었으며, 이는 총 152개의 NVIDIA A100 GPU에 해당합니다. 각 GPU는 배치 크기 10으로 설정되어, 전체 글로벌 배치 크기는 1,520개의 샘플이 됩니다. 이러한 대규모 분산 훈련 설정은 2,580만 개의 방대한 데이터셋을 효율적으로 처리하기 위해 필수적입니다.

옵티마이저로는 AdamW가 사용되었습니다. AdamW는 Adam 옵티마이저의 변형으로, 가중치 감쇠를 더 효과적으로 적용하는 방식을 채택합니다. 전통적인 Adam에서는 가중치 감쇠가 그래디언트에 추가되는 반면, AdamW는 가중치 업데이트 단계에서 직접 적용됩니다. 이는 학습률과 가중치 감쇠를 독립적으로 조정할 수 있게 하여 더 나은 일반화 성능을 제공합니다.

초기 학습률은 $8 \times 10^{-6}$으로 설정되었습니다. 이는 상대적으로 작은 학습률로, 사전 훈련된 모델을 파인튜닝할 때 일반적으로 사용되는 범위입니다. 너무 큰 학습률은 사전 훈련된 가중치를 손상시킬 수 있으며, 너무 작은 학습률은 훈련 속도를 지나치게 느리게 만듭니다. $8 \times 10^{-6}$은 이러한 균형을 맞추는 값입니다.

학습률 스케줄로는 코사인 학습률 스케줄(cosine learning rate schedule)이 사용되었습니다. 코사인 스케줄은 학습률을 코사인 함수의 형태로 점진적으로 감소시키는 방법입니다. 수학적으로 시간 $t$에서의 학습률 $\eta_t$는 다음과 같이 계산됩니다.

$$\eta_t = \eta_{min} + \frac{1}{2}(\eta_{max} - \eta_{min})\left(1 + \cos\left(\frac{t}{T}\pi\right)\right)$$

여기서 $\eta_{max}$는 초기 학습률($8 \times 10^{-6}$), $\eta_{min}$은 최소 학습률(일반적으로 0 또는 매우 작은 값), $T$는 총 훈련 스텝 수입니다. 코사인 스케줄은 초기에는 학습률을 천천히 감소시키다가 후반부에 더 빠르게 감소시키는 특성을 가지며, 이는 모델이 초기에는 빠르게 학습하고 후반부에는 세밀한 조정을 할 수 있게 합니다.

추가로 초기 500 스텝 동안 선형 학습률 워밍업(linear learning rate warm-up)이 적용되었습니다. 워밍업은 훈련 초기에 학습률을 0에서 목표 학습률까지 점진적으로 증가시키는 기법입니다. 이는 훈련 초기의 불안정성을 방지하고, 모델이 급격한 가중치 변화 없이 안정적으로 학습을 시작할 수 있게 합니다. 워밍업 단계에서 스텝 $s$에서의 학습률 $\eta_s$는 다음과 같이 계산됩니다.

$$\eta_s = \frac{s}{500} \times \eta_{max}$$

여기서 $s$는 현재 스텝 번호(0부터 500까지)이며, $\eta_{max}$는 목표 학습률입니다. 500 스텝 이후에는 앞서 설명한 코사인 스케줄이 적용됩니다.

```python
def get_cosine_schedule_with_warmup(optimizer, num_warmup_steps, num_training_steps, 
                                     min_lr_ratio=0.0):
    """
    워밍업과 코사인 감쇠를 결합한 학습률 스케줄러
    
    Args:
        optimizer: 옵티마이저
        num_warmup_steps: 워밍업 스텝 수 (500)
        num_training_steps: 총 훈련 스텝 수
        min_lr_ratio: 최소 학습률 비율
    """
    def lr_lambda(current_step):
        # 워밍업 단계: 선형 증가
        if current_step < num_warmup_steps:
            return float(current_step) / float(max(1, num_warmup_steps))
        
        # 코사인 감쇠 단계
        progress = float(current_step - num_warmup_steps) / float(
            max(1, num_training_steps - num_warmup_steps)
        )
        cosine_decay = 0.5 * (1.0 + math.cos(math.pi * progress))
        
        return min_lr_ratio + (1.0 - min_lr_ratio) * cosine_decay
    
    return torch.optim.lr_scheduler.LambdaLR(optimizer, lr_lambda)

# 사용 예시
optimizer = torch.optim.AdamW(
    model.parameters(),
    lr=8e-6,
    weight_decay=0.1
)

scheduler = get_cosine_schedule_with_warmup(
    optimizer,
    num_warmup_steps=500,
    num_training_steps=total_steps
)
```

### 훈련 기간과 에포크 설정

모델은 총 3 에포크 동안 훈련되었으며, 전체 훈련 과정은 약 200시간이 소요되었습니다. 3 에포크는 2,580만 개의 데이터셋을 세 번 반복하여 학습한다는 의미입니다. 에포크 수의 선택은 과적합과 과소적합 사이의 균형을 맞추는 중요한 결정입니다. 너무 적은 에포크는 모델이 데이터로부터 충분히 학습하지 못하게 하며, 너무 많은 에포크는 훈련 데이터에 과적합되어 일반화 성능이 저하될 수 있습니다.

152개의 GPU를 사용하여 200시간이 소요되었다는 것은 총 약 30,400 GPU-시간의 계산 자원이 투입되었음을 의미합니다. 이는 단일 GPU로 환산하면 약 3.5년에 해당하는 계산량입니다. 이러한 대규모 계산 자원의 투입은 현대 대규모 언어 모델 훈련의 특징이며, 분산 훈련 인프라의 중요성을 보여줍니다.

훈련 과정에서 모델은 2,580만 개의 다양한 인스트럭션-응답 쌍을 학습하며, 독해, 텍스트 수정, 도구 사용, 수학적 추론, 코딩, 창의적 글쓰기 등 17개의 서로 다른 능력을 개발합니다. 각 능력은 AgentInstruct 플로우를 통해 생성된 고품질의 다양한 데이터로 뒷받침되며, 이는 모델이 특정 벤치마크가 아닌 근본적인 능력을 학습하도록 유도합니다. 이러한 포괄적인 훈련 접근법은 Orca-3가 다양한 평가 시나리오에서 강건한 성능을 보이는 기반이 됩니다.
## 평가 결과

### Orca-Bench 평가

Orca-Bench 데이터셋은 AgentInstruct를 통해 데이터가 큐레이션된 17개 기술 각각에 대해 100개의 샘플로 구성된 홀드아웃 테스트 세트로 사용됩니다. 단, 개방형 도메인 질문 응답(ODQA) 카테고리는 두 개의 테스트 세트로 구성됩니다. 첫 번째 서브셋인 ODQA는 초기 시드 인스트럭션 단계에서 생성된 100개의 질문으로 구성되며, 두 번째 서브셋인 Complex ODQA는 정제 단계에서 개발된 더 복잡한 질문들을 포함합니다.

모든 기준 모델의 성능은 Orca-Bench 데이터셋을 사용하여 평가되었으며, GPT-4를 기준으로 0에서 10까지의 척도로 점수가 매겨졌습니다. Orca-Bench 내의 일부 항목은 다중 턴 교환을 포함합니다. 다중 턴 상호작용을 (시스템 메시지, user1, assistant, user2, assistant, ...)의 시퀀스로 표현할 때, 각 턴은 GPT-4(교사)에 의해 작성됩니다. 모든 $\text{user}_i$ 입력에 대해 교사가 설정한 이전 대화 기록을 조건으로 하는 학생 응답을 생성하며, 학생이 생성한 응답을 원래 교사의 응답과 비교하여 각각 0에서 10까지의 척도로 평가합니다.

학생의 전체 점수를 계산하기 위해 학생의 개별 점수를 합산하고 이 총합을 교사 점수의 합으로 나눈 후, 이 비율에 10을 곱하여 학생의 최종 점수를 0에서 10까지의 척도로 정규화합니다. 수학적으로 표현하면 다음과 같습니다.

$$\text{Student Score} = \frac{\sum_{i=1}^{n} \text{Score}_{\text{student}, i}}{\sum_{i=1}^{n} \text{Score}_{\text{teacher}, i}} \times 10$$

여기서 $n$은 다중 턴 대화의 총 턴 수이며, $\text{Score}_{\text{student}, i}$와 $\text{Score}_{\text{teacher}, i}$는 각각 $i$번째 턴에서의 학생과 교사의 점수입니다.

AgentInstruct의 목표는 다양한 난이도를 가진 대규모의 다양한 데이터 코퍼스를 합성하는 것입니다. 이 전략의 효과적인 실행은 Orca-2.5, Mistral-Instruct-7b, ChatGPT와 같은 기준 모델들이 10점보다 상당히 낮은 점수를 받는 데이터셋을 생성해야 하며, 이는 벤치마크로 지정된 GPT-4에 비해 상대적으로 열등함을 보여줍니다.

![Orca-3 체크포인트와 기준 모델 간 성능 비교](/assets/2025-10-19-agentinstruct--toward-generative-teaching-with-agentic-flows/1.png)

위 그래프는 기준 모델과 Orca-3 간의 비교 분석을 보여줍니다. 이 그래프는 AgentInstruct 데이터에 의해 가능해진 사후 훈련 동안 광범위한 능력의 주목할 만한 향상을 보여줍니다. 외부 원은 GPT-4의 점수인 10을 나타내며, 각 축은 서로 다른 기술 영역을 나타냅니다. Orca-3는 대부분의 영역에서 기준 모델들을 크게 능가하며 GPT-4에 근접한 성능을 보입니다.

| 모델 | Orca-Bench 점수 |
|------|----------------|
| Orca-2.5 | 7.13 |
| Mistral-Instruct-7B | 8.31 |
| ChatGPT | 8.13 |
| Orca-3 (에포크 1 체크포인트) | 9.35 |
| Orca-3 (에포크 2 체크포인트) | 9.49 |
| Orca-3 | 9.55 |

위 표는 평가된 모든 차원에 걸친 평균(매크로) 점수를 보여줍니다. 각 훈련 에포크 후의 Orca-3를 포함하여 평균적으로 AgentInstruct 데이터의 포함은 Orca-2.5 기준선 대비 33.94%의 성능 향상과 Mistral-Instruct-7B 대비 14.92%의 향상을 가져왔습니다. 이러한 결과는 AgentInstruct가 생성한 합성 데이터가 모델의 전반적인 능력을 실질적으로 향상시킬 수 있음을 명확히 보여줍니다.

### 표준 벤치마크 평가 결과

Orca-3는 AGIEval, MMLU, ARC, BBH, GPQA, DROP, GSM8K, FoFo, IFEval, MT-Bench, AlpacaEval, InfoBench, EQBench를 포함한 16개의 벤치마크에서 Orca-2.5, Mistral-7B-Instruct-v0.3, LLAMA3-8B-Instruct, GPT-3.5-turbo, GPT-4를 포함한 5개의 기준 모델과 비교 평가되었습니다.

평가된 벤치마크들은 다양한 능력을 측정합니다. AGIEval은 SAT, LSAT 등 표준화 시험 기반 벤치마크이며, MMLU는 57개 학문 분야의 다중 작업 이해를 평가합니다. ARC는 추론과 상식 지식을 측정하고, BBH는 복잡한 다단계 추론을 요구하는 23개 작업으로 구성됩니다. GPQA는 대학원 수준의 과학 질문을 다루며, DROP은 단락에 대한 이산 추론을 평가합니다. GSM8K는 초등학교 수학 문제를 포함하고, FoFo는 형식 준수 능력을 측정합니다. IFEval은 자연어 인스트럭션 따르기를 평가하며, MT-Bench는 다중 턴 대화 능력을 측정합니다. AlpacaEval은 인스트럭션 따르기 작업을 평가하고, InfoBench는 분해된 요구사항 준수 비율을 사용하며, EQBench는 감성 지능을 평가합니다.

| 모델 | Orca-3 -7B | Orca-2.5 -7B | Mistral-7B-Instruct | LLAMA3-8B-instruct | GPT-3.5-turbo | GPT-4 |
|------|-----------|-------------|-------------------|-------------------|--------------|-------|
| AGIEval | 56.80 (+40%) | 42.71 | 40.52 | 47.17 | 50.91 | 61.99 |
| MMLU | 69.95 (+19%) | 60.34 | 58.61 | 63.44 | 68.26 | 67.07 |
| ARC | 92.47 (+12%) | 86.39 | 82.72 | 85.74 | 92.0 | 93.35 |
| BBH | 61.83 (+38%) | 48.63 | 44.71 | 54.97 | 54.17 | 76.06 |
| GPQA | 28.12 (-4%) | 27.68 | 29.46 | 28.12 | 27.9 | 33.93 |
| DROP | 71.14 (+22%) | 65.19 | 58.12 | 68.44 | 67.15 | 67.36 |
| GSM8K | 83.09 (+54%) | 74.3 | 54.06 | 77.48 | 78.1* | 86.88 |
| FoFo | 84.01 (+12%) | 66.19 | 75.3 | 79.35 | 76.92 | 87.45 |
| IFEval | 49.54 (+2%) | 45.29 | 48.61 | - | 58.6 | 79.3 |
| MT-Bench | 8.20 (+9%) | 7.15 | 7.53 | 7.99 | 8.01 | 9.04 |
| AlpacaEval | 24.80 (+45%) | 13.47 | 17.1 | 22.9 | 22.7 | 55 |
| InfoBench | 84.30 (+4%) | 79.6 | 81 | - | 86.7 | 89.4 |
| EQBench Metric-v2 | 91.36 (+4%) | 88.03 | 87.75 | 88.67 | 88.95 | 93.32 |
| EQBench Metric-v1 | 50.28 (+28%) | 38.8 | 39.27 | 42.13 | 42.05 | 55.98 |

위 표는 모든 벤치마크에서 Orca-3와 다른 기준 모델들의 성능을 보여줍니다. 괄호 안의 백분율은 Mistral-7B-Instruct 대비 상대적 개선을 나타냅니다. Orca-3는 대부분의 벤치마크에서 상당한 개선을 보이며, 특히 AGIEval에서 40%, BBH에서 38%, GSM8K에서 54%, AlpacaEval에서 45%의 향상을 달성했습니다. 모든 평가는 제로샷 설정에서 수행되었습니다.

### 독해 능력 평가

독해 능력은 대규모 언어 모델에게 중요한 능력이며, 소규모 언어 모델에게는 단순한 검색 시스템이 아닌 추론 엔진으로서 더욱 중요합니다. AgentInstruct를 통한 목표 지향적 훈련을 통해 Mistral의 독해 능력에서 상당한 개선이 관찰되었으며, Orca-2.5 대비 18%, Mistral-Instruct-7B 대비 21%의 향상을 보였습니다. 이러한 데이터 기반 접근법을 활용하여 7B 모델의 성능을 LSAT 독해 섹션에서 GPT-4와 동등한 수준으로 끌어올렸습니다.

| 모델 | Orca-3 -7B | Orca-2.5 -7B | Mistral-7B-Instruct | GPT-4 | GPT-3.5-turbo |
|------|-----------|-------------|-------------------|-------|--------------|
| AGIEval lsat-rc | 75.84 (+21%, +20%) | 62.45 | 63.2 | 63.57 | 72.86 |
| AGIEval sat-en | 87.38 (+13%, +15%) | 77.18 | 75.73 | 82.04 | 82.52 |
| AGIEval gaokao-english | 87.25 (+13%, +17%) | 77.45 | 74.84 | 83.01 | 87.25 |
| AGIEval lsat-lr | 63.14 (+45%, +36%) | 43.53 | 46.27 | 54.9 | 68.82 |
| DROP | 71.14 (+9%, +22%) | 65.19 | 58.12 | 67.15 | 67.36 |
| 평균 | 76.95 (+18%, +21%) | 65.16 | 63.63 | 70.13 | 75.76 |

위 표는 독해 기반 하위 작업과 벤치마크에서의 모델 성능을 보여줍니다. Orca-3 결과 옆의 백분율은 각각 Orca-2.5와 Mistral-7B-Instruct 대비 개선 비율을 나타냅니다. 특히 LSAT 논리적 추론(lsat-lr)에서 45%의 향상을 보였으며, 이는 AgentInstruct의 논증 강화/약화 질문 생성 플로우가 효과적으로 작동했음을 보여줍니다.

### 수학 능력 평가

수학 문제 해결을 통한 추론 능력 평가는 AI 모델의 능력을 효과적으로 측정할 수 있는 방법입니다. 소규모 언어 모델은 초등 수학에서 상당한 개선을 보였지만, 일반적으로 더 복잡한 고등학교 및 대학 수준 수학에서는 성능이 저하됩니다. AgentInstruct를 통해 초등 수준부터 대학 수준까지 다양한 난이도에 걸쳐 Mistral의 수학 능력을 향상시켰으며, 다양한 수학 벤치마크에서 44%에서 168%에 이르는 상당한 성능 향상을 달성했습니다.

| 모델 | Orca-3 -7B | Orca-2.5 -7B | Mistral-7B-Instruct | GPT-4 | GPT-3.5-turbo |
|------|-----------|-------------|-------------------|-------|--------------|
| AGIEval math | 42.90 (+73%, +168%) | 24.8 | 16.0 | 38.0 | 57.9 |
| AGIEval sat-math | 80.91 (+34%, +50%) | 60.45 | 54.09 | 67.73 | 90.0 |
| BBH multistep-arithmetic-two | 66.80 (+1418%, +882%) | 4.4 | 6.8 | 46.4 | 77.2 |
| MMLU abstract algebra | 55.00 (+129%, +104%) | 24.0 | 27.0 | 47.0 | 70.0 |
| MMLU college mathematics | 44.00 (+63%, +44%) | 30.0 | 34.0 | 39.0 | 62.0 |
| MMLU high-school mathematics | 66.67 (+41%, +94%) | 47.41 | 34.44 | 57.04 | 66.67 |
| GSM8K | 83.09 (+12%, +54%) | 74.3 | 54.06 | 78.1* | 86.88 |

위 표는 수학 벤치마크에서의 모델 성능 점수를 보여줍니다. Orca-3 결과 옆의 백분율은 각각 Orca-2.5와 Mistral-7B-Instruct 대비 개선 비율을 나타냅니다. 특히 BBH 다단계 산술에서 1418%의 극적인 향상을 보였으며, 이는 AgentInstruct의 수학 문제 생성 플로우가 복잡한 다단계 추론 능력을 효과적으로 가르쳤음을 보여줍니다. AgentInstruct의 목표는 특정 벤치마크를 충족하기 위한 데이터 생성이 아니라 기술을 가르치는 것이며, 다양한 수학 데이터셋에서의 뚜렷한 향상은 생성적 교육을 위한 AgentInstruct의 효과성을 입증합니다.

### 형식 준수 능력 평가

형식 지침을 따르는 것은 언어 모델이 실제 상황에 적용되기 위해 필수적입니다. 모든 AgentInstruct 플로우에서 각 특정 시나리오에 대한 형식 준수를 가르치기 위해 에이전트를 통해 여러 형식 지침을 합성했습니다. 이를 통해 Mistral의 형식 준수 능력을 11.5% 향상시켜 Gemini Pro의 능력을 능가했습니다.

| 모델 | FoFo |
|------|------|
| **오픈소스** | |
| Orca-3-7B | 84.01 (+26.92%, +11.5%) |
| Orca-2.5-7B | 66.19 |
| Mistral-7B-Instruct | 75.3 |
| **클로즈드소스** | |
| GPT-3.5-turbo | 76.92 |
| Gemini Pro | 80.25* |
| GPT-4 | 87.45 |

위 표는 FoFo 벤치마크에서 Orca-3-7B 모델과 다른 오픈소스 및 클로즈드소스 기준 모델들의 성능을 보여줍니다. Orca-3 결과 옆의 백분율은 각각 Orca-2.5와 Mistral-7B-Instruct 대비 개선 비율을 나타냅니다. Orca-3는 84.01점을 달성하여 Gemini Pro(80.25)를 능가하고 GPT-4(87.45)에 근접한 성능을 보입니다.

### 추상적 요약 능력 평가

요약은 언어 모델의 중요한 능력이며, 많은 모델이 고품질 요약 성능을 달성하지만 환각 문제로 어려움을 겪습니다. 요약 능력은 환각과 품질이라는 두 가지 핵심 지표를 사용하여 평가되었으며, GPT-4를 평가자로 사용했습니다.

평가에 사용된 벤치마크는 다음과 같습니다. ACI-Bench는 의사-환자 대화로부터 자동 보고서 생성을 벤치마킹하기 위한 데이터셋으로 120개의 데이터 포인트로 구성됩니다. InstruSum은 인스트럭션 제어 가능한 요약을 위한 생성 능력을 평가하는 데이터셋으로 100개의 데이터 포인트를 포함합니다. Orca-Sum은 요약 및 근거 기반 데이터 변환 인스트럭션을 따르는 능력을 평가하기 위해 새로 생성된 벤치마크로, 뉴스, 대화, 과학, 건강, 소셜, 이메일, 코드 등 여러 도메인에 걸친 45개의 요약 데이터셋에서 샘플링한 458개의 데이터 포인트로 구성됩니다.

| 모델 | Orca-3 -7B | Orca-2.5 -7B | Mistral-7B-Instruct | LLAMA3-8B-instruct | GPT-3.5-turbo | GPT-4 |
|------|-----------|-------------|-------------------|-------------------|--------------|-------|
| **환각 비율 (%) - 낮을수록 좋음** | | | | | | |
| 전체 (마이크로) | 21.09 (-26.12%, -31.34%) | 28.55 | 30.72 | 34.22 | 21.13 | 15.07 |
| Orca-Sum | 28.17 | 36.84 | 39.61 | 38.43 | 28.60 | 21.66 |
| InstruSum | 9.00 | 12.00 | 17.00 | 25.00 | 12.00 | 1.00 |
| ACI-Bench | 4.20 | 10.83 | 8.30 | 25.83 | 1.70 | 1.70 |
| **품질 점수 (1-10) - 높을수록 좋음** | | | | | | |
| 전체 (마이크로) | 9.14 (+7.91%, +3.28%) | 8.47 | 8.85 | 9.00 | 8.69 | 9.08 |
| Orca-Sum | 8.95 | 8.27 | 8.61 | 8.90 | 8.32 | 8.61 |
| InstruSum | 9.17 | 8.30 | 9.16 | 9.21 | 9.27 | 9.31 |
| ACI-Bench | 9.72 | 9.39 | 9.48 | 9.23 | 9.60 | 9.70 |

위 표는 GPT-4에 의해 평가된 환각 비율과 품질 점수를 보여줍니다. Orca-3 결과 옆의 백분율은 각각 Orca-2.5와 Mistral-7B-Instruct 대비 개선 비율을 나타냅니다. AgentInstruct 접근법을 통해 환각을 31.34% 감소시키면서 GPT-4(교사)와 비슷한 품질 수준을 달성했습니다. 이는 AgentInstruct의 요약 플로우가 정확성과 품질을 동시에 향상시킬 수 있음을 보여줍니다.

### RAG 능력 평가

RAG(검색 증강 생성) 기술은 언어 모델이 정보에 기반한 맥락적으로 정확한 응답을 생성하는 능력을 크게 향상시켜 전반적인 성능과 유용성을 업그레이드합니다. 언어 모델의 RAG 능력을 테스트하는 데 있어 모델이 제한된 지식을 가진 영역에서 평가하는 것이 더 효과적입니다. 이 연구에서는 의료 코퍼스에서 검색된 정보를 참조하여 의료 질문에 답하는 데 초점을 맞춘 MIRAGE 벤치마크를 선택했습니다. 의료 도메인은 일반적으로 평가된 모델들의 주요 초점이 아니므로, MIRAGE는 RAG 능력을 평가하는 효과적인 플랫폼을 제공합니다. 또한 AgentInstruct RAG 데이터는 일반적인 비의료 데이터 시드를 사용했기 때문에, 기술(RAG)이 새로운 도메인에 얼마나 잘 적용될 수 있는지 테스트할 수 있습니다.

| MIRAGE 데이터셋 | MMLU-Med | MedQA-US | MedMCQA | PubMedQA | BioASQ | 평균 |
|----------------|----------|----------|---------|----------|--------|------|
| **GPT-4 (0613)** | | | | | | |
| CoT | 89.44 | 83.97 | 69.88 | 39.6 | 84.3 | 73.44 |
| RAG | 87.24 | 82.8 | 66.65 | 70.6 | 92.56 | 79.97 |
| **GPT-3.5-turbo (0613)** | | | | | | |
| CoT | 72.91 | 65.04 | 55.2 | 36 | 74.27 | 60.69 |
| RAG | 75.48 | 66.61 | 58.04 | 67.4 | 90.29 | 71.57 |
| **Orca-2.5-7B** | | | | | | |
| CoT | 63.91 | 51.37 | 43.65 | 29.6 | 71.04 | 51.92 |
| RAG | 53.72 | 37.08 | 39.2 | 31 | 69.09 | 43.62 |
| **Mistral-7B-Instruct-v0.1** | | | | | | |
| CoT | 50.96 | 42.73 | 34.9 | 27.6 | 47.57 | 40.75 |
| RAG | 54.64 | 35.35 | 43.41 | 30.2 | 68.77 | 46.47 |
| **Orca-3-7B** | | | | | | |
| CoT | 71.35 | 55.38 | 51.33 | 27.8 | 75.24 | 56.22 |
| RAG | 71.17 (+30.25%) | 51.85 (+46.68%) | 57.95 (+33.49%) | 58.2 (+92.71%) | 82.2 (+19.52%) | 64.27 (+38.30%) |

위 표는 MIRAGE에서 RAG 기술 평가 결과를 보여줍니다. Orca-3 결과 옆의 백분율은 Mistral-7B-Instruct 대비 개선 비율을 나타냅니다. CoT는 RAG를 사용하지 않고 직접 답변할 때의 동일한 모델의 성능을 보여줍니다. 모든 모델에서 동일한 검색 메커니즘을 사용하여 MedRAG 코퍼스를 활용했으며, 동일한 검색 함수와 동일한 수의 검색된 문서를 사용했습니다. 모든 모델이 동일한 검색 문서 세트를 제공받았으므로, 비교는 서로 다른 모델이 검색 결과를 응답에 통합하는 능력을 정확하게 반영합니다.

전반적으로 다음과 같은 관찰이 이루어졌습니다. 작업에 대한 더 깊은 이해를 가진 모델(CoT 점수)이 더 높은 RAG 점수를 보이는 경향이 있습니다. RAG 성능에만 초점을 맞추면, 사후 훈련을 적용하여 Mistral의 성능을 평균 38.30% 향상시켰습니다. MIRAGE의 다섯 데이터셋 중 PubMedQA는 모델의 RAG 능력을 평가하는 가장 효과적인 테스트베드를 제공합니다. PubMedQA에서는 모든 모델이 제한된 사전 지식을 가지고 있으며, 검색된 맥락이 필수 정보를 제공하는데, 이는 GPT-4의 성능 도약으로 입증됩니다. 모든 Mistral 파인튜닝 모델이 유사한 성능을 보이지만, AgentInstruct RAG 플로우 데이터로 훈련된 Orca-3만이 상당한 개선을 보여 Mistral-Instruct 대비 92.71%의 상대적 향상을 달성했습니다.
## 한계점

AgentInstruct는 데이터 생성에 필요한 인간 전문성을 크게 줄이고 대규모의 고품질 합성 데이터 생성을 가능하게 하지만, 이는 여전히 이 방향의 초기 단계이며 합성 데이터 생성과 관련된 여러 한계점을 가지고 있습니다.

### 합성 데이터 생성의 근본적 한계

확장성 측면에서 서로 다른 기술에 대한 에이전틱 플로우를 생성하는 것은 플로우 구축을 위한 인간의 노력에 의존합니다. 현재 AgentInstruct는 17개의 서로 다른 기술에 대해 에이전틱 플로우를 구현했지만, 각 플로우는 콘텐츠 변환 에이전트, 시드 인스트럭션 생성 에이전트, 정제 에이전트의 설계와 구성을 위한 상당한 인간의 개입을 필요로 합니다. 예를 들어, 독해 능력을 위한 플로우는 9개의 콘텐츠 변환 에이전트와 43개의 질문 유형을 포함하는 분류 체계를 정의해야 했으며, 이는 독해 평가에 대한 깊은 전문 지식을 요구합니다. 향후 연구에서는 사용자 명세로부터 에이전틱 플로우의 구축을 자동화하는 방법을 고려해야 합니다. 이는 메타 학습이나 프로그램 합성 기법을 활용하여 사용자가 원하는 기술의 특성을 입력하면 자동으로 적절한 에이전트 구성과 분류 체계를 생성하는 시스템을 개발하는 것을 의미할 수 있습니다.

정확성 측면에서 합성 데이터는 실제 세계 데이터의 복잡성과 미묘한 차이를 완벽하게 재현하지 못할 수 있어 잠재적인 부정확성으로 이어질 수 있습니다. 예를 들어, AgentInstruct가 생성한 독해 질문은 LSAT 스타일의 논리적 추론 질문을 모방하지만, 실제 LSAT 문제가 가진 법률적 맥락의 미묘함이나 특정 도메인 지식을 완전히 포착하지 못할 수 있습니다. 또한 GPT-4와 같은 강력한 모델을 사용하여 응답을 생성하더라도, 이러한 모델 자체가 환각이나 추론 오류를 범할 수 있으며, 이는 생성된 데이터의 품질에 영향을 미칩니다. 데이터의 품질을 더 잘 평가하기 위한 추가 작업이 필요합니다. 이는 자동화된 품질 평가 메트릭의 개발, 인간 평가자를 활용한 체계적인 품질 검증 프로세스의 구축, 그리고 생성된 데이터의 다양성과 난이도 분포를 분석하는 도구의 개발을 포함할 수 있습니다.

비용 측면에서 여러 에이전트와 도구를 사용하는 LLM으로 합성 데이터를 생성하는 것은 자원 집약적일 수 있습니다. AgentInstruct는 2,500만 개의 인스트럭션-응답 쌍을 생성하기 위해 GPT-4와 같은 강력한 모델을 반복적으로 호출하며, 각 인스트럭션은 콘텐츠 변환, 시드 생성, 정제의 여러 단계를 거칩니다. 예를 들어, 독해 질문 하나를 생성하기 위해 원시 텍스트를 논증 구절로 변환하고($\text{cost}_1$), 43개 질문 유형 중 하나에 따라 질문을 생성하며($\text{cost}_2$), 제안자-편집자 쌍을 통해 복잡도를 높이는($\text{cost}_3$) 과정을 거칩니다. 총 비용은 $\text{Total Cost} = N \times (\text{cost}_1 + \text{cost}_2 + \text{cost}_3)$로 표현될 수 있으며, 여기서 $N$은 생성할 인스트럭션의 수입니다. 2,500만 개의 인스트럭션을 생성하는 데 드는 API 호출 비용은 상당할 수 있으며, 이는 대규모 합성 데이터 생성의 실용성을 제한할 수 있습니다.

편향 측면에서 합성 데이터를 생성하는 데 사용된 원래 시드 데이터에 편향이 포함되어 있다면, 이러한 편향은 합성 데이터에 반영되고 심지어 증폭될 수 있습니다. AgentInstruct는 KnowledgePile, AutoMathText, OpenStax 자료, Apache-2.0 라이선스 소스 코드를 시드로 사용합니다. 이러한 데이터 소스가 특정 주제, 관점, 또는 인구 통계에 편향되어 있다면, 생성된 합성 데이터도 동일한 편향을 가질 것입니다. 예를 들어, 시드 데이터가 주로 서구 중심의 관점을 반영한다면, 생성된 독해 구절과 질문도 서구 중심적일 수 있습니다. 더 나아가, 에이전틱 플로우가 특정 패턴을 반복적으로 생성하면서 편향을 증폭시킬 수 있습니다. 제안자-편집자 메커니즘이 특정 유형의 복잡도 증대 전략을 선호한다면, 이는 데이터의 다양성을 제한하고 특정 편향을 강화할 수 있습니다.

검증 측면에서 합성 데이터가 원하는 시나리오를 정확하게 나타내는지 확인하기 위해 검증하는 것이 어려울 수 있습니다. AgentInstruct는 자동화된 플로우를 통해 대량의 데이터를 생성하지만, 각 생성된 인스트럭션이 의도한 기술을 실제로 가르치는지, 적절한 난이도를 가지는지, 그리고 정확한 응답을 포함하는지 검증하는 것은 도전적입니다. 예를 들어, 생성된 수학 문제가 실제로 풀 수 있는 문제인지, 제공된 답이 정확한지 자동으로 검증하기 위해서는 코드 인터프리터를 사용한 답 검증이 필요하지만, 이것도 완벽하지 않습니다. 복잡한 다단계 추론 문제의 경우, 중간 단계의 정확성을 검증하는 것은 더욱 어렵습니다. 또한 생성된 데이터가 벤치마크 특화가 아닌 일반적인 능력을 가르치는지 확인하는 것도 중요한 검증 과제입니다.

시드 데이터 의존성 측면에서 합성 데이터의 품질은 시드로 사용된 실제 데이터의 품질에 의존합니다. 품질이 낮은 입력 데이터는 품질이 낮은 합성 데이터를 초래할 수 있습니다. AgentInstruct가 웹 크롤링 데이터를 시드로 사용하는 경우, 이 데이터에 사실적 오류, 문법적 오류, 또는 불완전한 정보가 포함되어 있다면, 생성된 독해 구절과 질문도 이러한 문제를 상속받을 수 있습니다. 예를 들어, 시드 기사가 과학적 개념을 잘못 설명하고 있다면, 이를 기반으로 생성된 질문과 답변도 잘못된 정보를 포함할 것입니다. 콘텐츠 변환 에이전트가 이러한 오류를 수정할 수도 있지만, 항상 보장되는 것은 아닙니다. 따라서 시드 데이터의 품질 관리는 AgentInstruct의 성공에 매우 중요합니다.

### Orca-3 모델의 한계

Orca-3는 AgentInstruct 데이터로 파인튜닝되었으며 Mistral 모델 패밀리를 기반으로 하므로, Mistral의 많은 한계와 다른 대규모 언어 모델의 일반적인 한계, 그리고 훈련 과정에서 비롯된 한계를 유지합니다.

데이터 편향 측면에서 방대한 데이터로 훈련된 대규모 언어 모델은 소스 데이터에 존재하는 편향을 의도치 않게 포함할 수 있습니다. 결과적으로 모델은 잠재적으로 편향되거나 불공정한 출력을 생성할 수 있습니다. Orca-3는 Mistral-7b-v0.1을 기본 모델로 사용하며, 이 모델은 대규모 웹 데이터로 사전 훈련되었습니다. 웹 데이터는 성별, 인종, 문화적 편향을 포함할 수 있으며, 이러한 편향은 사전 훈련 단계에서 모델에 학습됩니다. AgentInstruct 데이터로 사후 훈련을 수행하더라도, 기본 모델에 내재된 편향을 완전히 제거하기는 어렵습니다. 예를 들어, 특정 직업이나 역할에 대한 성별 고정관념이 모델의 응답에 반영될 수 있습니다.

투명성 부족 측면에서 복잡성과 크기로 인해 대규모 언어 모델은 "블랙박스"로 작동할 수 있어, 특정 출력이나 결정 뒤의 근거를 이해하기 어렵게 만듭니다. Orca-3는 70억 개의 파라미터를 가진 트랜스포머 기반 모델이며, 각 출력은 수십억 개의 파라미터 간의 복잡한 상호작용의 결과입니다. 모델이 특정 답변을 생성한 이유를 정확히 설명하는 것은 매우 어렵습니다. 예를 들어, 모델이 특정 독해 질문에 대해 잘못된 답을 제공했을 때, 그 오류가 훈련 데이터의 특정 패턴, 모델 아키텍처의 한계, 또는 파인튜닝 과정의 문제 중 무엇에서 비롯되었는지 파악하기 어렵습니다. 더 많은 정보를 위해 Azure의 투명성 노트를 검토하는 것이 권장됩니다.

콘텐츠 유해성 측면에서 대규모 언어 모델이 야기할 수 있는 다양한 유형의 콘텐츠 유해성이 있습니다. 이러한 모델을 사용할 때 이를 인식하고 예방 조치를 취하는 것이 중요합니다. 여러 회사와 기관에서 제공하는 다양한 콘텐츠 조정 서비스를 활용하는 것이 권장됩니다. 중요한 점으로, AI 기술에 대한 콘텐츠 유해성과 관련하여 정부와 기술 리더들로부터 더 나은 규제와 표준이 마련되기를 희망합니다. 연구와 오픈소스 커뮤니티가 이 방향에서 수행할 수 있는 중요한 역할을 가치 있게 여기고 인정합니다. 대규모 언어 모델은 혐오 발언, 폭력적 콘텐츠, 개인정보 침해, 허위 정보 등 다양한 유해 콘텐츠를 생성할 수 있습니다. Orca-3도 이러한 위험으로부터 자유롭지 않으며, 특히 악의적인 프롬프트에 대응할 때 부적절한 콘텐츠를 생성할 수 있습니다.

환각 측면에서 중요한 결정이나 깊은 영향을 미칠 수 있는 정보에 대해 주어진 언어 모델에 전적으로 의존하지 않도록 주의하고 조심하는 것이 중요합니다. 이러한 모델이 콘텐츠를 조작하는 것을 방지하는 방법이 명확하지 않기 때문입니다. 더욱이 소규모 모델이 더 작은 크기와 따라서 감소된 기억 용량으로 인해 근거 없는 생성 사용 사례에서 환각에 더 취약할 수 있는지는 명확하지 않습니다. 이는 활발한 연구 주제이며, 이 주제에 대한 더 엄격한 측정, 이해, 완화 방안이 마련되기를 희망합니다. 환각은 모델이 사실이 아니거나 입력과 관련 없는 정보를 자신 있게 생성하는 현상을 의미합니다. 예를 들어, Orca-3에게 특정 역사적 사건에 대해 질문했을 때, 모델이 실제로 발생하지 않은 세부 사항을 추가하거나 날짜를 잘못 기억할 수 있습니다. 소규모 모델의 경우, 70억 개의 파라미터는 GPT-4와 같은 대규모 모델에 비해 상대적으로 제한된 기억 용량을 가지므로, 특정 도메인 지식이나 희귀한 사실에 대해 환각을 생성할 가능성이 더 높을 수 있습니다.

악용 가능성 측면에서 적절한 안전장치 없이는 이러한 모델이 허위 정보나 유해한 콘텐츠를 생성하는 데 악의적으로 사용될 위험이 있습니다. Orca-3는 고품질의 텍스트를 생성할 수 있는 능력을 가지고 있으며, 이는 긍정적인 목적으로 사용될 수 있지만 동시에 악용될 수도 있습니다. 예를 들어, 모델을 사용하여 설득력 있는 가짜 뉴스 기사를 생성하거나, 피싱 이메일을 작성하거나, 소셜 미디어에서 여론을 조작하기 위한 봇을 운영할 수 있습니다. 또한 모델의 코딩 능력을 악용하여 악성 코드를 생성하거나, 보안 취약점을 찾는 데 사용할 수도 있습니다. 이러한 악용을 방지하기 위해서는 모델 접근 제어, 사용 모니터링, 콘텐츠 필터링 등의 안전장치가 필요합니다.

데이터 분포 측면에서 Orca-3의 성능은 튜닝 데이터의 분포와 강하게 상관될 가능성이 높습니다. 이러한 상관관계는 훈련 데이터셋에서 과소 대표된 영역에서의 정확성을 제한할 수 있습니다. AgentInstruct는 17개의 서로 다른 기술에 대해 2,500만 개의 인스트럭션을 생성했지만, 이러한 기술과 데이터의 분포는 균일하지 않을 수 있습니다. 예를 들어, 독해와 수학 문제가 데이터셋의 상당 부분을 차지한다면, 모델은 이러한 영역에서 강한 성능을 보이지만 상대적으로 적게 표현된 다른 기술(예: 특정 도메인의 전문 지식)에서는 약한 성능을 보일 수 있습니다. 또한 시드 데이터로 사용된 KnowledgePile과 AutoMathText가 특정 주제나 난이도 수준에 편향되어 있다면, 모델의 성능도 이러한 편향을 반영할 것입니다. 예를 들어, 의료 도메인의 데이터가 부족하다면, MIRAGE 벤치마크에서 관찰된 것처럼 의료 질문에 대한 성능이 제한될 수 있습니다.

이러한 한계점들은 AgentInstruct와 Orca-3가 상당한 진전을 이루었음에도 불구하고, 합성 데이터 생성과 대규모 언어 모델 개발에는 여전히 해결해야 할 중요한 과제들이 남아 있음을 보여줍니다. 향후 연구에서는 이러한 한계를 완화하고 더 안전하고 신뢰할 수 있으며 공정한 AI 시스템을 개발하기 위한 노력이 필요합니다.

## 결론

AgentInstruct 접근법은 사후 훈련을 위한 대량의 다양하고 고품질의 데이터를 생성하는 과제에 대한 유망한 해결책을 제공합니다. 이 방법은 합성 데이터 생성을 위해 에이전틱 플로우를 사용함으로써 두드러지며, 따라서 모델 훈련에서 합성 데이터 사용과 관련된 주요 우려사항인 다양성 부족과 데이터 생성 과정에서의 집중적인 인간 큐레이션 및 개입의 필요성을 해결합니다.

에이전틱 프레임워크를 활용함으로써 AgentInstruct는 비구조화된 데이터 소스로부터 프롬프트와 응답을 모두 포함하는 맞춤형 데이터셋을 생성할 수 있으며, 이는 모델의 사후 훈련을 촉진하고 다양한 기술을 가르칩니다. 이 접근법의 효과는 AgentInstruct로 생성된 2,500만 쌍 데이터셋으로 사후 훈련된 Orca-3 모델에서 관찰된 상당한 개선으로 입증됩니다. Orca-3는 여러 벤치마크에서 주목할 만한 성능 향상을 보였습니다.

합성 데이터 생성을 위한 에이전틱 플로우 사용은 사전 훈련, 사후 훈련, 도메인/작업 특화를 포함한 모델 훈련의 모든 단계에서 상당한 가치를 보여줄 수 있다고 믿습니다. 비구조화된 콘텐츠를 사용하여 주어진 명세에 따라 다양하고 고품질의 인스트럭션 데이터를 생성할 수 있는 능력은 합성 데이터를 사용한 모델 맞춤화(도메인 특화 콘텐츠를 시드로 사용)와 지속적인 개선(에이전틱 플로우로 기본 모델보다 높은 품질의 데이터 생성)을 위한 (반)자동화된 파이프라인을 만드는 길을 열 수 있습니다.

AgentInstruct의 핵심 기여는 세 가지 근본적인 과제를 해결한다는 점입니다. 첫째, 대규모 데이터 생성의 과제를 자동화된 에이전틱 플로우를 통해 해결하여 수백만 개의 인스트럭션을 인간의 최소한의 개입으로 생성할 수 있게 합니다. 둘째, 다양성 확보의 과제를 원시 데이터 소스의 활용, 체계적인 분류 체계, 그리고 여러 에이전트의 조합을 통해 해결합니다. 셋째, 복잡한 데이터 생성의 과제를 제안자-편집자 메커니즘을 통한 반복적 정제로 해결하여 단순한 인스트럭션을 도전적인 문제로 발전시킵니다.

향후 방향으로는 에이전틱 플로우 구축의 자동화, 합성 데이터 품질 평가 방법의 개선, 편향 완화 전략의 개발, 그리고 더 효율적인 데이터 생성 메커니즘의 연구가 포함될 수 있습니다. 또한 AgentInstruct 접근법을 다양한 도메인과 언어로 확장하고, 더 큰 모델의 자기 개선에 활용하는 연구도 중요한 방향이 될 것입니다. 합성 데이터 생성을 서비스로 제공하는 개념은 모든 기본 LLM의 지속적인 학습과 개선을 가능하게 하는 잠재력을 가지고 있으며, 이는 AI 시스템의 발전에 중요한 기여를 할 수 있습니다.
## 부록 A: 에이전틱 플로우 세부사항

### 독해 능력 플로우의 에이전트 구성과 설계 철학

독해 능력 플로우는 9개의 전문화된 콘텐츠 변환 에이전트로 구성되며, 이들은 기능적 특성에 따라 세 가지 주요 카테고리로 분류됩니다. 이러한 분류 체계는 독해 능력이 맥락과 형식에 따라 서로 다른 인지 전략을 요구한다는 교육학적 원리를 반영합니다.

**형식 변환 에이전트 그룹**은 원시 텍스트를 특정 담화 형식으로 변환하여 구조화된 추론을 촉진합니다. 논증 구절 생성기(Argument Passage Generator)와 토론 구절 생성기(Debate Passage Generator)는 주장과 근거의 논리적 관계를 명시적으로 드러내는 텍스트를 생성하며, 이는 LSAT 스타일의 논리적 추론 질문 생성에 최적화되어 있습니다. 대화 구절 생성기(Conversation Passage Generator)와 회의록 생성기(Meeting Transcript Generator)는 대화형 맥락에서의 화용론적 추론과 맥락 이해를 평가할 수 있는 콘텐츠를 제공합니다. 이러한 형식 변환은 동일한 정보가 서로 다른 담화 구조로 제시될 때 독자가 어떻게 다른 이해 전략을 적용하는지 평가할 수 있게 합니다.

**창의적 콘텐츠 에이전트 그룹**은 문학적 또는 수사적 기법을 활용하여 고급 언어 이해 능력을 평가합니다. 시 생성기(Poem Generator)는 비유적 언어, 운율, 상징을 통해 표면적 의미를 넘어선 해석 능력을 테스트하며, 풍자 구절 생성기(Satirical Passage Generator)는 명시적 표현과 실제 의도 간의 간극을 파악하는 능력을 평가합니다. 이러한 에이전트들은 문자적 이해를 넘어서 추론적 이해와 비판적 분석 능력을 요구하는 질문 생성을 가능하게 합니다.

**구조적 변환 에이전트 그룹**은 텍스트의 길이와 복잡도를 조정합니다. 교육용 구절 생성기(Instructional Passage Generator)는 절차적 지식과 단계별 추론을 평가할 수 있는 형식으로 변환하며, 긴 텍스트 생성기(Long Text Generator)는 원본을 확장하여 장문 독해와 정보 통합 능력을 테스트합니다. 정체성 에이전트(Identity Agent)는 원본을 그대로 유지하여 변환 없이도 효과적인 질문 생성이 가능한 경우를 처리합니다.

이러한 다층적 에이전트 구성은 단일 원시 텍스트로부터 최대 9가지의 서로 다른 형태로 변환된 구절을 생성할 수 있게 하며, 각 변환된 형태는 특정 유형의 독해 질문 생성에 최적화되어 있습니다. 이는 데이터 다양성을 기하급수적으로 증가시키는 동시에, 각 질문이 특정 독해 기술을 명확하게 타겟팅하도록 보장합니다.

### 독해 질문 유형의 인지적 계층 구조

시드 인스트럭션 생성 플로우는 15개의 질문 유형을 포함하는 분류 체계를 사용하며, 이들은 Bloom의 인지 분류 체계와 독해 능력 이론에 기반하여 세 가지 인지 수준으로 조직됩니다.

**기본 이해 수준**은 텍스트에 명시적으로 제시된 정보를 추출하고 조직하는 능력을 평가합니다. 문자적 이해 질문(Literal Comprehension Question)은 특정 세부 사항이나 사실을 직접 묻는 단답형 또는 목록형 질문으로, 독자의 기본적인 정보 인식 능력을 측정합니다. 어휘 및 언어 사용(Vocabulary and Language Use) 질문은 빈칸 채우기 형식으로 맥락 속에서의 단어 이해를 평가하며, 사건 순서 정하기(Sequencing Events) 질문은 시간적 또는 논리적 순서를 파악하는 능력을 테스트합니다. 이러한 질문들은 독해의 기초를 형성하며, 더 복잡한 추론의 전제 조건이 됩니다.

**분석 수준**은 텍스트 요소 간의 관계를 파악하고 통합하는 능력을 요구합니다. 수치적 이산 추론(Numerical Discrete Reasoning) 질문은 텍스트의 여러 사실에 대한 수치적 추론을 요구하며, 관계 이해 질문(Relationship Comprehension Question)은 매칭 형식으로 항목 간의 특정 기준에 따른 연결을 평가합니다. 비판적 이해 질문(Critical Comprehension Question)은 참/거짓 형식으로 텍스트의 목적이나 관점에 대한 평가를 요구하며, 평가적 이해 질문(Evaluative Comprehension Question)은 에세이 형식으로 텍스트의 주제나 논증의 효과성에 대한 심층 분석을 촉구합니다. 이 수준의 질문들은 독자가 단순히 정보를 회상하는 것을 넘어서 정보를 해석하고 평가하는 능력을 개발하도록 돕습니다.

**평가 및 추론 수준**은 LSAT 논리적 추론 섹션에서 영감을 받은 고급 비판적 사고 능력을 평가합니다. 논증 강화(Strengthen) 질문은 논증의 결론을 더 타당하게 만드는 정보를 식별하도록 요구하며, 논증 약화(Weaken) 질문은 결론의 타당성을 훼손하는 증거나 논증을 찾도록 합니다. 가정(Assumption) 질문은 논증이 성립하기 위해 반드시 참이어야 하는 전제를 파악하게 하고, 결함(Flaw) 질문은 논증의 추론 오류를 지적하도록 요구합니다. 추론(Inference) 질문은 제공된 정보로부터 논리적으로 도출되는 결론을 선택하게 하며, 원리 식별(Principle) 질문은 논증의 기저에 있는 일반 규칙이나 원리를 인식하도록 합니다. 추론 방법(Method of Reasoning) 질문은 논증이 논리적으로 어떻게 구성되었는지 설명하게 하고, 역설 해결(Resolve the Paradox) 질문은 겉보기에 모순되는 정보를 조화시키는 설명을 제시하도록 요구합니다.

이러한 계층적 구조는 독해 능력이 단순한 정보 추출에서 시작하여 점진적으로 복잡한 추론과 비판적 평가로 발전한다는 교육학적 원리를 반영합니다. 각 수준의 질문은 특정 인지 기술을 타겟팅하며, 전체적으로는 포괄적인 독해 능력 평가를 가능하게 합니다. 정제 플로우에서 제안자-편집자 에이전트 쌍은 이러한 질문들의 복잡도를 더욱 높여, 여러 텍스트 구절을 통합하거나, 암묵적 정보를 추론하거나, 미묘한 언어적 단서를 파악하도록 요구하는 고난이도 질문으로 발전시킵니다.

### 텍스트 수정 작업의 기능적 분류와 응용

텍스트 수정 플로우는 18개의 작업 유형을 다루며, 이들은 변환의 목적과 특성에 따라 네 가지 기능적 카테고리로 분류됩니다.

**의미 보존 변환 카테고리**는 원본의 핵심 의미를 유지하면서 표현 방식을 변경하는 작업들을 포함합니다. 패러프레이징은 동의어와 다른 문장 구조를 사용하여 의미를 보존하면서 표현을 바꾸며, 텍스트 단순화는 더 간단한 어휘와 문장 구조를 사용하여 가독성을 높입니다. 번역은 한 언어에서 다른 언어로 의미를 최대한 보존하면서 변환하며, 표절 재작성은 독창성을 보장하면서 내용을 재구성합니다. 이러한 작업들은 모델이 의미의 핵심을 파악하고 다양한 방식으로 표현하는 능력을 개발하도록 돕습니다.

**구조 및 형식 변환 카테고리**는 텍스트의 외형적 특성을 변경하는 작업들을 다룹니다. 형식 변환은 가독성이나 스타일을 위해 텍스트의 외관을 조정하고, 대문자화는 대소문자 규칙을 적용하며, 스타일링은 볼드체, 이탤릭체 등을 적용하여 특정 부분을 강조합니다. 데이터 정규화는 날짜, 시간, 철자 등을 표준 형식으로 통일합니다. 이러한 작업들은 모델이 콘텐츠의 의미를 변경하지 않으면서도 형식적 요구사항을 충족시키는 능력을 가르칩니다.

**내용 변환 및 확장 카테고리**는 텍스트의 의미나 범위를 변경하는 작업들을 포함합니다. 확장은 추가 정보나 세부 사항을 더하여 텍스트를 더 포괄적으로 만들고, 콘텐츠 재작성은 관점, 스타일, 대상 청중을 변경하여 새로운 버전을 생성합니다. 감정 수정은 텍스트의 감정적 톤을 변경하여 긍정적이거나 부정적으로 만들며, 주석 달기는 분석이나 추가 맥락을 위해 노트나 설명을 추가합니다. 이러한 작업들은 모델이 원본 콘텐츠를 기반으로 새로운 가치를 창출하는 능력을 개발하도록 합니다.

**특수 목적 변환 카테고리**는 특정한 목적이나 제약 조건을 가진 작업들을 다룹니다. 키워드 교체는 특정 단어나 구를 동의어나 관련 용어로 대체하고, 제거는 텍스트에서 특정 콘텐츠를 삭제하거나 편집합니다. 코드 스위칭은 텍스트 내에서 언어나 방언을 교대로 사용하며, 텍스트 난독화는 보안 목적으로 텍스트를 의도적으로 모호하게 만듭니다. 텍스트 함의는 한 문장이나 구를 다른 문장을 함의하거나 모순하도록 수정하며, 어휘 제한 재작성은 제한된 어휘만을 사용하여 텍스트를 다시 씁니다. 이러한 작업들은 모델이 특수한 제약 조건 하에서도 효과적으로 텍스트를 조작하는 능력을 가르칩니다.

이러한 기능적 분류는 텍스트 수정 작업의 다양성을 체계적으로 조직하며, 각 카테고리는 서로 다른 언어 처리 능력을 요구합니다. 정제 플로우에서는 여러 카테고리의 작업을 순차적으로 적용하거나, 상충하는 제약 조건을 동시에 만족시키도록 요구하여 복잡도를 높입니다. 예를 들어, "학술적 톤을 유지하면서 텍스트를 단순화하되, 핵심 전문 용어는 보존하고, 전체 길이는 원문의 80% 이내로 유지하시오"와 같은 다차원적 제약 조건을 가진 작업은 모델이 여러 목표를 동시에 최적화하는 능력을 개발하도록 돕습니다.

### 평가 방법론의 설계 원리와 작업 특성 매칭

부록 B는 서로 다른 작업 유형과 벤치마크에 대한 평가 방법론을 상세히 설명하며, 각 방법론은 평가 대상 작업의 특성에 맞게 설계되었습니다.

**객관식 질문 평가**는 GPT-4를 사용한 답안 추출 방식을 채택합니다. 모든 모델은 빈 시스템 메시지와 함께 개방형 생성 설정에서 평가되며, 모델의 응답으로부터 선택된 옵션을 추출하기 위해 정규 표현식 대신 GPT-4를 사용합니다. 이 접근법은 모델이 다양한 형식으로 답변을 제시할 수 있음을 고려하며, GPT-4의 언어 이해 능력을 활용하여 학생의 최종 답변을 정확하게 파싱합니다. 추출된 예측은 정답과 매칭되어 정확도 점수를 생성합니다.

**정확 일치 및 범위 추출 문제 평가**는 수학 기반 질문과 정답 값이 제공되는 작업에 대해 GPT-4를 사용하여 답안을 추출하고 정답과 매칭합니다. 수학 기반 질문(GSM8K 등)에는 전문화된 시스템 메시지가 사용되며, 다른 정확 일치 문제(DROP 등)에는 별도의 시스템 메시지가 사용됩니다. 수학 문제의 경우, 학생의 답안이 문제 출제자의 답안과 다른 방법으로 도출되었을 수 있음을 인정하면서도, 최종 답변(일반적으로 숫자)은 고유해야 하며 문제 출제자의 답변과 일치해야 한다는 원칙을 적용합니다.

**EQBench 평가**는 감성 지능을 측정하기 위해 모델이 대화에서 각 감정에 대한 점수를 생성하도록 프롬프트하고, GPT-4를 사용하여 모델의 응답에서 점수를 추출합니다. 메트릭 점수는 EQBench 논문과 제작자의 GitHub 저장소에 설명된 버전 1과 2 구현을 모두 사용하여 생성됩니다. 점수 계산은 0점이 무작위 답변에 해당하고 100점이 참조 답변과의 완벽한 일치를 나타내도록 보정됩니다. 이러한 보정은 감성 지능 평가의 상대적 성능을 명확하게 비교할 수 있게 합니다.

**개방형 생성 평가**는 정답과 매칭할 수 없는 작업들을 다룹니다. FoFo 벤치마크는 GPT-4(버전 0613)를 판단자로 사용하여 형식 정확도 점수를 0에서 1 사이로 제공하며, 1은 모델의 응답이 프롬프트에 지정된 형식을 엄격히 따른다는 것을 의미합니다. IFEval 벤치마크는 모델 응답이 프롬프트의 검증 가능한 인스트럭션을 따르는지 확인하며, 제작자가 제공한 코드를 사용합니다. MT-Bench는 첫 번째 턴 쿼리와 두 번째 턴 쿼리로 구성되며, GPT-4가 각 턴의 응답을 1에서 10까지 점수로 평가합니다. AlpacaEval은 강력한 LLM(GPT-4-turbo 버전 0613)이 평가된 모델의 출력을 참조 답변보다 선호하는 횟수인 승률을 측정합니다. InfoBench는 GPT-4(버전 1106-preview)를 판단자로 사용하여 모델 응답이 분해된 인스트럭션을 따르는지 결정합니다.

### 요약 품질 및 환각 평가의 이중 접근법

요약 능력은 품질과 환각이라는 두 가지 핵심 차원에서 평가되며, 각 차원은 서로 다른 평가 프롬프트와 메트릭을 사용합니다.

**품질 평가**는 인스트럭션 준수, 콘텐츠 근거, 전반적 품질의 세 가지 기준을 사용합니다. 인스트럭션 준수는 응답이 사용자 인스트럭션을 올바르게 따르는지 평가하며, 콘텐츠 근거는 답변이 인스트럭션에 근거하여 이미 존재하는 내용을 넘어서는 새로운 콘텐츠를 도입하지 않는지 확인합니다. 전반적 품질은 응답의 명확성, 일관성, 완전성을 평가합니다. GPT-4는 장단점을 강조하는 짧은 설명을 제공한 후, 1에서 10까지의 척도로 전반적 품질을 평가합니다. 이러한 다차원적 평가는 요약이 단순히 정보를 압축하는 것을 넘어서 사용자의 요구사항을 충족하고 원본에 충실하며 높은 품질을 유지하는지 종합적으로 판단합니다.

**환각 평가**는 생성된 요약에서 원본 기사에 의해 뒷받침되지 않는 정보를 식별합니다. GPT-4는 요약의 각 섹션을 검토하고, 기사에서 관련 사실을 추출하여 요약의 정확성을 검증하며, 각 섹션이 환각을 포함하는지 결정합니다. 최종 판정은 JSON 형식으로 출력되며, 환각이 감지되었는지 여부와 환각된 텍스트의 정확한 범위를 포함합니다. 이러한 구조화된 접근법은 환각의 존재 여부뿐만 아니라 정확한 위치까지 식별하여, 모델의 약점을 구체적으로 파악할 수 있게 합니다.

이러한 이중 접근법은 요약 능력의 두 가지 중요한 측면을 균형 있게 평가합니다. 높은 품질 점수는 요약이 잘 작성되고 유용하다는 것을 나타내지만, 낮은 환각 비율은 요약이 사실적으로 정확하다는 것을 보장합니다. 두 메트릭을 함께 사용함으로써, 모델이 유용하면서도 신뢰할 수 있는 요약을 생성하는 능력을 종합적으로 평가할 수 있습니다.
- - -
### References
* [AgentInstruct: Toward Generative Teaching with Agentic Flows](http://arxiv.org/pdf/2407.03502v1)