---
layout: post
title: "DeepSeek-V3.2: Pushing the Frontier of Open Large Language Models"
date: 2025-12-02 09:25:14
author: "DeepSeek-AI"
categories: ["Paper Reviews", "Language-Models"]
tags: ["DeepSeek-Sparse-Attention", "Scalable-Reinforcement-Learning-Framework", "Large-Scale-Agentic-Task-Synthesis-Pipeline", "Group-Relative-Policy-Optimization-Scaling", "Unbiased-KL-Estimate-for-RL", "Off-Policy-Sequence-Masking", "Keep-Routing-for-Mixture-of-Experts", "Thinking-Context-Management-for-Tool-Use", "Long-Chain-of-Thought-Cold-Start-Integration", "Multi-Stage-Agentic-Environment-Synthesis"]
cover: /assets/images/language-models.jpg
use_math: true
---
### TL;DR
#### 이 연구를 시작하게 된 배경과 동기는 무엇입니까?

대규모 언어 모델의 발전 과정에서 o1과 DeepSeek-R1과 같은 추론 모델의 등장은 중요한 전환점이 되었습니다. 이들 모델은 검증 가능한 분야에서 실질적인 성능 도약을 이루었으나, 최근 몇 개월 동안 뚜렷한 분기점이 나타났습니다. GPT-5, Claude-4.5-Sonnet, Gemini-3.0-Pro와 같은 폐쇄형 독점 모델들의 성능 궤적이 가파르게 가속화되는 반면, Qwen3, GLM, MiniMax-M2, k2-thinking 같은 개방형 커뮤니티 모델들의 진전은 상대적으로 완만해졌습니다. 결과적으로 폐쇄형 모델과 개방형 모델 간의 성능 격차가 수렴하기보다는 오히려 확대되고 있으며, 독점 시스템들은 복잡한 작업에서 점점 더 우수한 능력을 보여주고 있습니다.

연구팀의 분석을 통해 복잡한 작업에서 개방형 모델의 능력을 제한하는 세 가지 핵심 결함이 확인되었습니다. 첫째, 아키텍처 측면에서 바닐라 어텐션 메커니즘에 대한 지배적인 의존은 긴 시퀀스에 대한 효율성을 심각하게 제약하며, 이러한 비효율성은 확장 가능한 배포와 효과적인 사후 훈련 모두에 상당한 장애물이 됩니다. 둘째, 자원 할당 측면에서 개방형 모델은 사후 훈련 단계에서 불충분한 계산 투자로 인해 어려운 작업에서의 성능이 제한됩니다. 마지막으로 AI 에이전트의 맥락에서 개방형 모델은 독점 모델에 비해 일반화 및 명령 수행 능력에서 현저한 지연을 보이며, 실제 배포에서의 효과성을 저해합니다. 이러한 핵심 한계들을 체계적으로 해결하기 위해 DeepSeek-V3.2 연구가 시작되었습니다.

#### 이 연구에서 제시하는 새로운 해결 방법은 무엇입니까?

DeepSeek-V3.2는 세 가지 주요 기술적 혁신을 통해 개방형 모델의 한계를 극복하고자 합니다. 첫 번째 혁신은 **DeepSeek Sparse Attention(DSA)**의 도입으로, 이는 긴 문맥 시나리오에서 모델 성능을 유지하면서도 계산 복잡도를 대폭 감소시키는 효율적인 어텐션 메커니즘입니다. 기존의 어텐션 메커니즘이 시퀀스 길이의 제곱에 비례하는 O(L²)의 계산량을 요구했다면, DSA는 이를 선택된 토큰 수에 비례하는 O(Lk)로 감소시켜 장문 처리의 효율성을 획기적으로 개선합니다. DSA는 lightning indexer와 fine-grained token selection이라는 두 가지 핵심 구성 요소로 이루어져 있으며, lightning indexer는 쿼리 토큰이 어떤 이전 토큰들을 선택해야 하는지를 빠르게 결정하는 경량 스코어링 시스템입니다.

두 번째 혁신은 **확장 가능한 강화학습 프레임워크의 구축**입니다. 견고한 강화학습 프로토콜을 구현하고 사후 훈련 단계의 계산 자원을 대폭 확장함으로써, DeepSeek-V3.2는 GPT-5와 비견되는 성능을 달성했습니다. 특히 주목할 점은 고성능 변형 모델인 DeepSeek-V3.2-Speciale이 GPT-5를 능가하며 Gemini-3.0-Pro와 동등한 수준의 추론 능력을 보여준다는 것입니다. 이 모델은 2025년 국제 수학 올림피아드(IMO)와 국제 정보 올림피아드(IOI) 모두에서 금메달 수준의 성과를 거두었으며, 사전 훈련 비용의 10%를 초과하는 사후 훈련 계산 예산을 할당하여 고급 능력을 발휘합니다.

세 번째 혁신은 **대규모 에이전트 작업 합성 파이프라인의 개발**입니다. 추론 능력을 도구 사용 시나리오에 통합하기 위해, 연구팀은 체계적으로 대규모 훈련 데이터를 생성하는 새로운 파이프라인을 개발했습니다. 먼저 DeepSeek-V3 방법론을 활용한 콜드 스타트 단계를 구현하여 단일 궤적 내에서 추론과 도구 사용을 통합하고, 이후 1,800개 이상의 고유한 환경과 85,000개의 복잡한 프롬프트를 생성하는 대규모 에이전트 작업 합성으로 진행합니다. 이러한 광범위한 합성 데이터는 강화학습 프로세스를 주도하여 에이전트 맥락에서 모델의 일반화 및 명령 수행 능력을 크게 향상시킵니다.

#### 제안된 방법은 어떻게 구현되었습니까?

**DeepSeek Sparse Attention의 구현**은 MLA(Multi-Latent Attention) 기반 구조 하에서 이루어졌습니다. Lightning indexer는 쿼리 토큰 **h**_t와 이전 토큰 **h**_s 사이의 인덱스 스코어 I_{t,s}를 계산하며, 이는 다음 수식으로 정의됩니다. I_{t,s} = Σ_{j=1}^{H^I} w_{t,j}^I · ReLU(**q**^I_{t,j} · **k**^I_s). 여기서 H^I는 indexer 헤드의 개수이고, ReLU 활성화 함수는 처리량 최적화를 고려하여 선택되었습니다. Lightning indexer는 적은 수의 헤드를 사용하고 FP8 정밀도로 구현되어 계산 효율성이 매우 뛰어납니다. 인덱스 스코어가 계산되면, fine-grained token selection 메커니즘이 top-k 인덱스 스코어에 해당하는 키-밸류 항목들만을 선별적으로 검색하여 어텐션 연산에 활용합니다.

**지속적 사전 훈련**은 두 개의 훈련 단계로 구성됩니다. 첫 번째 단계인 Dense Warm-up 단계에서는 lightning indexer를 초기화하는 짧은 워밍업 과정을 수행하며, 이 단계에서는 dense attention을 유지하면서 lightning indexer를 제외한 모든 모델 파라미터를 동결합니다. Indexer의 출력을 주요 어텐션 분포와 정렬하기 위해 KL-divergence 손실이 훈련 목표로 설정되며, 학습률 10^-3이 사용되고 indexer는 단 1000 스텝 동안만 훈련됩니다. 두 번째 단계인 Sparse Training 단계에서는 indexer 워밍업 이후 fine-grained token selection 메커니즘을 도입하고 모든 모델 파라미터를 최적화하여 DSA의 sparse 패턴에 모델을 적응시킵니다. 이 단계에서는 학습률 7.3×10^-6이 사용되며, 각 쿼리 토큰에 대해 2048개의 키-밸류 토큰이 선택되고 15000 스텝 동안 훈련됩니다.

**사후 훈련 단계**는 전문가 증류와 혼합 강화학습 훈련으로 구성됩니다. 모든 전문가 모델은 동일한 사전 훈련된 DeepSeek-V3.2 기본 체크포인트로부터 파인튜닝되며, 수학, 프로그래밍, 일반 논리적 추론, 일반 에이전트 작업, 에이전트 코딩, 에이전트 검색의 여섯 가지 전문 도메인을 포괄합니다. 강화학습 훈련 알고리즘으로는 Group Relative Policy Optimization(GRPO)을 채택하며, 추론, 에이전트, 인간 정렬 훈련을 단일 강화학습 단계로 통합합니다. 보상 메커니즘은 작업 유형에 따라 차별화되는데, 추론 및 에이전트 작업에는 규칙 기반 결과 보상, 길이 페널티, 언어 일관성 보상을 적용하고, 일반 작업에는 생성형 보상 모델을 사용합니다.

**GRPO 확장을 위한 안정화 전략**은 세 가지 핵심 기법을 포함합니다. 첫째, 편향 없는 KL 추정을 위해 K3 추정자를 수정하여 현재 정책과 이전 정책 간의 중요도 샘플링 비율을 사용한 편향 없는 KL 추정값을 얻습니다. 둘째, 오프 폴리시 시퀀스 마스킹을 도입하여 데이터 샘플링 정책과 현재 정책 간의 KL 발산으로 측정되는 상당한 정책 분기를 도입하는 부정적 시퀀스를 마스킹합니다. 셋째, Keep Routing을 통해 추론 프레임워크에서 샘플링 중 사용된 전문가 라우팅 경로를 보존하고 훈련 중에도 동일한 라우팅 경로를 강제하여 MoE 모델의 안정성을 확보합니다.

**도구 사용에서의 사고 통합**은 사고 컨텍스트 관리, 콜드 스타트 메커니즘, 대규모 에이전트 작업 합성으로 구성됩니다. 사고 컨텍스트 관리에서는 과거 추론 콘텐츠를 대화에 새로운 사용자 메시지가 도입될 때만 폐기하며, 도구 관련 메시지만 추가되는 경우 추론 콘텐츠를 상호작용 전반에 걸쳐 유지합니다. 콜드 스타트 메커니즘은 추론 데이터와 비추론 에이전트 데이터를 신중하게 설계된 프롬프팅을 통해 통합하며, 모델이 명시적인 지시사항을 정확하게 따를 수 있는 능력을 활용합니다. 대규모 에이전트 작업 합성은 검색 에이전트, 코드 에이전트, 코드 인터프리터 에이전트, 일반 에이전트의 네 가지 범주로 구성되며, 각각 실제 또는 합성 환경과 프롬프트를 활용하여 총 85,267개의 훈련 인스턴스를 생성합니다.

#### 이 연구의 결과가 가지는 의미는 무엇입니까?

**성능 평가 결과**는 DeepSeek-V3.2가 추론, 코딩, 수학, 에이전트 작업을 포괄하는 18개의 벤치마크에서 뛰어난 성능을 달성했음을 보여줍니다. 추론 작업에서 DeepSeek-V3.2는 MMLU-Pro에서 85.0%, GPQA Diamond에서 82.4%의 정확도를 기록했으며, 코딩 작업에서는 LiveCodeBench에서 83.3%, Codeforces에서 2386의 레이팅을 달성했습니다. 수학 작업에서는 AIME 2025에서 93.1%, HMMT Feb 2025에서 92.5%의 통과율을 기록했으며, 코드 에이전트 평가에서는 Terminal Bench 2.0에서 46.4%, SWE Verified에서 73.1%의 성능을 보였습니다. 특히 주목할 점은 DeepSeek-V3.2가 개방형 모델의 에이전트 능력을 크게 발전시켜, MCP-Mark, MCP-Universe, Tool-Decathlon에서 소개된 롱테일 에이전트 작업에서 탁월한 숙련도를 보여주었다는 것입니다.

**DeepSeek-V3.2-Speciale의 성과**는 확장된 사고의 잠재력을 입증합니다. 이 모델은 감소된 길이 페널티를 적용하여 더 긴 추론 과정을 생성할 수 있으며, AIME 2025에서 96.0%, HMMT Feb 2025에서 99.2%, HMMT Nov 2025에서 94.4%의 통과율을 달성했습니다. 특히 IMOAnswerBench에서 84.5%, LiveCodeBench에서 88.7%, Codeforces에서 2701의 레이팅을 기록하여 최첨단 Gemini-3.0-Pro를 능가하는 성능을 보였습니다. 2025년 국제 수학 올림피아드(IMO)에서 35/42점으로 금메달을 획득했으며, 국제 정보 올림피아드(IOI)에서 492/600점으로 금메달을, ICPC 세계 결선에서 10/12점으로 금메달을 기록했습니다. 이러한 결과는 개방형 모델이 충분한 계산 자원과 적절한 훈련 전략을 갖추면 최첨단 폐쇄형 모델과 경쟁할 수 있음을 명확히 보여줍니다.

**계산 효율성의 개선**은 DSA의 실질적 가치를 입증합니다. H800 클러스터에서의 벤치마킹 결과, 128K 토큰 위치에서 DeepSeek-V3.2는 프리필링 비용으로 백만 토큰당 약 0.14 USD를 나타내는 반면 DeepSeek-V3.1-Terminus는 약 0.55 USD에 달해 약 4배의 비용 차이를 보입니다. 디코딩 비용에서도 유사한 패턴이 관찰되며, 128K 토큰 위치에서 DeepSeek-V3.2는 백만 토큰당 약 0.27 USD의 디코딩 비용을 보이는 반면 DeepSeek-V3.1-Terminus는 약 1.18 USD로 약 4.4배의 차이를 나타냅니다. 이러한 비용 절감은 최적화된 구현과 결합된 DSA의 효율성 덕분이며, 긴 문맥 시나리오에서 상당한 엔드-투-엔드 속도 향상을 달성합니다.

**한계와 향후 연구 방향**은 지속적인 개선의 필요성을 강조합니다. 첫째, 총 훈련 FLOPs가 적기 때문에 DeepSeek-V3.2의 세계 지식의 폭은 여전히 선도적인 독점 모델에 비해 뒤처져 있으며, 향후 반복 개발에서 사전 훈련 계산을 확장하여 이러한 지식 격차를 해결할 계획입니다. 둘째, 토큰 효율성은 여전히 도전 과제로 남아있으며, DeepSeek-V3.2는 일반적으로 Gemini-3.0-Pro와 같은 모델의 출력 품질과 일치하기 위해 더 긴 생성 궤적을 필요로 합니다. 향후 연구는 모델의 추론 체인의 지능 밀도를 최적화하여 효율성을 개선하는 데 초점을 맞출 것입니다. 셋째, 복잡한 작업을 해결하는 능력은 여전히 최첨단 모델에 비해 열등하며, 이는 파운데이션 모델과 사후 훈련 레시피를 더욱 정제하도록 동기를 부여합니다. 이러한 한계들은 개방형 모델 개발의 현재 상태를 반영하는 동시에, 향후 연구의 명확한 방향을 제시하며, 개방형 모델이 최첨단 폐쇄형 모델과의 격차를 더욱 좁히기 위한 핵심 영역들을 지적합니다.
- - -
# DeepSeek-V3.2: 개방형 대규모 언어 모델의 새로운 지평

## 초록

DeepSeek-V3.2는 높은 계산 효율성과 뛰어난 추론 및 에이전트 성능을 조화롭게 결합한 대규모 언어 모델입니다. 이 모델의 핵심 기술적 혁신은 세 가지 주요 영역에서 이루어졌습니다.

첫 번째 혁신은 DeepSeek Sparse Attention(DSA)의 도입입니다. DSA는 긴 문맥 시나리오에서 모델 성능을 유지하면서도 계산 복잡도를 대폭 감소시키는 효율적인 어텐션 메커니즘입니다. 기존의 어텐션 메커니즘이 시퀀스 길이의 제곱에 비례하는 계산량을 요구했다면, DSA는 이를 선형에 가깝게 줄여 장문 처리의 효율성을 획기적으로 개선했습니다.

두 번째 혁신은 확장 가능한 강화학습 프레임워크의 구축입니다. 견고한 강화학습 프로토콜을 구현하고 사후 훈련 단계의 계산 자원을 대폭 확장함으로써, DeepSeek-V3.2는 [GPT-5](https://openai.com/index/introducing-gpt-5-and-gpt-5-mini/)와 비견되는 성능을 달성했습니다. 특히 주목할 점은 고성능 변형 모델인 DeepSeek-V3.2-Speciale가 GPT-5를 능가하며, [Gemini-3.0-Pro](https://blog.google/technology/google-deepmind/google-gemini-ai-update-march-2025/)와 동등한 수준의 추론 능력을 보여준다는 것입니다. 이 모델은 2025년 국제 수학 올림피아드(IMO)와 국제 정보 올림피아드(IOI) 모두에서 금메달 수준의 성과를 거두었습니다.

세 번째 혁신은 대규모 에이전트 작업 합성 파이프라인의 개발입니다. 추론 능력을 도구 사용 시나리오에 통합하기 위해, 연구팀은 체계적으로 대규모 훈련 데이터를 생성하는 새로운 합성 파이프라인을 개발했습니다. 이 방법론은 확장 가능한 에이전트 사후 훈련을 가능하게 하여, 복잡하고 상호작용적인 환경에서 일반화 능력과 명령 수행의 견고성을 크게 향상시켰습니다.

![DeepSeek-V3.2 벤치마크 비교](https://arxiv.org/html/2512.02556/x1.png)

위 그림은 DeepSeek-V3.2와 주요 경쟁 모델들의 성능을 다양한 추론 및 에이전트 능력 벤치마크에서 비교한 결과를 보여줍니다. DeepSeek-V3.2-Speciale, DeepSeek-V3.2-Thinking, GPT-5-High, Claude-4.5-Sonnet, Gemini-3.0-Pro 등의 모델이 AIMF 2025, HMMT 2023, HLE, Codeforces, SWE, Terminal Bench 2.0, Tool Decathlon과 같은 다양한 작업에서 평가되었습니다. 이러한 비교 평가는 각 모델의 강점과 약점을 이해하는 데 중요한 의미를 가지며, DeepSeek-V3.2가 개방형 모델로서 최첨단 폐쇄형 모델들과 경쟁할 수 있는 수준에 도달했음을 보여줍니다.

## 서론

[o1](https://openai.com/index/learning-to-reason-with-llms/)과 [DeepSeek-R1](https://arxiv.org/pdf/2501.12948v2)과 같은 추론 모델의 등장은 대규모 언어 모델의 진화에서 중요한 전환점이 되었습니다. 이러한 모델들은 검증 가능한 분야에서 전반적인 성능의 실질적인 도약을 촉발했습니다. 이 이정표 이후 대규모 언어 모델의 능력은 빠르게 발전해왔습니다. 그러나 최근 몇 달 동안 뚜렷한 분기점이 나타났습니다. [Qwen3](https://arxiv.org/pdf/2501.12948v2), [GLM](https://arxiv.org/pdf/2501.12948v2), [MiniMax-M2](https://arxiv.org/pdf/2501.12948v2), [k2-thinking](https://arxiv.org/pdf/2501.12948v2)과 같은 개방형 커뮤니티가 계속해서 진전을 이루고 있는 반면, GPT-5, Claude-4.5-Sonnet, Gemini-3.0-Pro와 같은 폐쇄형 독점 모델의 성능 궤적은 훨씬 더 가파른 속도로 가속화되었습니다. 결과적으로 폐쇄형 모델과 개방형 모델 간의 성능 격차는 수렴하기보다는 오히려 확대되고 있으며, 독점 시스템들은 복잡한 작업에서 점점 더 우수한 능력을 보여주고 있습니다.

연구팀의 분석을 통해 복잡한 작업에서 개방형 모델의 능력을 제한하는 세 가지 핵심 결함이 확인되었습니다. 첫째, 아키텍처 측면에서 [바닐라 어텐션](https://arxiv.org/pdf/1706.03762v7) 메커니즘에 대한 지배적인 의존은 긴 시퀀스에 대한 효율성을 심각하게 제약합니다. 이러한 비효율성은 확장 가능한 배포와 효과적인 사후 훈련 모두에 상당한 장애물이 됩니다. 둘째, 자원 할당 측면에서 개방형 모델은 사후 훈련 단계에서 불충분한 계산 투자로 인해 어려운 작업에서의 성능이 제한됩니다. 마지막으로 AI 에이전트의 맥락에서 개방형 모델은 독점 모델에 비해 일반화 및 명령 수행 능력에서 현저한 지연을 보이며, 실제 배포에서의 효과성을 저해합니다.

이러한 핵심 한계를 해결하기 위해 연구팀은 먼저 계산 복잡도를 대폭 줄이도록 설계된 고효율 어텐션 메커니즘인 DSA를 도입했습니다. 이 아키텍처는 효율성 병목 현상을 효과적으로 해결하며, 긴 문맥 시나리오에서도 모델 성능을 유지합니다. 둘째, 사후 훈련 단계에서 상당한 계산 확장을 가능하게 하는 안정적이고 확장 가능한 강화학습 프로토콜을 개발했습니다. 특히 이 프레임워크는 사전 훈련 비용의 10%를 초과하는 사후 훈련 계산 예산을 할당하여 고급 능력을 발휘합니다. 셋째, 도구 사용 시나리오에서 일반화 가능한 추론을 촉진하는 새로운 파이프라인을 제안했습니다. 먼저 [DeepSeek-V3](https://arxiv.org/pdf/2412.19437v2) 방법론을 활용한 콜드 스타트 단계를 구현하여 단일 궤적 내에서 추론과 도구 사용을 통합합니다. 이후 1,800개 이상의 고유한 환경과 85,000개의 복잡한 프롬프트를 생성하는 대규모 에이전트 작업 합성으로 진행합니다. 이러한 광범위한 합성 데이터는 강화학습 프로세스를 주도하여 에이전트 맥락에서 모델의 일반화 및 명령 수행 능력을 크게 향상시킵니다.

DeepSeek-V3.2는 여러 추론 벤치마크에서 Kimi-k2-thinking 및 GPT-5와 유사한 성능을 달성합니다. 더욱이 DeepSeek-V3.2는 개방형 모델의 에이전트 능력을 크게 발전시켜, MCP-Mark, MCP-Universe, Tool-Decathlon에서 소개된 롱테일 에이전트 작업에서 탁월한 숙련도를 보여줍니다. DeepSeek-V3.2는 에이전트 시나리오에서 매우 비용 효율적인 대안으로 부상하며, 훨씬 낮은 비용으로 개방형 모델과 최첨단 독점 모델 간의 성능 격차를 크게 좁혔습니다. 특히 추론 영역에서 개방형 모델의 한계를 넓히기 위해 길이 제약을 완화하여 DeepSeek-V3.2-Speciale을 개발했습니다. 그 결과 DeepSeek-V3.2-Speciale은 선도적인 폐쇄형 시스템인 Gemini-3.0-Pro와 성능 동등성을 달성했습니다. 이 모델은 IOI 2025, ICPC World Final 2025, IMO 2025, CMO 2025에서 금메달 수준의 성과를 보여줍니다.
## DeepSeek-V3.2 아키텍처

### DeepSeek Sparse Attention의 기술적 혁신

DeepSeek-V3.2는 DeepSeek-V3.2-Exp와 정확히 동일한 아키텍처를 사용하며, 이전 버전인 DeepSeek-V3.1-Terminus와 비교할 때 유일한 아키텍처 수정 사항은 지속적 훈련을 통한 DeepSeek Sparse Attention(DSA)의 도입입니다. DSA는 어텐션 메커니즘의 계산 복잡도를 시퀀스 길이의 제곱인 O(L²)에서 선택된 토큰 수에 비례하는 O(Lk)로 감소시킵니다. 여기서 k는 L보다 훨씬 작은 값으로, 긴 문맥 처리의 효율성을 획기적으로 개선합니다.

#### Lightning Indexer와 토큰 선택의 이중 메커니즘

DSA의 프로토타입은 두 가지 핵심 구성 요소로 이루어져 있습니다. 첫 번째는 lightning indexer로, 이는 쿼리 토큰이 어떤 이전 토큰들을 선택해야 하는지를 빠르게 결정하는 경량 스코어링 시스템입니다. 두 번째는 fine-grained token selection 메커니즘으로, indexer가 계산한 스코어를 기반으로 실제로 키-밸류 항목들을 선별하여 어텐션 연산에 활용합니다.

Lightning indexer는 쿼리 토큰 $\mathbf{h}_{t}\in\mathbb{R}^{d}$와 이전 토큰 $\mathbf{h}_{s}\in\mathbb{R}^{d}$ 사이의 인덱스 스코어 $I_{t,s}$를 계산합니다. 이 스코어는 다음 수식으로 정의됩니다.

$$I_{t,s}=\sum_{j=1}^{H^{I}}w_{t,j}^{I}\cdot\text{ReLU}\left(\mathbf{q}^{I}_{t,j}\cdot\mathbf{k}^{I}_{s}\right)$$

이 수식에서 $H^{I}$는 indexer 헤드의 개수를 나타내며, $\mathbf{q}^{I}_{t,j}\in\mathbb{R}^{d^{I}}$와 $w_{t,j}^{I}\in\mathbb{R}$는 쿼리 토큰 $\mathbf{h}_{t}$로부터 유도된 쿼리 벡터와 가중치입니다. $\mathbf{k}^{I}_{s}\in\mathbb{R}^{d^{I}}$는 이전 토큰 $\mathbf{h}_{s}$로부터 유도된 키 벡터입니다. 활성화 함수로 ReLU를 선택한 이유는 처리량(throughput) 최적화를 고려한 것으로, ReLU는 계산적으로 단순하면서도 효과적인 비선형성을 제공합니다. 특히 lightning indexer는 적은 수의 헤드를 사용하고 FP8 정밀도로 구현될 수 있어, 계산 효율성이 매우 뛰어납니다. FP8은 8비트 부동소수점 표현으로, 기존의 FP16이나 FP32에 비해 메모리 사용량과 연산량을 대폭 줄이면서도 충분한 정밀도를 유지합니다.

인덱스 스코어 $\{I_{t,s}\}$가 각 쿼리 토큰 $\mathbf{h}_{t}$에 대해 계산되면, fine-grained token selection 메커니즘이 작동합니다. 이 메커니즘은 top-k 인덱스 스코어에 해당하는 키-밸류 항목들 $\{\mathbf{c}_{s}\}$만을 선별적으로 검색합니다. 선별된 토큰들과 쿼리 토큰 사이에 어텐션 메커니즘을 적용하여 최종 어텐션 출력 $\mathbf{u}_{t}$가 계산됩니다.

$$\mathbf{u}_{t}=\text{Attn}\quantity(\mathbf{h}_{t},\quantity{\mathbf{c}_{s}\,\middle|\,I_{t,s}\in\text{Top-k}\quantity(I_{t,:})})$$

이러한 선택적 접근 방식은 모든 이전 토큰에 대해 전체 어텐션을 계산하는 대신, 가장 관련성이 높은 토큰들에만 집중함으로써 계산 복잡도를 선형에 가깝게 줄입니다.

![DeepSeek-V3.2 어텐션 아키텍처](https://arxiv.org/html/2512.02556/x2.png)

위 그림은 DeepSeek-V3.2의 어텐션 아키텍처를 보여줍니다. MLA(Multi-Latent Attention) 구조 하에서 DSA가 어떻게 구현되는지를 시각적으로 나타내고 있으며, 녹색 부분은 DSA가 indexer를 통해 top-k 키-밸류 항목들을 선택하는 과정을 보여줍니다. 그림에는 Core Attention(Multi-Query Attention) 모듈, Top-k Selector, 그리고 Lightning Indexer의 세 가지 주요 구성 요소와 이들 간의 데이터 흐름이 명확하게 표시되어 있습니다.

#### MLA 기반 구현의 커널 수준 최적화

DeepSeek-V3.1-Terminus로부터의 지속적 훈련을 고려하여, 연구팀은 MLA를 기반으로 DSA를 구현했습니다. 커널 수준에서 각 키-밸류 항목은 여러 쿼리들 간에 공유되어야 계산 효율성을 확보할 수 있습니다. 이러한 제약으로 인해 DSA는 MLA의 MQA(Multi-Query Attention) 모드를 기반으로 구현되었으며, 이 모드에서는 각 latent vector(MLA의 키-밸류 항목)가 쿼리 토큰의 모든 쿼리 헤드들 간에 공유됩니다.

MLA의 MQA 모드와 MHA 모드의 차이는 부록에 상세히 설명되어 있으며, 연구팀은 DeepSeek-V3.2의 오픈소스 구현을 제공하여 세부 사항을 명확하게 공개했습니다. 이 구현은 https://huggingface.co/deepseek-ai/DeepSeek-V3.2-Exp/tree/main/inference 에서 확인할 수 있으며, 실제 프로덕션 환경에서 어떻게 DSA가 최적화되어 실행되는지를 상세히 보여줍니다.

#### 지속적 사전 훈련의 이단계 전략

DeepSeek-V3.1-Terminus의 기본 체크포인트로부터 시작하여, 이 모델은 이미 128K 컨텍스트 길이로 확장된 상태입니다. DeepSeek-V3.2를 생성하기 위해 지속적 사전 훈련과 사후 훈련이 수행되었으며, 지속적 사전 훈련은 두 개의 훈련 단계로 구성됩니다. 두 단계 모두에서 훈련 데이터의 분포는 DeepSeek-V3.1-Terminus의 128K 긴 문맥 확장 데이터와 완전히 일치합니다.

첫 번째 단계는 Dense Warm-up 단계로, lightning indexer를 초기화하는 짧은 워밍업 과정입니다. 이 단계에서는 dense attention을 유지하면서 lightning indexer를 제외한 모든 모델 파라미터를 동결합니다. Indexer의 출력을 주요 어텐션 분포와 정렬하기 위해, $t$번째 쿼리 토큰에 대해 먼저 모든 어텐션 헤드들의 주요 어텐션 스코어를 합산합니다. 이 합계는 시퀀스 차원을 따라 L1 정규화되어 목표 분포 $p_{t,:}\in\mathbb{R}^{t}$를 생성합니다. 이 목표 분포를 기반으로 KL-divergence 손실이 indexer의 훈련 목표로 설정됩니다.

$$\mathcal{L}^{I}=\sum_{t}\mathbb{D}_{\mathrm{KL}}\left(p_{t,:}\,\middle\|\,\text{Softmax}\quantity({I}_{t,:})\right)$$

이 손실 함수는 indexer가 계산한 스코어의 소프트맥스 분포가 실제 어텐션 분포와 얼마나 일치하는지를 측정합니다. KL-divergence는 두 확률 분포 간의 차이를 정량화하는 정보 이론적 척도로, 0에 가까울수록 두 분포가 유사함을 의미합니다. 워밍업을 위해 학습률 $10^{-3}$이 사용되며, indexer는 단 1000 스텝 동안만 훈련됩니다. 각 스텝은 128K 토큰으로 구성된 16개의 시퀀스를 포함하여, 총 2.1B 토큰에 해당합니다.

두 번째 단계는 Sparse Training 단계로, indexer 워밍업 이후 fine-grained token selection 메커니즘을 도입하고 모든 모델 파라미터를 최적화하여 DSA의 sparse 패턴에 모델을 적응시킵니다. 이 단계에서도 indexer 출력을 주요 어텐션 분포와 계속 정렬하지만, 선택된 토큰 집합 $\mathcal{S}_{t}=\quantity{s\,\middle|\,I_{t,s}\in\text{Top-k}\quantity(I_{t,:})}$만을 고려합니다.

$$\mathcal{L}^{I}=\sum_{t}\mathbb{D}_{\mathrm{KL}}\left(p_{t,\mathcal{S}_{t}}\,\middle\|\,\text{Softmax}\quantity(I_{t,\mathcal{S}_{t}})\right)$$

이 수식은 dense 단계와 달리 선택된 토큰들에 대해서만 분포 일치를 수행한다는 점에서 차별화됩니다. 주목할 점은 indexer 입력을 계산 그래프에서 분리(detach)하여 별도로 최적화한다는 것입니다. Indexer의 훈련 신호는 오직 $\mathcal{L}^{I}$로부터만 오며, 주요 모델의 최적화는 언어 모델링 손실에 따라서만 이루어집니다. 이러한 분리된 최적화 전략은 indexer와 주요 모델이 서로 다른 목표를 추구하면서도 협력적으로 작동할 수 있게 합니다.

Sparse training 단계에서는 학습률 $7.3\times 10^{-6}$이 사용되며, 각 쿼리 토큰에 대해 2048개의 키-밸류 토큰이 선택됩니다. 주요 모델과 indexer 모두 15000 스텝 동안 훈련되며, 각 스텝은 128K 토큰으로 구성된 480개의 시퀀스를 포함하여 총 943.7B 토큰에 해당합니다. 이는 워밍업 단계의 약 450배에 달하는 훈련량으로, 모델이 sparse attention 패턴에 충분히 적응할 수 있도록 합니다.

### 성능 동등성 검증

2025년 9월, DeepSeek-V3.2-Exp는 다양한 능력에 초점을 맞춘 벤치마크 모음에서 평가되었습니다. DeepSeek-V3.1-Terminus와 비교한 결과, DSA가 긴 시퀀스에서 계산 효율성을 크게 개선하면서도 짧은 문맥 및 긴 문맥 작업 모두에서 실질적인 성능 저하가 관찰되지 않았습니다.

인간 선호도 평가는 본질적으로 편향에 취약하기 때문에, 연구팀은 ChatbotArena를 간접 평가 프레임워크로 활용하여 새로 개발된 기본 모델에 대한 사용자 선호도를 근사했습니다. DeepSeek-V3.1-Terminus와 DeepSeek-V3.2-Exp는 동일한 사후 훈련 전략을 공유하며, 2025년 11월 10일에 수행된 평가에서 얻은 Elo 점수가 밀접하게 일치했습니다. 이러한 결과는 sparse attention 메커니즘을 통합했음에도 불구하고 새로운 기본 모델이 이전 버전과 동등한 성능을 달성했음을 시사합니다.

DeepSeek-V3.2-Exp가 출시된 후, 이전에 공개되지 않은 테스트 세트를 사용한 여러 독립적인 긴 문맥 평가가 수행되었습니다. 대표적인 벤치마크는 [AA-LCR](https://artificialanalysis.ai/evaluations/artificial-analysis-long-context-reasoning)로, 여기서 DeepSeek-V3.2-Exp는 추론 모드에서 DeepSeek-V3.1-Terminus보다 4점 높은 점수를 기록했습니다. [Fiction.liveBench 평가](https://fiction.live/stories/Fiction-liveBench-April-6-2025/oQdzQvKHw8JyXbN87)에서도 DeepSeek-V3.2-Exp는 여러 메트릭에서 DeepSeek-V3.1-Terminus를 일관되게 능가했습니다. 이러한 증거는 DeepSeek-V3.2-Exp의 기본 체크포인트가 긴 문맥 작업에서 성능 저하를 보이지 않았음을 나타냅니다.

### 추론 비용 분석

![프리필링 비용](https://arxiv.org/html/2512.02556/x3.png)

![디코딩 비용](https://arxiv.org/html/2512.02556/x4.png)

위 그래프들은 H800 클러스터에서 DeepSeek-V3.1-Terminus와 DeepSeek-V3.2의 추론 비용이 시퀀스 내 토큰 위치에 따라 어떻게 변화하는지를 보여줍니다. 이러한 비용은 GPU 시간당 2 USD의 대여 가격으로 H800 GPU에 배포된 실제 서비스를 벤치마킹하여 추정되었습니다. 짧은 시퀀스 프리필링의 경우, 연구팀은 DSA를 시뮬레이션하는 masked MHA 모드를 특별히 구현했으며, 이는 짧은 문맥 조건에서 더 높은 효율성을 달성할 수 있습니다.

프리필링 그래프에서 볼 수 있듯이, 토큰 위치가 증가함에 따라 DeepSeek-V3.1-Terminus의 비용은 가파르게 상승하는 반면, DeepSeek-V3.2는 훨씬 완만한 증가 곡선을 보입니다. 128K 토큰 위치에서 DeepSeek-V3.2는 백만 토큰당 약 0.14 USD의 비용을 나타내는 반면, DeepSeek-V3.1-Terminus는 약 0.55 USD에 달해 약 4배의 비용 차이를 보입니다.

디코딩 그래프에서도 유사한 패턴이 관찰되며, 긴 문맥에서 DeepSeek-V3.2의 비용 효율성이 더욱 두드러집니다. 128K 토큰 위치에서 DeepSeek-V3.2는 백만 토큰당 약 0.27 USD의 디코딩 비용을 보이는 반면, DeepSeek-V3.1-Terminus는 약 1.18 USD로 약 4.4배의 차이를 나타냅니다. 이러한 비용 절감은 최적화된 구현과 결합된 DSA의 효율성 덕분이며, 긴 문맥 시나리오에서 상당한 엔드-투-엔드 속도 향상을 달성합니다.
## 사후 훈련

DeepSeek-V3.2의 사후 훈련 단계는 지속적 사전 훈련을 완료한 기본 체크포인트를 최종 모델로 발전시키는 핵심 과정입니다. 이 단계에서도 지속적 사전 훈련과 동일한 방식으로 sparse attention을 적용하며, DeepSeek-V3.2-Exp와 동일한 파이프라인을 유지합니다.

### 전문가 증류를 통한 도메인 특화 모델 개발

사후 훈련의 첫 번째 단계는 각 과제 영역에 대한 전문가 모델을 개발하는 것입니다. 모든 전문가 모델은 동일한 사전 훈련된 DeepSeek-V3.2 기본 체크포인트로부터 파인튜닝되어, 일관된 기반 위에서 도메인 특화 능력을 발전시킵니다. 전문가 모델 프레임워크는 작문 작업과 일반 질의응답 외에도 여섯 가지 전문 도메인을 포괄합니다. 이 도메인들은 수학(mathematics), 프로그래밍(programming), 일반 논리적 추론(general logical reasoning), 일반 에이전트 작업(general agentic tasks), 에이전트 코딩(agentic coding), 그리고 에이전트 검색(agentic search)입니다. 주목할 점은 모든 도메인이 사고 모드(thinking mode)와 비사고 모드(non-thinking mode)를 동시에 지원한다는 것입니다.

각 전문가 모델의 훈련 과정은 대규모 강화학습 컴퓨팅 자원을 활용합니다. 특히 연구팀은 긴 추론 체인(long chain-of-thought reasoning)을 위한 사고 모드와 직접적인 응답 생성을 위한 비사고 모드에 서로 다른 모델을 사용하여 훈련 데이터를 생성합니다. 이러한 이중 접근 방식은 각 모드에 최적화된 데이터를 생성할 수 있게 하며, 궁극적으로 더 강력한 전문가 모델을 구축하는 데 기여합니다.

전문가 모델이 준비되면, 이들은 최종 체크포인트를 위한 도메인 특화 데이터를 생성하는 데 활용됩니다. 실험 결과는 증류된 데이터로 훈련된 모델이 도메인 특화 전문가들의 성능에 근접하는 수준을 달성함을 보여줍니다. 성능 격차는 매우 작으며, 후속 강화학습 훈련을 통해 효과적으로 제거됩니다. 이는 전문가 증류 접근법의 효율성을 입증하는 것으로, 여러 도메인의 전문 지식을 단일 모델에 통합하면서도 각 도메인에서 높은 성능을 유지할 수 있음을 보여줍니다.

### 혼합 강화학습 훈련의 통합적 접근

DeepSeek-V3.2는 강화학습 훈련 알고리즘으로 [Group Relative Policy Optimization(GRPO)](https://arxiv.org/abs/2402.03300)를 채택합니다. GRPO는 DeepSeek-Math와 DeepSeek-R1에서도 사용된 검증된 알고리즘으로, 그룹 단위의 상대적 보상을 활용하여 정책을 최적화합니다. DeepSeek-V3.2-Exp와 마찬가지로, 연구팀은 추론(reasoning), 에이전트(agent), 그리고 인간 정렬(human alignment) 훈련을 단일 강화학습 단계로 통합했습니다. 이러한 통합적 접근법은 다양한 도메인에서 균형 잡힌 성능을 효과적으로 달성하면서, 다단계 훈련 패러다임에서 흔히 발생하는 파괴적 망각(catastrophic forgetting) 문제를 우회합니다.

보상 메커니즘은 작업 유형에 따라 차별화됩니다. 추론 및 에이전트 작업에는 규칙 기반 결과 보상(rule-based outcome reward), 길이 페널티(length penalty), 그리고 언어 일관성 보상(language consistency reward)을 적용합니다. 규칙 기반 결과 보상은 명확한 검증 기준이 있는 작업에서 정확성을 직접 평가할 수 있게 하며, 길이 페널티는 과도하게 장황한 응답을 억제합니다. 언어 일관성 보상은 생성된 응답이 문법적으로 올바르고 일관된 언어 구조를 유지하도록 유도합니다. 일반 작업에는 생성형 보상 모델(generative reward model)을 사용하는데, 이 모델은 각 프롬프트에 대해 맞춤형 평가 루브릭(rubrics)을 갖추고 있어 보다 세밀한 품질 평가가 가능합니다.

### DeepSeek-V3.2와 DeepSeek-V3.2-Speciale의 차별화

DeepSeek-V3.2는 전문가들로부터 증류된 추론, 에이전트, 인간 정렬 데이터를 통합하여 수천 스텝의 지속적인 강화학습 훈련을 거쳐 최종 체크포인트에 도달합니다. 이 모델은 다양한 작업에서 균형 잡힌 성능을 제공하도록 설계되었습니다.

확장된 사고(extended thinking)의 잠재력을 탐구하기 위해, 연구팀은 실험적 변형 모델인 DeepSeek-V3.2-Speciale을 개발했습니다. 이 모델은 추론 데이터로만 독점적으로 훈련되었으며, 강화학습 과정에서 감소된 길이 페널티를 적용했습니다. 길이 페널티를 줄임으로써 모델은 더 긴 추론 과정을 생성할 수 있으며, 복잡한 문제를 해결하기 위해 더 심도 있는 사고 과정을 전개할 수 있습니다. 또한 [DeepSeekMath-V2](https://arxiv.org/abs/2405.04804)의 데이터셋과 보상 방법을 통합하여 수학적 증명에서의 능력을 향상시켰습니다. DeepSeekMath-V2는 수학적 추론에 특화된 모델로, 그 훈련 방법론을 활용하면 복잡한 수학 문제 해결 능력이 크게 개선됩니다.

연구팀은 강화학습 컴퓨팅을 확장하기 위한 안정적인 레시피 개발과 에이전트 작업에 사고를 통합하는 방법에 특별히 주목합니다.

## GRPO 확장을 위한 안정화 전략

### GRPO의 기본 목적 함수

GRPO는 각 질문 $q$가 주어졌을 때 이전 정책 $\pi_{\mathrm{old}}$로부터 샘플링된 응답 그룹 $\{o_{1},\cdots,o_{G}\}$에 대해 정책 모델 $\pi_{\theta}$를 최적화합니다. 목적 함수는 다음과 같이 정의됩니다.

$$\mathcal{J}_{\mathrm{GRPO}}(\theta)=\mathbb{E}_{q\sim P(Q),\{o_{i}\}_{i=1}^{G}\sim\pi_{\mathrm{old}}(\cdot|q)}\Bigg[\frac{1}{G}\sum_{i=1}^{G}\frac{1}{|o_{i}|}\sum_{t=1}^{|o_{i}|}\min\left(r_{i,t}(\theta)\hat{A}_{i,t},\text{clip}\left(r_{i,t}(\theta),1-\varepsilon,1+\varepsilon\right)\hat{A}_{i,t}\right)-\beta\mathbb{D}_{\mathrm{KL}}\left(\pi_{\theta}(o_{i,t})\,\middle\|\,\pi_{\mathrm{ref}}(o_{i,t})\right)\Bigg]$$

여기서 $r_{i,t}(\theta)=\frac{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}{\pi_{\mathrm{old}}(o_{i,t}|q,o_{i,<t})}$는 현재 정책과 이전 정책 간의 중요도 샘플링 비율(importance sampling ratio)입니다. 이 비율은 정책 업데이트의 크기를 측정하며, 너무 큰 업데이트를 방지하는 데 중요한 역할을 합니다. 하이퍼파라미터 $\varepsilon$와 $\beta$는 각각 클리핑 범위와 KL 페널티 강도를 제어합니다. 클리핑 메커니즘은 중요도 샘플링 비율을 $[1-\varepsilon, 1+\varepsilon]$ 범위로 제한하여 정책 업데이트가 너무 급격하게 변하지 않도록 보장합니다.

어드밴티지 $\hat{A}_{i,t}$는 토큰 $o_{i,t}$의 상대적 가치를 나타내며, 그룹 내에서 결과 보상을 정규화하여 추정됩니다. 구체적으로, 보상 모델 집합을 사용하여 그룹 내 각 출력 $o_{i}$에 대한 결과 보상 $R_{i}$를 계산하여 $G$개의 보상 $\boldsymbol{R}=\{R_{1},\cdots,R_{G}\}$를 얻습니다. 토큰 $o_{i,t}$의 어드밴티지는 출력 $o_{i}$의 보상에서 그룹의 평균 보상을 빼서 계산됩니다. $\hat{A}_{i,t}=R_{i}-\text{mean}(\boldsymbol{R})$. 이러한 그룹 상대 정규화는 보상의 절대값이 아닌 상대적 순위를 기준으로 학습하게 하여, 보상 스케일의 변동에 대한 강건성을 높입니다.

### 편향 없는 KL 추정

토큰 $o_{i,t}$가 이전 정책 $\pi_{\mathrm{old}}(\cdot|q,o_{i,<t})$로부터 샘플링되었다는 점을 고려하여, 연구팀은 [K3 추정자](https://arxiv.org/abs/2006.05622)를 수정하여 현재 정책 $\pi_{\theta}$와 이전 정책 $\pi_{\mathrm{old}}$ 간의 중요도 샘플링 비율을 사용한 편향 없는 KL 추정값을 얻었습니다.

$$\mathbb{D}_{\mathrm{KL}}\left(\pi_{\theta}(o_{i,t})\,\middle\|\,\pi_{\mathrm{ref}}(o_{i,t})\right)=\frac{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}{\pi_{\mathrm{old}}(o_{i,t}|q,o_{i,<t})}\left(\frac{\pi_{\mathrm{ref}}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}-\log\frac{\pi_{\mathrm{ref}}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}-1\right)$$

이 수정의 직접적인 결과로, KL 추정자의 기울기가 편향되지 않게 되어 체계적인 추정 오류를 제거하고 안정적인 수렴을 촉진합니다. 이는 원래 K3 추정자와 뚜렷한 대조를 이루는데, 특히 샘플링된 토큰이 참조 정책에 비해 현재 정책 하에서 상당히 낮은 확률을 가질 때($\pi_{\theta}\ll\pi_{\mathrm{ref}}$) 차이가 두드러집니다. 이러한 경우 K3 추정자의 기울기는 이러한 토큰의 우도를 최대화하기 위해 불균형적으로 큰 경계 없는 가중치를 할당하여, 노이즈가 많은 기울기 업데이트를 초래하고 후속 반복에서 샘플 품질을 저하시키며 불안정한 훈련 역학으로 이어집니다.

실제로 연구팀은 서로 다른 도메인이 다양한 강도의 KL 정규화로부터 이득을 얻는다는 것을 발견했습니다. 수학과 같은 특정 도메인의 경우, 상대적으로 약한 KL 페널티를 적용하거나 심지어 완전히 생략하는 것이 향상된 성능을 가져올 수 있습니다. 이는 수학적 추론이 창의적이고 다양한 접근법을 요구하므로, 참조 정책에 너무 강하게 제약받지 않는 것이 유리하기 때문입니다.

### 오프 폴리시 시퀀스 마스킹

강화학습 시스템의 효율성을 개선하기 위해, 일반적으로 대규모 롤아웃 데이터 배치를 생성한 후 여러 미니 배치로 분할하여 여러 번의 기울기 업데이트 스텝을 수행합니다. 이러한 관행은 본질적으로 오프 폴리시(off-policy) 동작을 도입합니다. 추가적으로, 효율적인 데이터 생성을 위해 사용되는 추론 프레임워크는 종종 고도로 최적화되어 있어 훈련 프레임워크와 구현 세부 사항에서 차이가 있을 수 있습니다. 이러한 훈련-추론 불일치는 오프 폴리시 정도를 더욱 악화시킵니다.

훈련을 안정화하고 오프 폴리시 업데이트에 대한 내성을 개선하기 위해, 연구팀은 데이터 샘플링 정책 $\pi_{\mathrm{old}}$와 현재 정책 $\pi_{\theta}$ 간의 KL 발산으로 측정되는 상당한 정책 분기를 도입하는 부정적 시퀀스를 마스킹합니다. 구체적으로, GRPO 손실에 이진 마스크 $M$을 도입합니다.

$$\mathcal{J}_{\mathrm{GRPO}}(\theta)=\mathbb{E}_{q\sim P(Q),\{o_{i}\}_{i=1}^{G}\sim\pi_{\mathrm{old}}(\cdot|q)}\Bigg[\frac{1}{G}\sum_{i=1}^{G}\frac{1}{|o_{i}|}\sum_{t=1}^{|o_{i}|}\min\left(r_{i,t}(\theta)\hat{A}_{i,t},\text{clip}\left(r_{i,t}(\theta),1-\varepsilon,1+\varepsilon\right)\hat{A}_{i,t}\right)M_{i,t}-\beta\mathbb{D}_{\mathrm{KL}}\left(\pi_{\theta}(o_{i,t})\,\middle\|\,\pi_{\mathrm{ref}}(o_{i,t})\right)\Bigg]$$

여기서 마스크는 다음과 같이 정의됩니다.

$$M_{i,t}=\begin{cases}0&{\hat{A}_{i,t}<0,\frac{1}{|o_{i}|}\sum_{t=1}^{|o_{i}|}\log\frac{\pi_{\mathrm{old}}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}>\delta}\\[4.30554pt] 1&{\text{otherwise}}\end{cases}$$

하이퍼파라미터 $\delta$는 정책 분기의 임계값을 제어합니다. 여기서 $\pi_{\mathrm{old}}$는 추론 프레임워크에서 직접 반환된 샘플링 확률을 나타내므로, 이전 정책과 현재 정책 간의 KL 발산은 위에서 언급한 두 가지 오프 폴리시 원인을 모두 고려합니다. 중요한 점은 부정적 어드밴티지를 가진 시퀀스만 마스킹한다는 것입니다. 직관적으로, 모델은 자신의 실수로부터 학습함으로써 가장 큰 이득을 얻지만, 고도로 오프 폴리시인 부정적 샘플은 해로울 수 있으며 최적화 프로세스를 오도하거나 불안정하게 만들 수 있습니다. 연구팀은 이 오프 폴리시 시퀀스 마스킹 작업이 그렇지 않으면 불안정성을 보일 특정 훈련 시나리오에서 안정성을 개선함을 경험적으로 관찰했습니다.

### Keep Routing을 통한 MoE 안정성 확보

Mixture-of-Experts(MoE) 모델은 추론 중 전문가 모듈의 부분집합만 활성화하여 계산 효율성을 개선합니다. 그러나 추론 및 훈련 프레임워크 간의 불일치는 정책 업데이트와 결합되어 동일한 입력에 대해서도 추론과 훈련 중에 일관되지 않은 전문가 라우팅을 초래할 수 있습니다. 이러한 불일치는 활성 파라미터 부분공간에서 갑작스러운 변화를 유발하여 최적화를 불안정하게 만들고 오프 폴리시 문제를 악화시킵니다.

이를 완화하기 위해, 연구팀은 추론 프레임워크에서 샘플링 중 사용된 전문가 라우팅 경로를 보존하고 훈련 중에도 동일한 라우팅 경로를 강제하여 동일한 전문가 파라미터가 최적화되도록 보장합니다. 이 Keep Routing 작업은 MoE 모델의 강화학습 훈련 안정성에 중요한 것으로 밝혀졌으며, DeepSeek-V3-0324 이후 강화학습 훈련 파이프라인에 채택되었습니다.

### Keep Sampling Mask를 통한 행동 공간 일관성

Top-p 및 top-k 샘플링은 대규모 언어 모델이 생성하는 응답의 품질을 향상시키기 위해 널리 사용되는 샘플링 전략입니다. 강화학습 훈련에서 이러한 전략을 사용하는 것도 유리한데, 최적화 대상으로 사용될 극도로 낮은 확률의 토큰 샘플링을 피하기 때문입니다. 이러한 잘라내기(truncation)는 샘플 품질을 보존하지만, $\pi_{\mathrm{old}}$와 $\pi_{\theta}$의 행동 공간 간에 불일치를 도입하여 중요도 샘플링의 원칙을 위반하고 훈련을 불안정하게 만듭니다.

이를 해결하기 위해, 연구팀은 $\pi_{\mathrm{old}}$로부터 샘플링하는 동안 잘라내기 마스크를 보존하고 훈련 중에 이를 $\pi_{\theta}$에 적용하여 두 정책이 동일한 행동 부분공간을 공유하도록 보장합니다. 경험적으로, top-p 샘플링을 Keep Sampling Mask 전략과 결합하면 강화학습 훈련 중에 언어 일관성을 효과적으로 보존하는 것으로 나타났습니다.

## 도구 사용에서의 사고 통합

### 사고 컨텍스트 관리

[DeepSeek-R1](https://arxiv.org/abs/2501.12948)은 사고 프로세스를 통합하면 복잡한 문제를 해결하는 모델의 능력이 크게 향상될 수 있음을 입증했습니다. 이러한 통찰력을 바탕으로, 연구팀은 사고 능력을 도구 호출 시나리오에 통합하고자 했습니다. DeepSeek-R1의 전략, 즉 두 번째 라운드의 메시지가 도착하면 추론 콘텐츠를 폐기하는 방식을 복제하면 상당한 토큰 비효율성이 발생한다는 것을 관찰했습니다. 이 접근법은 모델이 후속 도구 호출마다 전체 문제를 중복적으로 재추론하도록 강제합니다.

이를 완화하기 위해, 연구팀은 도구 호출 시나리오에 엄격하게 맞춤화된 컨텍스트 관리 전략을 개발했습니다.

![도구 호출 시나리오에서의 사고 유지 메커니즘](https://arxiv.org/html/2512.02556/x5.jpeg)

위 그림은 도구 호출 시나리오에서의 사고 유지 메커니즘을 보여줍니다. 이 다이어그램은 사용자 입력, 사고 모듈, 도구 호출, 도구 결과를 포함한 도구 호출 프로세스의 단계 순서를 묘사합니다. 이 메커니즘의 핵심 원칙은 두 가지입니다. 첫째, 과거 추론 콘텐츠는 대화에 새로운 사용자 메시지가 도입될 때만 폐기됩니다. 도구 관련 메시지(예: 도구 출력)만 추가되는 경우, 추론 콘텐츠는 상호작용 전반에 걸쳐 유지됩니다. 둘째, 추론 추적이 제거될 때도 도구 호출 및 그 결과의 이력은 컨텍스트에 보존됩니다.

주목할 점은 Roo Code나 Terminus와 같은 특정 에이전트 프레임워크가 사용자 메시지를 통해 도구 상호작용을 시뮬레이션한다는 것입니다. 이러한 프레임워크는 위에서 설명한 컨텍스트 관리 규칙으로 인해 향상된 추론 지속성의 모든 이점을 완전히 누리지 못할 수 있습니다. 따라서 연구팀은 이러한 아키텍처에 대해 비사고 모델을 사용하는 것을 권장합니다.

### 콜드 스타트 메커니즘

추론 데이터(비에이전트)와 비추론 에이전트 데이터가 이용 가능한 상황에서, 이 두 능력을 통합하기 위한 직관적인 전략은 신중하게 설계된 프롬프팅을 통하는 것입니다. 연구팀은 모델이 명시적인 지시사항을 정확하게 따를 수 있는 충분한 능력을 가지고 있으며, 이를 통해 추론 프로세스 내에서 도구 실행을 원활하게 통합할 수 있다고 가정합니다.

콜드 스타트 메커니즘의 작동을 보여주기 위해, 연구팀은 훈련 데이터를 선택적으로 샘플링했습니다. 서로 다른 작업 프롬프트는 서로 다른 시스템 프롬프트와 연관되어 있다는 점에 유의해야 합니다. 경쟁 프로그래밍 프롬프트에 해당하는 예시가 제시되었습니다.

추론 데이터의 예시는 최종 답변 전에 추론을 수행하도록 모델에 명시적으로 요청하는 시스템 프롬프트를 사용하고, 특수 태그 `<think></think>`를 사용하여 추론 경로를 표시합니다. 비추론 에이전트 데이터의 프롬프트는 시스템 프롬프트에 도구 호출 지침이 포함되어 있습니다. 연구팀이 설계한 시스템 프롬프트는 모델이 추론 프로세스 내에 여러 도구 호출을 통합하도록 지시합니다. 이러한 방식으로, 도구 사용 패턴의 추론이 견고성이 부족할 수 있지만, 모델은 때때로 원하는 궤적을 생성할 수 있으며, 이는 후속 강화학습 단계의 기반을 제공합니다.

### 대규모 에이전트 작업 합성

다양한 강화학습 작업 세트는 모델 강건성을 향상시키는 데 중요합니다. 검색, 코드 엔지니어링, 코드 해석과 같은 작업에는 실제 웹 검색 API, 코딩 도구, Jupyter Notebook을 포함한 실제 도구를 사용합니다. 이러한 강화학습 환경은 실제이지만, 사용된 프롬프트는 실제 사용자 상호작용에서 얻은 것이 아니라 인터넷 소스에서 추출되거나 합성적으로 생성됩니다. 다른 작업의 경우 환경과 프롬프트가 모두 합성적으로 구성됩니다.

| 작업 수 | 환경 | 프롬프트 |
|---------|------|----------|
| code agent 24667 | real | extracted |
| search agent 50275 | real | synthesized |
| general agent 4417 | synthesized | synthesized |
| code interpreter 5908 | real | extracted |

**검색 에이전트(Search Agent)**: DeepSeek-V3.2를 기반으로 한 다중 에이전트 파이프라인을 사용하여 다양하고 고품질의 훈련 데이터를 생성합니다. 먼저 대규모 웹 코퍼스에서 다양한 도메인에 걸쳐 정보가 풍부한 롱테일 엔티티를 샘플링합니다. 질문 구성 에이전트는 구성 가능한 깊이 및 폭 파라미터를 가진 검색 도구를 사용하여 각 엔티티를 탐색하고, 발견된 정보를 질문-답변 쌍으로 통합합니다. 이질적인 구성(서로 다른 체크포인트, 시스템 프롬프트 등)을 가진 여러 답변 생성 에이전트가 제안된 각 질의응답 쌍에 대해 다양한 후보 응답을 생성합니다. 검색 기능을 갖춘 검증 에이전트가 여러 패스를 통해 모든 답변을 검증하여, 정답이 올바르고 모든 후보가 검증 가능하게 잘못된 샘플만 유지합니다. 이러한 데이터는 여러 언어, 도메인, 난이도 수준에 걸쳐 있습니다.
이러한 검증 가능한 샘플을 보완하고 실제 사용 상황을 더 잘 반영하기 위해, 연구팀은 검색 도구가 측정 가능한 이점을 제공하는 기존의 유용성 강화학습 데이터셋에서 필터링된 인스턴스로 데이터셋을 증강했습니다. 이후 여러 품질 차원에 걸쳐 상세한 평가 루브릭을 개발하고, 생성형 보상 모델을 사용하여 이러한 루브릭을 기반으로 응답을 채점합니다. 이러한 하이브리드 접근법은 사실적 신뢰성과 실용적 유용성 모두에 대한 최적화를 가능하게 합니다.

**코드 에이전트(Code Agent)**: GitHub에서 수백만 개의 이슈-Pull Request(PR) 쌍을 마이닝하여 대규모 실행 가능 환경을 구축했습니다. 이 데이터셋은 휴리스틱 규칙과 대규모 언어 모델 기반 판단을 사용하여 엄격하게 필터링되어 높은 품질을 보장하며, 각 항목이 합리적인 이슈 설명, 상관된 골드 패치, 그리고 검증을 위한 테스트 패치를 포함하도록 요구합니다. DeepSeek-V3.2를 기반으로 한 자동화된 환경 설정 에이전트가 이러한 쌍에 대한 실행 가능 환경을 구축하기 위해 사용되었습니다. 이 에이전트는 패키지 설치, 종속성 해결, 테스트 실행을 처리합니다. 테스트 결과는 표준 JUnit 형식으로 출력되어 프로그래밍 언어와 테스트 프레임워크 전반에 걸쳐 일관된 파싱을 보장합니다.

환경이 성공적으로 구축되었다고 간주되는 것은 골드 패치를 적용했을 때 false-to-positive(F2P) 테스트 케이스의 수가 0이 아니고(이슈가 수정되었음을 나타냄), pass-to-fail(P2F) 테스트 케이스의 수가 0일 때(회귀가 없음을 나타냄)만입니다. 이 파이프라인을 사용하여, 연구팀은 Python, Java, JavaScript, TypeScript, C, C++, Go, PHP를 포함한 여러 프로그래밍 언어에 걸쳐 수만 개의 재현 가능한 이슈 해결 환경을 성공적으로 구축했습니다.

**코드 인터프리터 에이전트(Code Interpreter Agent)**: Jupyter Notebook을 코드 인터프리터로 활용하여 복잡한 추론 작업을 해결합니다. 이를 위해 연구팀은 수학, 논리, 데이터 과학을 아우르는 다양한 문제를 큐레이션했으며, 각 문제는 모델이 코드 실행 능력을 활용하여 솔루션에 도달하도록 요구합니다. 이러한 환경에서 모델은 계산적으로 복잡한 문제를 코드로 분해하고, 중간 결과를 검증하며, 반복적으로 솔루션을 정제할 수 있습니다.

**일반 에이전트(General Agent)**: 강화학습에서 에이전트 환경과 작업을 확장하기 위해, 연구팀은 1,827개의 작업 지향 환경을 합성하는 자동 환경 합성 에이전트를 사용했습니다. 이러한 작업은 해결하기는 어렵지만 검증하기는 쉬운 특성을 가지고 있습니다. 합성 워크플로는 주로 환경 및 도구 세트 구축, 작업 합성, 솔루션 생성으로 구성됩니다.

구체적으로 워크플로는 다음과 같이 진행됩니다. 첫째, 작업 카테고리(예: 여행 일정 계획)와 bash 및 검색 도구가 장착된 샌드박스가 주어지면, 에이전트는 먼저 이러한 도구를 사용하여 인터넷에서 관련 데이터를 생성하거나 검색하여 샌드박스 데이터베이스에 저장합니다. 둘째, 에이전트는 각각 함수로 구현된 작업별 도구 세트를 합성합니다. 셋째, 도전적이면서도 자동으로 검증 가능한 작업을 생성하기 위해, 에이전트는 현재 데이터베이스를 기반으로 솔루션 및 Python으로 구현된 검증 함수와 함께 간단한 작업을 초기에 제안합니다.

솔루션 함수는 도구 함수를 호출하거나 논리 계산을 수행하는 것으로 제한되며, 다른 함수를 호출하거나 데이터베이스에 직접 접근할 수 없어 작업이 도구 인터페이스를 통해서만 해결될 수 있도록 보장합니다. 또한 솔루션 함수가 생성한 결과는 검증 함수에 의해 검증되어야 합니다. 솔루션이 검증되지 않으면, 에이전트는 솔루션이나 검증 함수를 수정하여 솔루션의 출력이 검증을 통과할 때까지 조정합니다. 이후 에이전트는 작업의 난이도를 반복적으로 높이고 해당 솔루션 및 검증 함수를 업데이트합니다. 이 반복 과정에서 현재 도구 세트가 작업을 해결하기에 충분하지 않으면, 에이전트가 도구 세트를 증강합니다.

이 워크플로를 따라, 연구팀은 수천 개의 $\langle\text{environment},\text{tools},\text{task},\text{verifier}\rangle$ 튜플을 얻었습니다. 이후 DeepSeek-V3.2를 사용하여 이 데이터셋에 대해 강화학습을 수행하고 pass@100이 0이 아닌 인스턴스만 유지하여, 최종적으로 1,827개의 환경과 해당 작업(총 4,417개)을 얻었습니다.

다음은 합성된 여행 계획 작업의 예시입니다. 이 예시는 모든 제약 조건을 만족하는 여행 계획을 찾기 위해 대규모 조합 공간을 탐색하는 것이 어렵지만, 주어진 후보 솔루션이 이러한 제약 조건을 만족하는지 확인하는 것은 상대적으로 간단하다는 점을 강조합니다.

**합성된 작업의 예시: 여행 계획**

"저는 항저우에서 시작하는 3일간의 여행을 계획하고 있으며, 2025년 10월 1일부터 10월 3일까지의 일정을 만드는 데 도움이 필요합니다. 몇 가지 중요한 요구 사항이 있습니다. 전체 여행 기간 동안 도시, 호텔, 관광지, 레스토랑을 반복하고 싶지 않습니다. 또한 제가 추천하는 모든 호텔, 레스토랑, 관광지가 실제로 제가 그날 머무르는 도시에 위치하고 있는지 확인해 주세요.

둘째 날에 대해 한 가지 더 말씀드리자면, 예산을 현명하게 사용하려고 합니다. 만약 1박당 800 위안 이상의 럭셔리 호텔을 예약하게 되면, 다른 비용에 더 신중해야 합니다. 레스토랑(점심과 저녁) 총 지출은 350 위안 미만이어야 하고, 두 레스토랑 모두 최소 4.0성급 이상이어야 하며, 오후 관광지 티켓은 120 위안 미만이어야 합니다. 둘째 날 호텔이 중상급 범위(500-800 위안)라면, 조금 더 유연성이 있습니다. 레스토랑 선택 중 최소 하나는 4.0 이상의 평점이어야 하고, 관광지 티켓은 180 위안 미만이어야 합니다. 더 저렴한 호텔(200-500 위안 범위)의 경우, 최소 하나의 레스토랑이 3.2 이상의 평점을 가지고 있는지만 확인하면 됩니다.

이 일정을 작성하는 데 도움을 주시겠습니까?"

**제출 결과 형식:**

```json
[
  {
    "time": "2025-10-01",
    "city": "city_name",
    "hotel": "hotel_name",
    "afternoon_restaurant": "restaurant_name",
    "afternoon_attraction": "attraction_name",
    "evening_restaurant": "restaurant_name"
  },
  {
    "time": "2025-10-02",
    "city": "city_name",
    "hotel": "hotel_name",
    "afternoon_restaurant": "restaurant_name",
    "afternoon_attraction": "attraction_name",
    "evening_restaurant": "restaurant_name"
  },
  {
    "time": "2025-10-03",
    "city": "city_name",
    "hotel": "hotel_name",
    "afternoon_restaurant": "restaurant_name",
    "afternoon_attraction": "attraction_name",
    "evening_restaurant": "restaurant_name"
  }
]
```

**여행 계획을 위한 도구 세트:**

| 함수 이름 | 설명 |
|----------|------|
| get_all_attractions_by_city(city) | 주어진 도시의 모든 관광지를 가져옵니다. |
| get_all_cities() | 데이터베이스에서 모든 도시를 가져옵니다. |
| get_all_hotels_by_city(city) | 주어진 도시의 모든 호텔을 가져옵니다. |
| get_all_restaurants_by_city(city) | 주어진 도시의 모든 레스토랑을 가져옵니다. |
| get_city_by_attraction(attraction) | 주어진 관광지의 도시를 가져옵니다. |
| get_city_by_hotel(hotel) | 주어진 호텔의 도시를 가져옵니다. |
| get_city_by_restaurant(restaurant) | 주어진 레스토랑의 도시를 가져옵니다. |
| get_city_transport(city) | 주어진 도시의 모든 시내 교통 옵션을 가져옵니다. |
| get_infos_by_attraction(info_keywords, attraction) | 주어진 관광지의 지정된 정보를 가져옵니다. |
| get_infos_by_city(info_keywords, city) | 주어진 도시의 지정된 정보를 가져옵니다. |
| get_infos_by_hotel(info_keywords, hotel) | 주어진 호텔의 지정된 정보를 가져옵니다. |
| get_infos_by_restaurant(info_keywords, restaurant) | 주어진 레스토랑의 지정된 정보를 가져옵니다. |
| get_inter_city_transport(from_city, to_city) | 주어진 도시 쌍 간의 모든 교통 수단을 가져옵니다. |
| get_weather_by_city_date(city, date) | 주어진 도시-날짜 쌍의 날씨를 가져옵니다. |
| submit_result(answer_text) | 최종 답변 내용을 제출합니다. |

이 예시에서 볼 수 있듯이, 에이전트는 제공된 도구들을 활용하여 복잡한 제약 조건을 만족하는 여행 계획을 수립해야 합니다. 검증 함수는 생성된 계획이 모든 요구사항(도시/호텔/레스토랑 중복 금지, 위치 일치, 예산 제약 조건 등)을 만족하는지 자동으로 확인할 수 있습니다. 이러한 방식으로 합성된 작업들은 강화학습 훈련에 효과적인 환경을 제공하며, 모델이 복잡한 논리적 추론과 도구 사용을 결합하여 실제 문제를 해결하는 능력을 발전시킬 수 있도록 합니다.

이러한 대규모 에이전트 작업 합성 파이프라인을 통해, DeepSeek-V3.2는 다양한 도메인과 난이도 수준에 걸친 광범위한 에이전트 시나리오에서 훈련될 수 있으며, 이는 모델의 일반화 능력과 실제 환경에서의 견고성을 크게 향상시킵니다.
## 평가

DeepSeek-V3.2는 추론, 코딩, 수학, 에이전트 작업을 포괄하는 18개의 벤치마크에서 평가되었습니다. 평가는 온도 1.0, 128K 토큰의 컨텍스트 윈도우를 사용하여 수행되었으며, 수학 관련 작업에는 단계별 추론과 최종 답변을 `\boxed{}`로 표시하도록 하는 템플릿이 적용되었습니다.

### 주요 결과

다음 표는 DeepSeek-V3.2와 주요 폐쇄형 및 개방형 모델들의 성능을 비교한 결과입니다. 개방형 모델의 경우 도구 사용에서 사고 기능을 지원하는 모델들만 비교에 포함되었습니다.

| 벤치마크 (메트릭) | Claude-4.5-Sonnet | GPT-5-High | Gemini-3.0-Pro | Kimi-K2-Thinking | MiniMax-M2 | DeepSeek-V3.2-Thinking |
|---|---|---|---|---|---|---|
| **영어** |
| MMLU-Pro (EM) | 88.2 | 87.5 | 90.1 | 84.6 | 82.0 | 85.0 |
| GPQA Diamond (Pass@1) | 83.4 | 85.7 | 91.9 | 84.5 | 77.7 | 82.4 |
| HLE (Pass@1) | 13.7 | 26.3 | 37.7 | 23.9 | 12.5 | 25.1 |
| **코드** |
| LiveCodeBench (Pass@1-COT) | 64.0 | 84.5 | 90.7 | 82.6 | 83.0 | 83.3 |
| Codeforces (Rating) | 1480 | 2537 | 2708 | - | - | 2386 |
| **수학** |
| AIME 2025 (Pass@1) | 87.0 | 94.6 | 95.0 | 94.5 | 78.3 | 93.1 |
| HMMT Feb 2025 (Pass@1) | 79.2 | 88.3 | 97.5 | 89.4 | - | 92.5 |
| HMMT Nov 2025 (Pass@1) | 81.7 | 89.2 | 93.3 | 89.2 | - | 90.2 |
| IMOAnswerBench (Pass@1) | - | 76.0 | 83.3 | 78.6 | - | 78.3 |
| **코드 에이전트** |
| Terminal Bench 2.0 (Acc) | 42.8 | 35.2 | 54.2 | 35.7 | 30.0 | 46.4 |
| SWE Verified (Resolved) | 77.2 | 74.9 | 76.2 | 71.3 | 69.4 | 73.1 |
| SWE Multilingual (Resolved) | 68.0 | 55.3 | - | 61.1 | 56.5 | 70.2 |
| **검색 에이전트** |
| BrowseComp (Pass@1) | 24.1 | 54.9 | -/60.2* | 44.0 | - | 51.4/67.6* |
| BrowseCompZh (Pass@1) | 42.4 | 63.0 | - | 62.3 | 48.5 | 65.0 |
| HLE (Pass@1) | 32.0 | 35.2 | 45.8 | 44.9 | 31.8 | 40.8 |
| **도구 사용** |
| τ²-Bench (Pass@1) | 84.7 | 80.2 | 85.4 | 74.3 | 76.9 | 80.3 |
| MCP-Universe (Success Rate) | 46.5 | 47.9 | 50.7 | 35.6 | 29.4 | 45.9 |
| MCP-Mark (Pass@1) | 33.3 | 50.9 | 43.1 | 20.4 | 24.4 | 38.0 |
| Tool-Decathlon (Pass@1) | 38.6 | 29.0 | 36.4 | 17.6 | 16.0 | 35.2 |

*컨텍스트 관리 기법 적용 시 성능

DeepSeek-V3.2는 추론 작업에서 GPT-5-high와 유사한 성능을 달성하면서도 Kimi-K2-Thinking보다 훨씬 적은 출력 토큰으로 비슷한 점수를 기록했습니다. 이러한 성능 향상은 강화학습 훈련에 할당된 계산 자원의 증가에 기인하며, 사전 훈련 비용의 10%를 초과하는 강화학습 예산을 투입한 결과입니다. 코드 에이전트 평가에서는 SWE-bench Verified와 Terminal Bench 2.0 모두에서 개방형 모델들을 크게 앞서며 실제 코딩 워크플로우에서의 잠재력을 입증했습니다.

검색 에이전트 평가에서는 128K 컨텍스트 길이 제한으로 인해 약 20% 이상의 테스트 케이스가 제한을 초과했습니다. 이를 해결하기 위해 컨텍스트 관리 방법을 적용한 결과 성능이 크게 향상되었으며, 이에 대한 상세한 내용은 컨텍스트 관리 섹션에서 다룹니다. 도구 사용 벤치마크에서는 개방형 모델과 폐쇄형 모델 간의 성능 격차를 크게 좁혔으며, 특히 강화학습 훈련 중 접하지 않았던 환경과 도구셋에서도 추론 전략을 일반화하는 능력을 보여주었습니다.

### DeepSeek-V3.2-Speciale의 성능

확장된 사고 잠재력을 탐구하기 위해 개발된 DeepSeek-V3.2-Speciale은 감소된 길이 페널티를 적용하여 더 긴 추론 과정을 생성할 수 있도록 했습니다. 다음 표는 주요 모델들의 벤치마크 성능과 토큰 효율성을 비교한 결과입니다.

| 벤치마크 | GPT-5-High | Gemini-3.0-Pro | Kimi-K2-Thinking | DeepSeek-V3.2-Thinking | DeepSeek-V3.2-Speciale |
|---|---|---|---|---|---|
| AIME 2025 (Pass@1) | 94.6 (13k) | **95.0** (15k) | 94.5 (24k) | 93.1 (16k) | **96.0** (23k) |
| HMMT Feb 2025 (Pass@1) | 88.3 (16k) | 97.5 (16k) | 89.4 (31k) | 92.5 (19k) | **99.2** (27k) |
| HMMT Nov 2025 (Pass@1) | 89.2 (20k) | **93.3** (15k) | 89.2 (29k) | 90.2 (18k) | **94.4** (25k) |
| IMOAnswerBench (Pass@1) | 76.0 (31k) | **83.3** (18k) | 78.6 (37k) | 78.3 (27k) | **84.5** (45k) |
| LiveCodeBench (Pass@1-COT) | 84.5 (13k) | **90.7** (13k) | 82.6 (29k) | 83.3 (16k) | 88.7 (27k) |
| CodeForces (Rating) | 2537 (29k) | **2708** (22k) | - | 2386 (42k) | **2701** (77k) |
| GPQA Diamond (Pass@1) | 85.7 (8k) | **91.9** (8k) | 84.5 (12k) | 82.4 (7k) | 85.7 (16k) |
| HLE (Pass@1) | 26.3 (15k) | **37.7** (15k) | 23.9 (24k) | 25.1 (21k) | 30.6 (35k) |

괄호 안의 숫자는 천 단위의 출력 토큰 수를 나타냅니다.

DeepSeek-V3.2-Speciale은 증가된 추론 토큰을 활용하여 여러 벤치마크에서 최첨단 Gemini-3.0-Pro를 능가하는 성능을 달성했습니다. 특히 주목할 점은 이 범용 모델이 타겟 훈련 없이도 2025년 국제 정보 올림피아드(IOI)와 ICPC 세계 결선에서 금메달 수준의 성과를 거두었다는 것입니다.

| 대회 | P1 | P2 | P3 | P4 | P5 | P6 | 전체 | 메달 |
|---|---|---|---|---|---|---|---|---|
| IMO 2025 | 7 | 7 | 7 | 7 | 7 | 0 | 35/42 | 금 |
| CMO 2025 | 18 | 18 | 9 | 21 | 18 | 18 | 102/126 | 금 |
| IOI 2025 | 100 | 82 | 72 | 100 | 55 | 83 | 492/600 | 금 |

| 대회 | A | B | C | D | E | F | G | H | I | J | K | L | 전체 | 메달 |
|---|---|---|---|---|---|---|---|---|---|---|---|---|---|---|
| ICPC WF 2025 | 3 | - | 1 | 1 | 2 | 2 | - | 1 | 1 | 1 | 1 | 1 | 10/12 | 금 |

DeepSeek-V3.2-Speciale은 IOI 2025에서 10위, ICPC WF 2025에서 2위를 기록했습니다. 또한 [DeepSeekMath-V2](https://arxiv.org/abs/2405.04804)의 기법을 통합하여 복잡한 증명 작업에서도 IMO 2025와 CMO 2025에서 금메달 기준을 달성했습니다. 그러나 토큰 효율성은 Gemini-3.0-Pro에 비해 여전히 낮은 수준이며, 이는 향후 연구가 필요한 중요한 영역으로 남아있습니다.

### 합성 에이전트 작업의 효과

합성 에이전트 작업의 효과를 검증하기 위해 두 가지 핵심 질문에 초점을 맞춘 실험이 수행되었습니다. 첫째, 합성 작업이 강화학습에 충분히 도전적인가? 둘째, 이러한 합성 작업이 다른 하위 작업이나 실제 환경으로 얼마나 잘 일반화되는가?

첫 번째 질문에 답하기 위해 일반 합성 에이전트 작업에서 50개의 인스턴스를 무작위로 샘플링하여 합성에 사용된 모델과 최첨단 폐쇄형 모델들을 평가했습니다.

| Pass@K | DeepSeek-v3.2-Exp | Sonnet-4.5 | Gemini-3.0 Pro | GPT-5-Thinking |
|---|---|---|---|---|
| 1 | 12% | 34% | 51% | 62% |
| 2 | 18% | 47% | 65% | 75% |
| 4 | 26% | 62% | 74% | 82% |

DeepSeek-V3.2-Exp는 단 12%의 정확도를 기록했으며, 최첨단 폐쇄형 모델도 최대 62%에 그쳤습니다. 이는 합성 데이터에 DeepSeek-V3.2-Exp와 최첨단 모델 모두에게 도전적인 에이전트 작업이 포함되어 있음을 보여줍니다.

강화학습이 합성 데이터에서 다른 작업으로 일반화되는지 조사하기 위해, DeepSeek-V3.2의 SFT 체크포인트에 합성 에이전트 작업만을 사용하여 비사고 모드에서 강화학습을 적용했습니다. 긴 추론과 다른 강화학습 데이터의 영향을 배제하기 위한 설계입니다.

![합성 일반 에이전트 데이터를 독점적으로 사용한 DeepSeek-V3.2-SFT의 강화학습 훈련](https://arxiv.org/html/2512.02556/figures/synthesis-rl-plot.png)

위 그림은 합성 일반 에이전트 데이터만을 사용한 강화학습 훈련이 Tau2Bench, MCP-Mark, MCP-Universe 벤치마크에서 DeepSeek-V3.2-SFT 대비 상당한 개선을 가져왔음을 보여줍니다. 반면 코드 및 검색 시나리오로 강화학습을 제한한 DeepSeek-V3.2-Exp는 이러한 벤치마크에서 성능 향상을 보이지 않았습니다. 이는 합성 데이터의 잠재력을 더욱 부각시키며, 다양한 도메인에서의 일반화 능력을 입증합니다.

### 검색 에이전트의 컨텍스트 관리

128K와 같은 확장된 컨텍스트 윈도우에서도 에이전트 워크플로우, 특히 검색 기반 시나리오는 최대 길이 제한에 직면하여 추론 프로세스가 조기에 종료되는 경우가 빈번합니다. 이는 테스트 타임 컴퓨팅 잠재력의 완전한 실현을 저해합니다. 이를 해결하기 위해 토큰 사용량이 컨텍스트 윈도우 길이의 80%를 초과할 때 토큰 예산을 테스트 타임에 확장하는 간단한 컨텍스트 관리 전략이 도입되었습니다.

다음은 세 가지 컨텍스트 관리 전략을 Python 의사 코드로 구현한 예시입니다.

```python
def context_management_strategy(trajectory, context_limit, strategy_type):
    """
    컨텍스트 관리 전략을 적용하여 토큰 예산을 확장합니다.
    
    Args:
        trajectory: 현재까지의 대화 및 도구 호출 이력
        context_limit: 최대 컨텍스트 길이 (예: 128K)
        strategy_type: 'summary', 'discard_75', 'discard_all'
    
    Returns:
        관리된 컨텍스트와 추가 실행 공간
    """
    current_tokens = count_tokens(trajectory)
    threshold = context_limit * 0.8
    
    if current_tokens < threshold:
        return trajectory  # 아직 임계값 미만
    
    if strategy_type == 'summary':
        # 전략 1: 오버플로우된 궤적을 요약하고 재시작
        overflow_content = trajectory['tool_calls'][:-5]  # 최근 5개 제외
        summary = generate_summary(overflow_content)
        new_trajectory = {
            'summary': summary,
            'recent_calls': trajectory['tool_calls'][-5:],
            'user_query': trajectory['user_query']
        }
        return new_trajectory
    
    elif strategy_type == 'discard_75':
        # 전략 2: 처음 75%의 도구 호출 이력을 폐기
        total_calls = len(trajectory['tool_calls'])
        keep_from = int(total_calls * 0.75)
        trajectory['tool_calls'] = trajectory['tool_calls'][keep_from:]
        return trajectory
    
    elif strategy_type == 'discard_all':
        # 전략 3: 모든 이전 도구 호출 이력을 폐기 (new context tool)
        # 사용자 쿼리와 현재 상태만 유지
        new_trajectory = {
            'user_query': trajectory['user_query'],
            'current_state': trajectory.get('current_state'),
            'tool_calls': []  # 이력 초기화
        }
        return new_trajectory
    
    return trajectory


def parallel_fewest_step_strategy(query, num_trajectories, max_steps):
    """
    병렬 스케일링 기준선: 여러 독립 궤적을 샘플링하고 
    가장 적은 단계를 가진 궤적을 선택
    
    Args:
        query: 사용자 질의
        num_trajectories: 샘플링할 궤적 수
        max_steps: 각 궤적의 최대 실행 단계
    
    Returns:
        가장 적은 단계를 가진 성공적인 궤적
    """
    trajectories = []
    
    for _ in range(num_trajectories):
        trajectory = execute_agent(query, max_steps)
        if trajectory['success']:
            trajectories.append(trajectory)
    
    # 가장 적은 단계를 가진 궤적 선택
    if trajectories:
        return min(trajectories, key=lambda t: t['num_steps'])
    return None
```

이러한 전략들은 [BrowseComp 벤치마크](https://arxiv.org/abs/2412.10137)에서 평가되었습니다.

![다양한 테스트 타임 컴퓨팅 확장 전략에 따른 Browsecomp 정확도](https://arxiv.org/html/2512.02556/x6.png)

위 그림은 다양한 컴퓨팅 예산 하에서 컨텍스트 관리가 모델이 추가 실행 단계를 수행할 수 있는 공간을 제공하여 상당한 성능 향상을 가져온다는 것을 보여줍니다. Summary 전략은 평균 364단계로 확장하여 최대 60.2의 성능을 달성했지만, 전체적인 효율성은 상대적으로 낮았습니다. 반면 단순함에도 불구하고 Discard-all 전략은 효율성과 확장성 모두에서 우수한 성능을 보여, 67.6의 점수를 달성하며 훨씬 적은 단계를 사용하면서도 병렬 스케일링과 비슷한 수준의 성과를 거두었습니다.

테스트 타임 컴퓨팅은 컨텍스트 관리를 통한 직렬 확장 또는 병렬 확장 모두를 통해 효과적으로 확장될 수 있으며, 둘 다 모델의 문제 해결 능력을 효과적으로 확장합니다. 그러나 서로 다른 전략은 다양한 효율성과 확장성을 보여주므로, 모델 성능을 벤치마킹할 때 실제 컴퓨팅 비용을 고려하는 것이 중요합니다. 직렬 및 병렬 확장의 최적 조합을 찾아 효율성과 확장성을 모두 극대화하는 것은 향후 연구의 중요한 방향으로 남아있습니다.
## 결론, 한계, 그리고 향후 연구 방향

DeepSeek-V3.2는 계산 효율성과 고급 추론 능력 사이의 격차를 효과적으로 연결하는 프레임워크를 제시했습니다. 이 연구는 세 가지 핵심 기술적 혁신을 통해 개방형 대규모 언어 모델의 새로운 가능성을 열었습니다.

첫 번째 혁신인 DSA는 긴 문맥 성능을 희생하지 않으면서도 계산 복잡도를 획기적으로 감소시켰습니다. 앞서 설명한 DSA 아키텍처는 lightning indexer와 fine-grained token selection 메커니즘을 통해 어텐션 연산의 복잡도를 O(L²)에서 O(Lk)로 줄였으며, 이는 128K 토큰 위치에서 약 4배의 비용 절감을 달성했습니다. 이러한 효율성 개선은 단순히 계산 비용을 줄이는 것을 넘어, 긴 문맥 시나리오에서 모델의 실용적 배포를 가능하게 만들었습니다.

두 번째 혁신은 계산 예산의 대폭적인 확장입니다. 사후 훈련 단계에서 사전 훈련 비용의 10%를 초과하는 계산 자원을 투입함으로써, DeepSeek-V3.2는 추론 벤치마크에서 [GPT-5](https://openai.com/index/introducing-gpt-5-and-gpt-5-mini/)와 비견되는 성능을 달성했습니다. 이는 개방형 모델이 충분한 계산 자원과 적절한 훈련 전략을 갖추면 최첨단 폐쇄형 모델과 경쟁할 수 있음을 입증한 중요한 성과입니다. 특히 DeepSeek-V3.2-Speciale은 [Gemini-3.0-Pro](https://blog.google/technology/google-deepmind/google-gemini-ai-update-march-2025/)와 동등한 수준의 추론 능력을 보여주며, 2025년 IMO와 IOI에서 금메달 수준의 성과를 거두었습니다. 이러한 결과는 개방형 모델이 최고 수준의 수학적 추론과 프로그래밍 능력을 달성할 수 있음을 명확히 보여줍니다.

세 번째 혁신인 대규모 에이전트 작업 합성 파이프라인은 도구 사용 숙련도를 크게 향상시켰습니다. 앞서 소개한 합성 파이프라인은 1,800개 이상의 고유한 환경과 85,000개의 복잡한 프롬프트를 생성하여, 모델이 다양한 도구 사용 시나리오에서 강건하고 일반화 가능한 능력을 발전시킬 수 있도록 했습니다. 이는 개방형 대규모 언어 모델을 활용한 강력하고 일반화 가능한 AI 에이전트의 새로운 가능성을 열었으며, 실제 응용 환경에서의 실용성을 크게 높였습니다.

그러나 이러한 성과에도 불구하고, DeepSeek-V3.2는 Gemini-3.0-Pro와 같은 최첨단 폐쇄형 모델과 비교할 때 몇 가지 한계를 인정합니다. 첫째, 총 훈련 FLOPs가 적기 때문에 DeepSeek-V3.2의 세계 지식의 폭은 여전히 선도적인 독점 모델에 비해 뒤처져 있습니다. 이는 모델이 다양한 도메인에 걸친 광범위한 사실적 지식을 요구하는 작업에서 상대적으로 제한적인 성능을 보일 수 있음을 의미합니다. 연구팀은 향후 반복 개발에서 사전 훈련 계산을 확장하여 이러한 지식 격차를 해결할 계획입니다. 사전 훈련 단계에서 더 많은 계산 자원을 투입하고 더 다양한 데이터를 활용함으로써, 모델의 지식 기반을 확장하고 다양한 주제에 대한 이해도를 높일 수 있을 것으로 기대됩니다.

둘째, 토큰 효율성은 여전히 도전 과제로 남아있습니다. DeepSeek-V3.2는 일반적으로 Gemini-3.0-Pro와 같은 모델의 출력 품질과 일치하기 위해 더 긴 생성 궤적, 즉 더 많은 토큰을 필요로 합니다. 이는 동일한 품질의 응답을 생성하는 데 더 많은 계산 자원과 시간이 소요됨을 의미하며, 실제 배포 환경에서 비용 효율성과 응답 속도에 영향을 미칠 수 있습니다. 향후 연구는 모델의 추론 체인의 지능 밀도를 최적화하여 효율성을 개선하는 데 초점을 맞출 것입니다. 이는 각 토큰이 더 많은 정보를 담고 더 효과적인 추론을 수행할 수 있도록 모델을 개선하는 것을 의미하며, 결과적으로 더 짧은 생성 궤적으로도 높은 품질의 출력을 달성할 수 있게 될 것입니다.

셋째, 복잡한 작업을 해결하는 능력은 여전히 최첨단 모델에 비해 열등합니다. 이는 DeepSeek-V3.2가 다단계 추론이 필요하거나 여러 개념을 통합해야 하는 매우 복잡한 문제에서 최고 수준의 성능을 달성하지 못할 수 있음을 나타냅니다. 이러한 한계는 연구팀이 파운데이션 모델과 사후 훈련 레시피를 더욱 정제하도록 동기를 부여합니다. 향후 연구에서는 모델의 기본 아키텍처를 개선하고, 더 효과적인 훈련 전략을 개발하며, 복잡한 추론 능력을 강화하는 데 집중할 것입니다.

이러한 한계들은 개방형 모델 개발의 현재 상태를 반영하는 동시에, 향후 연구의 명확한 방향을 제시합니다. 사전 훈련 계산의 확장, 토큰 효율성 개선, 그리고 복잡한 작업 해결 능력의 향상은 모두 개방형 대규모 언어 모델이 최첨단 폐쇄형 모델과의 격차를 더욱 좁히기 위해 필요한 핵심 영역입니다. DeepSeek-V3.2의 성과는 이러한 목표가 달성 가능함을 보여주며, 지속적인 연구와 개발을 통해 개방형 모델이 더욱 강력하고 효율적으로 발전할 수 있는 기반을 마련했습니다.

특히 주목할 점은 DeepSeek-V3.2가 계산 효율성과 성능 사이의 균형을 추구하는 접근 방식을 취했다는 것입니다. DSA를 통한 효율성 개선은 단순히 비용을 절감하는 것을 넘어, 제한된 자원으로도 높은 성능을 달성할 수 있는 가능성을 보여주었습니다. 이는 개방형 모델 개발에서 중요한 교훈을 제공하며, 무조건적인 규모 확장보다는 효율적인 아키텍처 설계와 최적화된 훈련 전략이 경쟁력 있는 모델을 만드는 데 핵심적임을 시사합니다.

또한 대규모 에이전트 작업 합성 파이프라인의 성공은 합성 데이터의 잠재력을 입증했습니다. 실제 데이터 수집의 어려움과 비용을 고려할 때, 체계적으로 설계된 합성 환경과 작업은 모델의 일반화 능력을 효과적으로 향상시킬 수 있는 실용적인 대안을 제공합니다. 이러한 접근법은 향후 AI 에이전트 개발에서 중요한 방법론으로 자리잡을 것으로 예상됩니다.

DeepSeek-V3.2의 연구는 개방형 대규모 언어 모델의 발전에 중요한 이정표를 세웠으며, 계산 효율성, 추론 능력, 그리고 도구 사용 숙련도의 조화로운 발전이 가능함을 보여주었습니다. 향후 연구를 통해 확인된 한계들이 해결된다면, 개방형 모델은 최첨단 폐쇄형 모델과 완전히 동등한 수준에 도달할 수 있을 것이며, 이는 AI 연구 커뮤니티 전체에 큰 이익을 가져올 것입니다.
## 부록

### MLA의 MHA 및 MQA 모드

![MLA의 MHA 모드](https://arxiv.org/html/2512.02556/x7.png)

![MLA의 MQA 모드](https://arxiv.org/html/2512.02556/x8.png)

DeepSeek-V3.2는 Multi-Latent Attention 구조 하에서 두 가지 어텐션 모드를 전략적으로 활용합니다. 첫 번째 그림은 MHA 모드의 아키텍처를 보여주며, 입력 hidden state로부터 여러 쿼리 헤드를 생성하여 각 헤드가 독립적인 latent vector와 상호작용하는 구조입니다. 이 모드는 풍부한 표현력을 제공하여 훈련 및 프리필링 단계에서 사용됩니다. 두 번째 그림은 MQA 모드를 나타내며, 모든 쿼리 헤드가 단일 latent vector를 공유하는 구조로 메모리 효율성을 극대화합니다. 이 모드는 디코딩 단계에서 적용되어 추론 시 계산 비용을 크게 절감합니다.

DeepSeek-V3.1-Terminus에서는 훈련과 프리필링에 MHA 모드를, 디코딩에 MQA 모드를 적용하는 이중 모드 전략을 사용했습니다. 이러한 모드 전환은 커널 수준에서 최적화되어 각 단계의 특성에 맞는 최적의 성능과 효율성을 달성하며, 앞서 설명한 DSA 구현도 이 MQA 모드를 기반으로 구축되었습니다.

### 콜드 스타트 템플릿

콜드 스타트 메커니즘은 추론 능력과 도구 사용을 점진적으로 통합하기 위해 세 가지 수준의 시스템 프롬프트를 활용합니다. 다음은 각 단계를 보여주는 템플릿들입니다.

**기본 추론 템플릿 (Table 6)**

| 시스템 프롬프트 | 응답 패턴 |
|---|---|
| You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests. Please first reason before giving the final answer. The reasoning process enclosed within `<think> </think>`. The final answer is output after the `</think>` tag. | `<think>` … `</think>` [FINAL ANSWER] |

이 템플릿은 기본 추론 패턴을 확립하며, 모델이 `<think>` 태그 내에서 추론 과정을 전개한 후 최종 답변을 제시하도록 합니다.

**도구 통합 템플릿 (Table 7)**

| 시스템 프롬프트 | 응답 패턴 |
|---|---|
| Use Python interpreter tool to execute Python code. The code will not be shown to the user. This tool should be used for internal reasoning... ## Tools You have access to the following tools: {TOOL-DESCRIPTIONS} Important: ALWAYS adhere to this exact format for tool use: {TOOLCALL-FORMAT} | [MULTI-TURN TOOLCALL] [FINAL ANSWER] |

이 템플릿은 도구 호출 능력을 추가하되 명시적 추론 과정은 요구하지 않으며, `{TOOL-DESCRIPTIONS}`와 `{TOOLCALL-FORMAT}` 플레이스홀더가 특정 도구와 형식으로 대체됩니다.

**통합 추론-도구 템플릿 (Table 8)**

| 시스템 프롬프트 | 응답 패턴 |
|---|---|
| You are a helpful assistant with access to a Python interpreter. - You may use the Python tool **multiple times** during your reasoning, a.k.a in `<think></think>`, with a maximum of 20 code executions. - Call the Python tool early in your reasoning to aid in solving the task... | `<think>` [MULTI-TURN Thinking-Then-TOOLCALL] `</think>` [FINAL ANSWER] |

최종 템플릿은 추론 과정 내에서 도구 호출을 완전히 통합하며, 모델이 `<think>` 태그 내에서 최대 20회까지 도구를 실행하며 추론할 수 있도록 합니다. 이러한 점진적 접근법은 모델이 단순 추론에서 도구 사용, 그리고 추론과 도구의 완전한 통합으로 발전하도록 안내합니다.

### 비사고 모드 DeepSeek-V3.2 에이전트 평가

다음은 DeepSeek-V3.2의 비사고 모드와 사고 모드의 성능 비교입니다. Terminal Bench 2.0의 비사고 점수는 Claude Code 프레임워크로 평가되었으며, Terminus 프레임워크를 사용할 경우 39.3점을 기록했습니다.

| 벤치마크 (메트릭) | 비사고 모드 | 사고 모드 |
|---|---|---|
| **코드 에이전트** |
| Terminal Bench 2.0 (Acc) | 37.1 | 46.4 |
| SWE Verified (Resolved) | 72.1 | 73.1 |
| SWE Multilingual (Resolved) | 68.9 | 70.2 |
| **도구 사용** |
| ToolUse τ²-bench (Pass@1) | 77.2 | 80.3 |
| MCP-Universe (Success Rate) | 38.6 | 45.9 |
| MCP-Mark (Pass@1) | 26.5 | 38.0 |
| Tool-Decathlon (Pass@1) | 25.6 | 35.2 |

비사고 모드는 사고 모드에 비해 약간 낮은 성능을 보이지만 여전히 경쟁력 있는 수준을 유지합니다. 모든 벤치마크에서 사고 모드가 일관되게 더 높은 성능을 보여주며, 특히 Tool-Decathlon과 MCP-Mark 같은 복잡한 도구 사용 작업에서 추론 과정의 명시적 표현이 10점 이상의 성능 향상을 가져왔습니다.

### IOI, ICPC World Final, IMO, CMO 평가 방법

모든 경쟁 대회 평가에서 모델의 최대 생성 길이는 128K 토큰으로 설정되었으며, 도구나 인터넷 접근 없이 대회의 시간 및 시도 제한을 엄격히 준수했습니다.

IOI 평가는 공식 대회 규칙에 따라 문제당 최대 50회 제출을 허용하며 각 제출은 모든 하위 작업의 최대 점수로 채점됩니다. 각 문제에 대해 500개의 후보 솔루션을 먼저 샘플링한 후, 제공된 샘플 테스트 케이스를 통과하지 못하거나 길이 제약을 초과하는 무효 제출을 제거하는 초기 필터링을 수행했습니다. 이후 DeepSeek-V32-Exp 모델을 사용하여 모델이 명시적으로 문제 해결 불가능 또는 거부를 표시한 샘플을 식별하고 제거했습니다. 남은 유효한 후보 중에서 추론 경로가 가장 긴 50개 샘플을 최종 제출로 선택했습니다. 이러한 전략은 충분히 깊은 사고 과정을 거친 솔루션을 우선시하여 복잡한 문제에 대한 해결 품질을 높입니다.

ICPC 평가는 동일한 필터링 방법론을 적용했으나 초기 샘플 크기를 줄여 문제당 32개의 후보 솔루션을 생성하고 동일한 기준으로 제출을 선택했습니다. 이는 ICPC 문제의 특성과 시간 제약을 고려한 조정입니다.

IMO와 CMO 작업에서는 생성-검증-정제 루프를 사용했습니다. 모델은 완벽한 자체 평가를 달성하거나 최대 수정 한계에 도달할 때까지 반복적으로 솔루션을 개선하며, 이 과정은 DeepSeekMath의 검증된 방법론과 동일합니다. 각 반복에서 모델은 자신의 솔루션을 평가하고 오류를 식별한 후 개선된 버전을 생성하여, 수학적 증명의 정확성과 완전성을 점진적으로 향상시킵니다.
- - -
### References
* [DeepSeek-V3.2: Pushing the Frontier of Open Large Language Models](https://arxiv.org/pdf/2512.02556v1)