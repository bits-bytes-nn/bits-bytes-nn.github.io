---
layout: post
title: "DeepSeek-V3.2: Pushing the Frontier of Open Large Language Models"
date: 2025-12-02 09:25:14
author: "DeepSeek AI"
categories: ["Paper Reviews", "Language-Models"]
tags: ["DeepSeek-Sparse-Attention", "Scalable-Reinforcement-Learning-Framework", "Large-Scale-Agentic-Task-Synthesis-Pipeline", "Group-Relative-Policy-Optimization-Scaling", "Unbiased-KL-Estimate-for-RL", "Off-Policy-Sequence-Masking", "Keep-Routing-for-Mixture-of-Experts", "Thinking-Context-Management-for-Tool-Use", "Long-Chain-of-Thought-Cold-Start-Integration", "Multi-Stage-Agentic-Environment-Synthesis"]
cover: /assets/images/language-models.jpg
use_math: true
---
### TL;DR
#### 이 연구를 시작하게 된 배경과 동기는 무엇입니까?

최근 몇 년간 대규모 언어 모델의 발전은 눈부신 성과를 이루었지만, 오픈소스 모델과 상용 모델 간의 성능 격차가 점점 벌어지고 있는 현실에 직면하고 있습니다. GPT-5, Claude-4.5-Sonnet, Gemini 3.0과 같은 비공개 상용 모델들이 복잡한 추론 작업에서 급속도로 성능을 향상시키는 동안, Qwen3, GLM, MiniMax-M2 등의 오픈소스 모델들은 상대적으로 뒤처지고 있는 상황입니다. 이러한 격차는 단순한 성능 차이를 넘어 오픈소스 커뮤니티의 기술 혁신 능력에 대한 근본적인 의문을 제기합니다. DeepSeek 연구팀은 이 문제의 근본 원인을 분석하여 세 가지 핵심 결함을 식별했습니다. 첫째, 바닐라 어텐션 메커니즘의 $O(L^2)$ 계산 복잡도는 긴 시퀀스 처리에서 심각한 효율성 병목을 야기합니다. 둘째, 오픈소스 모델들이 사후 훈련 단계에 할당하는 계산 자원이 불충분하여 고급 추론 능력 개발이 제한됩니다. 셋째, AI 에이전트 시나리오에서 도구 사용 능력과 일반화 능력이 상용 모델에 비해 현저히 뒤처져 있습니다. 이러한 한계를 극복하기 위해 DeepSeek-V3.2는 아키텍처 혁신, 계산 투자 확대, 그리고 체계적인 데이터 합성이라는 세 가지 전략적 접근을 통해 오픈소스 모델의 새로운 가능성을 제시하고자 합니다.

#### 이 연구에서 제시하는 새로운 해결 방법은 무엇입니까?

DeepSeek-V3.2는 오픈소스 모델의 한계를 극복하기 위해 세 가지 혁신적인 기술을 제시합니다. 첫 번째 혁신은 **DeepSeek Sparse Attention (DSA)**로, 라이트닝 인덱서와 세밀한 토큰 선택 메커니즘으로 구성되어 있습니다. DSA는 쿼리 토큰이 모든 이전 토큰과 상호작용하는 대신 상위 k개의 관련 토큰만 선택하여 어텐션을 수행함으로써, 계산 복잡도를 $O(L^2)$에서 $O(Lk)$로 감소시킵니다. 여기서 $k \ll L$이므로 긴 문맥에서 상당한 계산량 절감이 이루어집니다. 라이트닝 인덱서는 인덱스 점수 $I_{t,s}=\sum_{j=1}^{H^{I}}w_{t,j}^{I}\cdot\text{ReLU}(\mathbf{q}^{I}\_{t,j}\cdot\mathbf{k}^{I}\_{s})$를 통해 각 쿼리 토큰이 어떤 토큰들을 선택할지 결정하며, 이는 Multi-Head Latent Attention (MLA)의 Multi-Query Attention 모드를 기반으로 구현되어 메모리 효율성을 극대화합니다.

두 번째 혁신은 **확장 가능한 강화학습 프레임워크**입니다. DeepSeek-V3.2는 사후 훈련에 사전 훈련 비용의 10%를 초과하는 계산 예산을 할당하여, 이는 오픈소스 모델에서는 전례 없는 수준의 투자입니다. Group Relative Policy Optimization (GRPO) 알고리즘을 기반으로 하는 이 프레임워크는 불편향 KL 추정, 오프-폴리시 시퀀스 마스킹, MoE 모델을 위한 Keep Routing, 샘플링 일관성을 위한 Keep Sampling Mask 등의 전략을 통해 훈련 안정성을 확보합니다. 이러한 기법들은 강화학습 훈련 중 발생할 수 있는 정책 발산, 오프-폴리시 문제, 그리고 라우팅 불일치 등의 문제를 효과적으로 해결합니다.

세 번째 혁신은 **대규모 에이전트 작업 합성 파이프라인**입니다. 이 파이프라인은 1,800개 이상의 서로 다른 환경과 85,000개의 복잡한 프롬프트를 생성하여 확장 가능한 에이전트 사후 훈련을 가능하게 합니다. 합성된 작업은 코드 에이전트(24,667개), 검색 에이전트(50,275개), 일반 에이전트(4,417개), 코드 인터프리터(5,908개)의 네 가지 범주로 구성되며, 각 범주는 실제 도구와 환경을 활용하거나 자동화된 환경 합성을 통해 생성됩니다. 특히 도구 호출 시나리오에서 사고 능력을 통합하기 위해 사고 컨텍스트 관리 메커니즘을 개발했으며, 이는 과거 추론 내용을 새로운 사용자 메시지가 도입될 때만 삭제하고 도구 관련 메시지만 추가될 때는 유지함으로써 토큰 효율성을 극대화합니다.

#### 제안된 방법은 어떻게 구현되었습니까?

DeepSeek-V3.2의 구현은 DeepSeek-V3.1-Terminus의 기본 체크포인트에서 시작하여 두 단계의 지속적 사전 훈련을 거칩니다. 첫 번째 단계는 **밀집 워밍업 단계**로, 라이트닝 인덱서를 초기화하기 위해 1,000 스텝 동안 진행되며 총 2.1B 토큰이 사용됩니다. 이 단계에서는 모든 모델 파라미터를 동결하고 인덱서만 훈련하여, 인덱서 출력을 주 어텐션 분포와 정렬하기 위해 KL 발산 손실 $\mathcal{L}^{I}=\sum_{t}\mathbb{D}\_{\mathrm{KL}}(p_{t,:}\,\|\,\text{Softmax}(I_{t,:}))$를 최소화합니다. 두 번째 단계는 **희소 훈련 단계**로, 15,000 스텝 동안 진행되며 총 943.7B 토큰이 사용됩니다. 이 단계에서는 세밀한 토큰 선택 메커니즘을 도입하고 모든 모델 파라미터를 최적화하여, 선택된 토큰 집합에 대해서만 분포를 정렬하는 수정된 손실 함수 $\mathcal{L}^{I}=\sum_{t}\mathbb{D}\_{\mathrm{KL}}(p_{t,\mathcal{S}\_{t}}\,\|\,\text{Softmax}(I_{t,\mathcal{S}_{t}}))$를 사용합니다. 각 쿼리 토큰에 대해 2,048개의 키-값 토큰을 선택하며, 학습률은 $7.3 \times 10^{-6}$로 설정됩니다.

사후 훈련 단계는 **전문가 증류**와 **혼합 강화학습 훈련**으로 구성됩니다. 전문가 증류에서는 수학, 프로그래밍, 일반 논리적 추론, 일반 에이전트 작업, 에이전트 코딩, 에이전트 검색의 여섯 가지 영역에 특화된 전문가 모델을 개발하고, 각 전문가는 사고 모드와 비사고 모드를 모두 지원합니다. 혼합 강화학습 훈련에서는 GRPO 알고리즘을 사용하여 추론, 에이전트, 그리고 인간 정렬 훈련을 하나의 강화학습 단계로 통합합니다. GRPO의 목표 함수는 $\mathcal{J}\_{\mathrm{GRPO}}(\theta)=\mathbb{E}\_{q\sim P(Q),\{o_{i}\}\_{i=1}^{G}\sim\pi_{\mathrm{old}}(\cdot \Vert q)}[\frac{1}{G}\sum_{i=1}^{G}\frac{1}{\lVert o_{i} \rVert}\sum_{t=1}^{\lVert o_{i} \rVert}\min(r_{i,t}(\theta)\hat{A}\_{i,t},\text{clip}(r_{i,t}(\theta),1-\varepsilon,1+\varepsilon)\hat{A}\_{i,t})-\beta\mathbb{D}\_{\mathrm{KL}}(\pi_{\theta}(o_{i,t})\,\|\,\pi_{\mathrm{ref}}(o_{i,t}))]$로 정의되며, 여기서 $r_{i,t}(\theta)$는 현재 정책과 이전 정책 사이의 중요도 샘플링 비율입니다.

강화학습 훈련의 안정성을 위해 여러 고급 기법이 적용됩니다. **불편향 KL 추정**은 중요도 샘플링 비율을 사용하여 KL 발산을 추정함으로써 그래디언트의 편향을 제거하고 안정적인 수렴을 촉진합니다. **오프-폴리시 시퀀스 마스킹**은 음의 어드밴티지를 가지면서 동시에 높은 정책 발산을 보이는 시퀀스를 마스킹하여 오프-폴리시 문제로 인한 불안정성을 완화합니다. **Keep Routing**은 추론 프레임워크에서 샘플링 중에 사용된 전문가 라우팅 경로를 보존하고 훈련 중에 동일한 라우팅을 강제하여 활성 파라미터 부분공간의 급격한 변화를 방지합니다. **Keep Sampling Mask**는 top-p 샘플링 중에 절단 마스크를 보존하고 훈련 중에 적용하여 두 정책이 동일한 행동 부분공간을 공유하도록 합니다.

#### 이 연구의 결과가 가지는 의미는 무엇입니까?

DeepSeek-V3.2는 다양한 벤치마크에서 인상적인 성능을 달성했습니다. 추론 작업에서 AIME 2025에서 93.1%, HMMT Feb 2025에서 92.5%, HMMT Nov 2025에서 90.2%의 정확도를 기록하여 GPT-5-High와 유사한 수준의 성능을 보였습니다. 코딩 작업에서는 Codeforces에서 2,386의 레이팅을 달성했으며, 코드 에이전트 평가에서 SWE-bench Verified에서 73.1%의 해결률을 기록했습니다. 검색 에이전트 평가에서는 BrowseComp에서 51.4점(컨텍스트 관리 적용 시 67.6점)을 달성했으며, 도구 사용 벤치마크에서 MCP-Universe에서 45.9%의 성공률을 기록했습니다. 이러한 성과는 오픈소스 모델이 적절한 아키텍처 개선, 충분한 계산 투자, 그리고 효과적인 데이터 합성을 통해 상용 모델에 근접할 수 있음을 입증합니다.

특히 주목할 점은 **DeepSeek-V3.2-Speciale**의 성과입니다. 이 모델은 추론 데이터만으로 훈련되고 강화학습 중 길이 패널티가 감소되어 더 긴 추론 과정을 허용합니다. 그 결과 2025년 국제 수학 올림피아드(IMO)에서 42점 만점에 35점을 획득하여 금메달 수준의 성능을 달성했으며, 국제 정보 올림피아드(IOI)에서는 600점 만점에 492점을 기록하여 10위를 차지했습니다. ICPC World Finals 2025에서는 12문제 중 10문제를 해결하여 2위에 해당하는 성과를 보였고, 중국 수학 올림피아드(CMO)에서는 126점 만점에 102점을 달성했습니다. 이러한 결과는 오픈소스 모델이 최상위 경쟁 대회에서도 탁월한 추론 능력을 발휘할 수 있음을 명확히 입증합니다.

그러나 연구팀은 현재의 한계점도 명확히 인식하고 있습니다. 첫째, 총 훈련 FLOPs가 적기 때문에 세계 지식의 폭이 Gemini-3.0-Pro와 같은 최전선 모델에 비해 뒤처져 있으며, 향후 사전 훈련 계산을 확장하여 이를 해소할 계획입니다. 둘째, 토큰 효율성이 여전히 과제로 남아 있습니다. DeepSeek-V3.2-Speciale는 AIME 2025에서 96.0%의 정확도를 달성하지만 23,000개의 토큰을 사용하는 반면, Gemini-3.0-Pro는 15,000개의 토큰으로 95.0%를 달성합니다. 셋째, 복잡한 작업을 해결하는 능력은 여전히 최전선 모델에 비해 열등합니다. 이러한 한계에도 불구하고 DeepSeek-V3.2는 오픈소스 대규모 언어 모델 개발의 새로운 이정표를 제시했으며, DSA를 통한 계산 효율성 개선, 대규모 강화학습을 통한 추론 능력 향상, 그리고 체계적인 에이전트 작업 합성을 통한 도구 사용 능력 강화는 모두 향후 오픈소스 모델 개발의 중요한 방향을 제시합니다. 특히 합성 에이전트 작업이 실제 환경으로 효과적으로 일반화된다는 것이 입증되었으며, 이는 대규모 데이터 합성이 모델의 견고성과 일반화 능력을 향상시키는 강력한 도구임을 보여줍니다.
- - -
# DeepSeek-V3.2: 오픈 대규모 언어 모델의 새로운 지평

## 초록

DeepSeek-V3.2는 높은 계산 효율성과 뛰어난 추론 및 에이전트 성능을 조화롭게 결합한 대규모 언어 모델입니다. 이 모델은 오픈소스 언어 모델과 상용 모델 간의 성능 격차를 줄이기 위한 세 가지 핵심 기술적 혁신을 제시합니다.

첫 번째 혁신은 DeepSeek Sparse Attention (DSA)입니다. DSA는 긴 문맥 시나리오에서 모델 성능을 유지하면서도 계산 복잡도를 대폭 줄이는 효율적인 어텐션 메커니즘입니다. 전통적인 바닐라 어텐션이 시퀀스 길이의 제곱에 비례하는 $O(L^2)$ 복잡도를 갖는 것과 달리, DSA는 희소 어텐션 기법을 통해 계산량을 선형 수준으로 감소시킵니다. 이러한 아키텍처 개선은 긴 문맥 처리가 필요한 실제 응용 환경에서 모델의 배포 가능성과 사후 훈련의 확장성을 크게 향상시킵니다.

두 번째 혁신은 확장 가능한 강화학습 프레임워크입니다. 안정적인 강화학습 프로토콜을 구현하고 사후 훈련 단계의 계산 자원을 대폭 확장함으로써, DeepSeek-V3.2는 [GPT-5](https://openai.com/index/introducing-gpt-5)와 유사한 성능을 달성합니다. 특히 주목할 점은 사후 훈련에 할당된 계산 예산이 사전 훈련 비용의 10%를 초과한다는 것입니다. 이는 오픈소스 모델에서는 보기 드문 수준의 투자이며, 이를 통해 고급 추론 능력을 확보할 수 있었습니다. 더 나아가 높은 계산량을 투입한 변형 모델인 DeepSeek-V3.2-Speciale는 GPT-5를 능가하며 [Gemini-3.0-Pro](https://deepmind.google/technologies/gemini/pro/)와 동등한 추론 능숙도를 보입니다.

세 번째 혁신은 대규모 에이전트 작업 합성 파이프라인입니다. 추론 능력을 도구 사용 시나리오에 통합하기 위해, 체계적으로 훈련 데이터를 대규모로 생성하는 새로운 합성 파이프라인이 개발되었습니다. 이 방법론은 1,800개 이상의 서로 다른 환경과 85,000개의 복잡한 프롬프트를 생성하여 확장 가능한 에이전트 사후 훈련을 가능하게 합니다. 그 결과 복잡한 상호작용 환경에서의 일반화 능력과 지시 준수 견고성이 상당히 향상되었습니다.

![DeepSeek-V3.2와 경쟁 모델들의 벤치마크 비교](https://arxiv.org/html/2512.02556/x1.png)

위 그림은 DeepSeek-V3.2와 주요 경쟁 모델들의 성능을 다양한 추론 및 에이전트 능력 벤치마크에서 비교한 것입니다. AIME 2025, HMMT 2023 February 대회, HLE의 텍스트 전용 부분집합, Codeforces, SWE, Terminal Bench 2.0, Tool Decathlon 등 여러 과제에서 DeepSeek-V3.2-Speciale, DeepSeek-V3.2-Thinking, GPT-5-High, Claude-4.5-Sonnet, Gemini-3.0-Pro의 점수가 제시되어 있습니다. 이 비교는 다양한 추론 및 에이전트 작업에서 각 모델의 능력을 평가하고 이해하는 데 유용한 통찰을 제공합니다.

DeepSeek-V3.2-Speciale는 2025년 국제 수학 올림피아드(IMO)와 국제 정보 올림피아드(IOI)에서 금메달 수준의 성능을 달성했습니다. IMO에서는 42점 만점에 35점을 획득했으며, IOI에서는 600점 만점에 492점을 기록하여 10위를 차지했습니다. 또한 ICPC World Finals 2025에서는 12문제 중 10문제를 해결하여 2위에 해당하는 성과를 보였고, 중국 수학 올림피아드(CMO)에서는 126점 만점에 102점을 달성했습니다. 이러한 결과는 오픈소스 모델이 최상위 경쟁 대회에서도 탁월한 추론 능력을 발휘할 수 있음을 입증합니다.

## 서론

[추론 모델](https://openai.com/index/learning-to-reason-with-llms/)의 출시는 대규모 언어 모델의 진화에서 중요한 전환점이었습니다. 특히 검증 가능한 분야에서 전반적인 성능이 상당히 향상되는 계기가 되었습니다. 이 이정표 이후 대규모 언어 모델의 능력은 빠르게 발전해왔습니다. 그러나 최근 몇 달 동안 뚜렷한 분기가 나타났습니다. [Qwen3](https://qwenlm.github.io/blog/qwen3/), [GLM](https://arxiv.org/abs/2508.06471), MiniMax-M2, [k2-thinking](https://arxiv.org/abs/2509.07604) 등 오픈소스 커뮤니티가 계속해서 진전을 이루고 있는 동안, [GPT-5](https://openai.com/index/introducing-gpt-5), [Claude-4.5-Sonnet](https://www.anthropic.com/news/claude-4-5-sonnet), [Gemini 3.0](https://deepmind.google/technologies/gemini/) 같은 비공개 상용 모델의 성능 궤적은 훨씬 더 가파른 속도로 가속화되었습니다. 결과적으로 수렴하기는커녕 비공개 모델과 오픈소스 모델 간의 성능 격차는 오히려 확대되고 있으며, 상용 시스템은 복잡한 작업에서 점점 더 우수한 능력을 보여주고 있습니다.

분석을 통해 복잡한 작업에서 오픈소스 모델의 능력을 제한하는 세 가지 중요한 결함이 확인되었습니다. 첫째, 아키텍처 측면에서 [바닐라 어텐션](https://arxiv.org/abs/1706.03762) 메커니즘에 대한 과도한 의존은 긴 시퀀스에 대한 효율성을 심각하게 제약합니다. 바닐라 어텐션은 시퀀스 길이 $L$에 대해 $O(L^2)$의 계산 복잡도를 가지므로, 문맥 길이가 증가할수록 계산 비용이 기하급수적으로 증가합니다. 이러한 비효율성은 확장 가능한 배포와 효과적인 사후 훈련 모두에 상당한 장애물이 됩니다. 둘째, 자원 할당 측면에서 오픈소스 모델은 사후 훈련 단계에서 계산 투자가 불충분하여 어려운 작업에서의 성능이 제한됩니다. 많은 오픈소스 프로젝트가 사전 훈련에는 상당한 자원을 투입하지만, 사후 훈련에는 상대적으로 적은 예산만을 할당합니다. 셋째, AI 에이전트의 맥락에서 오픈소스 모델은 상용 모델에 비해 일반화 능력과 지시 준수 능력에서 현저한 지연을 보입니다. [MCP-Mark](https://arxiv.org/abs/2509.24002), [MCP-Universe](https://arxiv.org/abs/2508.14704), [Tool Decathlon](https://arxiv.org/abs/2510.25726) 같은 벤치마크에서 이러한 격차가 두드러지며, 이는 실제 배포 환경에서의 효과성을 저해합니다.

이러한 중요한 한계를 해결하기 위해 세 가지 주요 솔루션이 제안되었습니다. 첫째, 계산 복잡도를 대폭 줄이도록 설계된 매우 효율적인 어텐션 메커니즘인 DSA가 도입되었습니다. 이 아키텍처는 효율성 병목 현상을 효과적으로 해결하여 긴 문맥 시나리오에서도 모델 성능을 유지합니다. DSA는 라이트닝 인덱서와 세밀한 토큰 선택 메커니즘으로 구성되어 있으며, 핵심 어텐션 복잡도를 $O(L^2)$에서 $O(Lk)$로 줄입니다. 여기서 $k$는 선택된 키-값 토큰의 수로, $L$보다 훨씬 작습니다.

둘째, 사후 훈련 단계에서 계산을 대폭 확장할 수 있는 안정적이고 확장 가능한 강화학습 프로토콜이 개발되었습니다. 이 프레임워크는 사전 훈련 비용의 10%를 초과하는 사후 훈련 계산 예산을 할당하여 고급 능력을 확보합니다. 이는 오픈소스 모델에서는 전례 없는 수준의 투자입니다. 강화학습 프로토콜은 GRPO(Group Relative Policy Optimization) 알고리즘을 기반으로 하며, 불편향 KL 추정, 오프-폴리시 시퀀스 마스킹, MoE 모델을 위한 Keep Routing, 샘플링 일관성을 위한 Keep Sampling Mask 등의 전략을 통해 안정성을 확보합니다.

셋째, 도구 사용 시나리오에서 일반화 가능한 추론을 촉진하기 위한 새로운 파이프라인이 제안되었습니다. 먼저 [DeepSeek-V3](https://arxiv.org/abs/2412.19437) 방법론을 활용하여 추론과 도구 사용을 단일 궤적 내에서 통합하는 콜드 스타트 단계를 구현합니다. 이어서 1,800개 이상의 서로 다른 환경과 85,000개의 복잡한 프롬프트를 생성하는 대규모 에이전트 작업 합성으로 진행됩니다. 합성된 작업은 코드 에이전트(24,667개 작업), 검색 에이전트(50,275개 작업), 일반 에이전트(4,417개 작업), 코드 인터프리터(5,908개 작업)의 네 가지 범주로 구성됩니다. 이러한 광범위한 합성 데이터는 강화학습 프로세스를 구동하여 에이전트 맥락에서 모델의 일반화 능력과 지시 준수 능력을 크게 향상시킵니다.

DeepSeek-V3.2는 Kimi-k2-thinking 및 GPT-5와 여러 추론 벤치마크에서 유사한 성능을 달성합니다. 또한 DeepSeek-V3.2는 오픈 모델의 에이전트 능력을 크게 향상시켜 MCP-Mark, MCP-Universe, Tool Decathlon에서 소개된 롱테일 에이전트 작업에서 뛰어난 숙련도를 보여줍니다. 에이전트 시나리오에서 DeepSeek-V3.2는 매우 비용 효율적인 대안으로 부상하며, 상당히 낮은 비용으로 오픈 모델과 최전선 상용 모델 간의 성능 격차를 크게 줄입니다.

특히 추론 영역에서 오픈 모델의 한계를 뛰어넘기 위해 길이 제약을 완화하여 DeepSeek-V3.2-Speciale가 개발되었습니다. 그 결과 DeepSeek-V3.2-Speciale는 최고의 비공개 시스템인 Gemini-3.0-Pro와 성능 동등성을 달성합니다. IOI 2025에서 금메달 수준의 성능을 보이며, ICPC World Final 2025, IMO 2025, CMO 2025에서도 금메달 수준의 결과를 기록했습니다. 이러한 성취는 적절한 아키텍처 개선, 충분한 계산 투자, 효과적인 데이터 합성 전략이 결합될 때 오픈소스 모델이 최상위 경쟁에서도 뛰어난 성능을 발휘할 수 있음을 보여줍니다.
## DeepSeek-V3.2 아키텍처

DeepSeek-V3.2는 DeepSeek-V3.2-Exp와 정확히 동일한 아키텍처를 사용합니다. DeepSeek-V3.1의 마지막 버전인 DeepSeek-V3.1-Terminus와 비교했을 때, DeepSeek-V3.2의 유일한 아키텍처 수정 사항은 지속적 훈련을 통해 DeepSeek Sparse Attention (DSA)을 도입한 것입니다.

### DeepSeek Sparse Attention

DSA의 프로토타입은 두 가지 핵심 구성 요소로 이루어져 있습니다. 첫 번째는 라이트닝 인덱서이고, 두 번째는 세밀한 토큰 선택 메커니즘입니다. 라이트닝 인덱서는 쿼리 토큰 $\mathbf{h}\_{t}\in\mathbb{R}^{d}$와 이전 토큰 $\mathbf{h}\_{s}\in\mathbb{R}^{d}$ 사이의 인덱스 점수 $I_{t,s}$를 계산하여 쿼리 토큰이 어떤 토큰들을 선택할지 결정합니다. 이 인덱스 점수는 다음과 같이 계산됩니다.

$$I_{t,s}=\sum_{j=1}^{H^{I}}w_{t,j}^{I}\cdot\text{ReLU}\left(\mathbf{q}^{I}_{t,j}\cdot\mathbf{k}^{I}\_{s}\right),$$

여기서 $H^{I}$는 인덱서 헤드의 수를 나타냅니다. $\mathbf{q}^{I}\_{t,j}\in\mathbb{R}^{d^{I}}$와 $w_{t,j}^{I}\in\mathbb{R}$는 쿼리 토큰 $\mathbf{h}\_{t}$로부터 유도되며, $\mathbf{k}^{I}\_{s}\in\mathbb{R}^{d^{I}}$는 이전 토큰 $\mathbf{h}\_{s}$로부터 유도됩니다. 활성화 함수로 ReLU를 선택한 이유는 처리량 측면에서의 고려 때문입니다.

이 인덱스 점수 계산 방식을 이해하기 위해 각 구성 요소를 살펴보겠습니다. 쿼리 토큰에서 유도된 $\mathbf{q}^{I}\_{t,j}$는 각 인덱서 헤드 $j$에 대한 쿼리 벡터이며, 이는 현재 토큰이 어떤 정보를 찾고 있는지를 나타냅니다. 이전 토큰에서 유도된 $\mathbf{k}^{I}\_{s}$는 키 벡터로, 해당 토큰이 제공할 수 있는 정보를 표현합니다. 이 두 벡터의 내적 $\mathbf{q}^{I}\_{t,j}\cdot\mathbf{k}^{I}\_{s}$는 쿼리와 키 사이의 유사도를 측정하며, ReLU 활성화 함수를 통과시켜 음수 값을 제거합니다. 각 헤드의 결과에 가중치 $w_{t,j}^{I}$를 곱하고 모든 헤드에 걸쳐 합산하여 최종 인덱스 점수를 얻습니다.

라이트닝 인덱서가 각 쿼리 토큰 $\mathbf{h}\_{t}$에 대한 인덱스 점수 $\{I_{t,s}\}$를 계산하면, 세밀한 토큰 선택 메커니즘이 작동합니다. 이 메커니즘은 상위 k개의 인덱스 점수에 해당하는 키-값 엔트리 $\{\mathbf{c}\_{s}\}$만을 검색합니다. 그런 다음 어텐션 출력 $\mathbf{u}\_{t}$는 쿼리 토큰 $\mathbf{h}\_{t}$와 희소하게 선택된 키-값 엔트리 $\{\mathbf{c}_{s}\}$ 사이에 어텐션 메커니즘을 적용하여 계산됩니다.

$$\mathbf{u}_{t}=\text{Attn}\left(\mathbf{h}_{t},\left\{\mathbf{c}_{s}\mid I_{t,s}\in\text{Top-k}\left(I_{t,:}\right)\right\}\right).$$

이 수식에서 $\text{Top-k}(I_{t,:})$는 쿼리 토큰 $t$에 대한 모든 인덱스 점수 중 상위 k개를 선택하는 연산을 의미합니다. 조건 $I_{t,s}\in\text{Top-k}(I_{t,:})$를 만족하는 키-값 엔트리들만이 실제 어텐션 계산에 사용되므로, 전체 시퀀스가 아닌 선택된 일부 토큰들에 대해서만 어텐션을 계산하게 됩니다. 이러한 희소 선택 방식은 계산 복잡도를 시퀀스 길이 $L$의 제곱에 비례하는 $O(L^2)$에서 선택된 토큰 수 $k$에 선형적으로 비례하는 $O(Lk)$로 감소시킵니다. 여기서 $k \ll L$이므로 긴 시퀀스에서 상당한 계산량 절감이 이루어집니다.

DeepSeek-V3.1-Terminus로부터의 지속적 훈련을 고려하여, DeepSeek-V3.2는 [Multi-Head Latent Attention (MLA)](https://arxiv.org/pdf/2405.04434v5)를 기반으로 DSA를 구현합니다. 커널 수준에서 각 키-값 엔트리는 계산 효율성을 위해 여러 쿼리에 걸쳐 공유되어야 합니다. 이는 [Native Sparsity](https://arxiv.org/abs/2502.11089)에서 논의된 바와 같이 메모리 접근 패턴을 최적화하고 GPU 활용도를 높이는 데 필수적입니다. 따라서 DSA는 MLA의 [Multi-Query Attention (MQA)](https://arxiv.org/pdf/1911.02150v1) 모드를 기반으로 구현되며, 여기서 각 잠재 벡터(MLA의 키-값 엔트리)는 쿼리 토큰의 모든 쿼리 헤드에 걸쳐 공유됩니다.

![DeepSeek-V3.2의 어텐션 아키텍처](https://arxiv.org/html/2512.02556/x2.png)

MLA 기반 DSA 아키텍처는 위 다이어그램에 나타나 있습니다. 녹색 부분은 DSA가 인덱서에 따라 상위 k개의 키-값 엔트리를 선택하는 방식을 보여줍니다. 이 구조에서 라이트닝 인덱서는 먼저 모든 토큰에 대한 인덱스 점수를 계산하고, Top-k Selector가 가장 높은 점수를 가진 k개의 토큰을 선택합니다. 선택된 토큰들의 키-값 정보만이 Multi-Query Attention 모듈로 전달되어 최종 어텐션 출력을 생성합니다. 이러한 설계는 MLA의 효율적인 메모리 사용과 DSA의 희소 선택을 결합하여 긴 문맥 처리에서 최적의 성능을 달성합니다.

DeepSeek-V3.2의 오픈소스 구현은 [Hugging Face 저장소](https://huggingface.co/deepseek-ai/DeepSeek-V3.2-Exp/tree/main/inference)에서 제공되어 세부 사항을 명확하게 확인할 수 있습니다. 이 구현을 통해 DSA의 실제 작동 방식과 MLA와의 통합 방법을 구체적으로 이해할 수 있습니다.

#### 지속적 사전 훈련

DeepSeek-V3.2의 지속적 사전 훈련은 문맥 길이가 128K로 확장된 DeepSeek-V3.1-Terminus의 기본 체크포인트에서 시작됩니다. 이 과정은 두 가지 훈련 단계로 구성되며, 두 단계 모두 DeepSeek-V3.1-Terminus의 128K 긴 문맥 확장 데이터와 완전히 동일한 훈련 데이터 분포를 사용합니다.

첫 번째 단계는 밀집 워밍업 단계입니다. 이 단계에서는 라이트닝 인덱서를 초기화하기 위해 짧은 워밍업 기간을 사용합니다. 밀집 어텐션을 유지하면서 라이트닝 인덱서를 제외한 모든 모델 파라미터를 동결합니다. 인덱서 출력을 주 어텐션 분포와 정렬하기 위해, $t$번째 쿼리 토큰에 대해 먼저 모든 어텐션 헤드에 걸쳐 주 어텐션 점수를 합산합니다. 이 합을 시퀀스 차원을 따라 L1 정규화하여 목표 분포 $p_{t,:}\in\mathbb{R}^{t}$를 생성합니다. 이 목표 분포를 기반으로 인덱서의 훈련 목표로 KL 발산 손실을 설정합니다.

$$\mathcal{L}^{I}=\sum_{t}\mathbb{D}_{\mathrm{KL}}\left(p_{t,:}\,\middle\|\,\text{Softmax}(I_{t,:})\right).$$

이 손실 함수는 인덱서가 생성하는 점수 분포 $\text{Softmax}(I_{t,:})$가 실제 어텐션 분포 $p_{t,:}$와 최대한 유사하도록 학습시킵니다. KL 발산은 두 확률 분포 간의 차이를 측정하는 지표로, 이 값이 작을수록 인덱서가 중요한 토큰을 정확하게 식별한다는 의미입니다. 워밍업을 위해 $10^{-3}$의 학습률을 사용하며, 인덱서를 단 1000 스텝 동안만 훈련합니다. 각 스텝은 128K 토큰의 16개 시퀀스로 구성되어 총 2.1B 토큰이 사용됩니다.

두 번째 단계는 희소 훈련 단계입니다. 인덱서 워밍업 이후, 세밀한 토큰 선택 메커니즘을 도입하고 모든 모델 파라미터를 최적화하여 모델이 DSA의 희소 패턴에 적응하도록 합니다. 이 단계에서도 인덱서 출력을 주 어텐션 분포와 계속 정렬하지만, 선택된 토큰 집합 $\mathcal{S}_{t}=\{s\mid I_{t,s}\in\text{Top-k}(I_{t,:})\}$만을 고려합니다.

$$\mathcal{L}^{I}=\sum_{t}\mathbb{D}_{\mathrm{KL}}\left(p_{t,\mathcal{S}_{t}}\,\middle\|\,\text{Softmax}(I_{t,\mathcal{S}_{t}})\right).$$

이 수정된 손실 함수는 선택된 토큰들에 대해서만 분포를 정렬합니다. $p_{t,\mathcal{S}\_{t}}$는 선택된 토큰 집합에 대한 목표 분포이며, $I_{t,\mathcal{S}_{t}}$는 해당 토큰들에 대한 인덱스 점수입니다. 이러한 접근 방식은 인덱서가 희소 선택 환경에서도 효과적으로 작동하도록 보장합니다.

주목할 점은 별도 최적화를 위해 계산 그래프에서 인덱서 입력을 분리한다는 것입니다. 인덱서의 훈련 신호는 오직 $\mathcal{L}^{I}$로부터만 오며, 주 모델의 최적화는 오직 언어 모델링 손실에 따라 이루어집니다. 이러한 분리는 인덱서와 주 모델이 각자의 목표에 집중하여 학습할 수 있게 하며, 훈련 안정성을 향상시킵니다. 희소 훈련 단계에서는 $7.3 \times 10^{-6}$의 학습률을 사용하고, 각 쿼리 토큰에 대해 2048개의 키-값 토큰을 선택합니다. 주 모델과 인덱서를 모두 15000 스텝 동안 훈련하며, 각 스텝은 128K 토큰의 480개 시퀀스로 구성되어 총 943.7B 토큰이 사용됩니다.

### 동등성 평가

2025년 9월에 DeepSeek-V3.2-Exp를 다양한 능력에 초점을 맞춘 벤치마크 모음에서 평가하고 유사한 성능을 보이는 DeepSeek-V3.1-Terminus와 비교했습니다. DeepSeek-V3.2-Exp는 긴 시퀀스에서 계산 효율성을 크게 향상시키면서도, 짧은 문맥과 긴 문맥 작업 모두에서 DeepSeek-V3.1-Terminus와 비교하여 실질적인 성능 저하가 관찰되지 않았습니다.

인간 선호도 평가는 본질적으로 편향에 취약하므로, 새로 개발된 기본 모델에 대한 사용자 선호도를 근사하기 위한 간접 평가 프레임워크로 ChatbotArena를 사용했습니다. DeepSeek-V3.1-Terminus와 DeepSeek-V3.2-Exp는 동일한 사후 훈련 전략을 공유하며, 2025년 11월 10일에 수행된 평가에서 얻은 Elo 점수가 매우 근접합니다. 이러한 결과는 새로운 기본 모델이 희소 어텐션 메커니즘을 통합했음에도 불구하고 이전 버전과 동등한 성능을 달성한다는 것을 시사합니다.

DeepSeek-V3.2-Exp 출시 이후, 이전에 보지 못한 테스트 세트를 사용하여 여러 독립적인 긴 문맥 평가가 수행되었습니다. 대표적인 벤치마크는 [AA-LCR](https://artificialanalysis.ai/evaluations/artificial-analysis-long-context-reasoning)로, DeepSeek-V3.2-Exp는 추론 모드에서 DeepSeek-V3.1-Terminus보다 4점 높은 점수를 기록했습니다. [Fiction.liveBench 평가](https://fiction.live/stories/Fiction-liveBench-April-6-2025/oQdzQvKHw8JyXbN87)에서 DeepSeek-V3.2-Exp는 여러 지표에서 DeepSeek-V3.1-Terminus를 지속적으로 능가했습니다. 이러한 증거는 DeepSeek-V3.2-Exp의 기본 체크포인트가 긴 문맥 작업에서 성능 저하가 없음을 나타냅니다.

### 추론 비용

DSA는 주 모델의 핵심 어텐션 복잡도를 $O(L^2)$에서 $O(Lk)$로 감소시킵니다. 여기서 $k$는 선택된 토큰의 수이며 $k \ll L$입니다. 라이트닝 인덱서는 여전히 $O(L^2)$의 복잡도를 가지지만, DeepSeek-V3.1-Terminus의 MLA에 비해 훨씬 적은 계산을 필요로 합니다. 최적화된 구현과 결합하여, DSA는 긴 문맥 시나리오에서 상당한 종단 간 속도 향상을 달성합니다.

![프리필링 단계의 추론 비용](https://arxiv.org/html/2512.02556/x3.png)

![디코딩 단계의 추론 비용](https://arxiv.org/html/2512.02556/x4.png)

프리필링과 디코딩 단계의 비용 분석 그래프는 DeepSeek-V3.1-Terminus와 DeepSeek-V3.2의 토큰 비용이 시퀀스 내 토큰 위치에 따라 어떻게 변화하는지를 보여줍니다. 이러한 비용은 시간당 2 USD의 임대 가격으로 H800 GPU에 배포된 실제 서비스를 벤치마킹하여 추정되었습니다. 짧은 시퀀스 프리필링의 경우, 짧은 문맥 조건에서 더 높은 효율성을 달성할 수 있는 마스크된 MHA 모드를 특별히 구현하여 DSA를 시뮬레이션합니다.

프리필링 단계 그래프에서 볼 수 있듯이, 토큰 위치가 증가함에 따라 DeepSeek-V3.1-Terminus의 비용은 급격히 상승하는 반면, DeepSeek-V3.2는 훨씬 완만한 증가를 보입니다. 이는 DSA의 희소 선택 메커니즘이 긴 시퀀스에서 계산량을 효과적으로 제어한다는 것을 의미합니다. 디코딩 단계에서도 유사한 패턴이 관찰되며, 특히 긴 문맥에서 DeepSeek-V3.2의 비용 효율성이 두드러집니다. 이러한 비용 절감은 실제 배포 환경에서 모델의 경제성을 크게 향상시키며, 긴 문맥을 처리하는 응용 프로그램에서 특히 중요한 이점을 제공합니다.
## 사후 훈련

DeepSeek-V3.2는 지속적 사전 훈련이 완료된 후 사후 훈련 과정을 거쳐 최종 모델로 완성됩니다. 이 사후 훈련 단계에서도 희소 지속 사전 훈련 단계와 동일한 방식으로 희소 어텐션이 적용됩니다. DeepSeek-V3.2는 DeepSeek-V3.2-Exp와 동일한 사후 훈련 파이프라인을 유지하며, 이 파이프라인은 전문가 증류와 혼합 강화학습 훈련이라는 두 가지 핵심 단계로 구성됩니다.

### 전문가 증류

전문가 증류는 각 작업 영역에 특화된 전문 모델을 먼저 개발하는 전략입니다. 모든 전문가 모델은 동일한 사전 훈련된 DeepSeek-V3.2 기본 체크포인트에서 파인튜닝되어 일관된 기반 능력을 공유하면서도 각자의 전문 영역에서 최고 수준의 성능을 달성합니다. 전문가 모델이 다루는 영역은 수학, 프로그래밍, 일반 논리적 추론, 일반 에이전트 작업, 에이전트 코딩, 에이전트 검색의 여섯 가지이며, 각 영역은 사고 모드와 비사고 모드를 모두 지원합니다.

각 전문가 모델은 대규모 강화학습 계산 자원을 통해 훈련됩니다. 특히 주목할 점은 긴 체인 오브 소트 추론을 위한 사고 모드와 직접적인 응답 생성을 위한 비사고 모드에 대해 서로 다른 모델을 사용하여 훈련 데이터를 생성한다는 것입니다. 이러한 이원화된 접근 방식은 각 모드의 특성에 맞는 최적화된 데이터를 생성할 수 있게 합니다.

전문가 모델이 준비되면 이들은 최종 체크포인트를 위한 도메인별 데이터를 생성하는 데 활용됩니다. 실험 결과는 증류된 데이터로 훈련된 모델이 도메인별 전문가의 성능과 비교하여 미미한 차이만을 보이며, 이러한 작은 성능 격차는 후속 강화학습 훈련을 통해 효과적으로 해소된다는 것을 보여줍니다.

### 혼합 강화학습 훈련

DeepSeek-V3.2는 강화학습 훈련 알고리즘으로 Group Relative Policy Optimization (GRPO)를 채택합니다. GRPO는 DeepSeekMath와 DeepSeek-R1 연구에서 소개된 방법으로, 그룹 내 상대적 성능을 기반으로 정책을 최적화하는 효율적인 알고리즘입니다.

DeepSeek-V3.2-Exp와 마찬가지로, 추론, 에이전트, 그리고 인간 정렬 훈련을 하나의 강화학습 단계로 통합합니다. 이 접근 방식은 다양한 영역에서 성능의 균형을 효과적으로 달성하면서도 다단계 훈련 패러다임에서 흔히 발생하는 치명적인 망각 문제를 회피합니다. 여러 단계로 나누어 훈련할 경우 각 단계에서 이전에 학습한 능력이 손실될 수 있는데, 통합 훈련 방식은 이러한 문제를 본질적으로 방지합니다.

추론 및 에이전트 작업에 대해서는 규칙 기반 결과 보상, 길이 패널티, 언어 일관성 보상을 사용합니다. 일반 작업에 대해서는 생성형 보상 모델을 사용하며, 각 프롬프트마다 평가를 위한 자체 루브릭이 존재합니다. 이러한 차별화된 보상 체계는 각 작업 유형의 특성에 맞는 최적화를 가능하게 합니다.

### DeepSeek-V3.2와 DeepSeek-V3.2-Speciale

DeepSeek-V3.2는 추론, 에이전트, 인간 정렬 데이터를 전문가로부터 증류하여 통합하고, 수천 스텝의 지속적인 강화학습 훈련을 거쳐 최종 체크포인트에 도달합니다. 확장된 사고의 잠재력을 조사하기 위해 실험적 변형인 DeepSeek-V3.2-Speciale도 개발되었습니다.

DeepSeek-V3.2-Speciale는 추론 데이터만으로 훈련되며 강화학습 중 길이 패널티가 감소되었습니다. 추가로 수학적 증명 능력을 향상시키기 위해 DeepSeekMath-V2의 데이터셋과 보상 방법을 통합했습니다. 이 모델은 더 긴 추론 과정을 허용함으로써 복잡한 문제에 대한 심층적인 탐구를 가능하게 합니다.

### GRPO 확장

GRPO 알고리즘의 목표는 다음과 같이 정의됩니다. 주어진 질문 $q$에 대해 이전 정책 $\pi_{\mathrm{old}}$로부터 샘플링된 응답 그룹 $\{o_{1},\cdots,o_{G}\}$에 대하여, 정책 모델 $\pi_{\theta}$는 다음 목표 함수를 최대화합니다.

$$\mathcal{J}_{\mathrm{GRPO}}(\theta)=\mathbb{E}_{q\sim P(Q),\{o_{i}\}_{i=1}^{G}\sim\pi_{\mathrm{old}}(\cdot \Vert q)}\Bigg[\frac{1}{G}\sum_{i=1}^{G}\frac{1}{\lVert o_{i} \rVert}\sum_{t=1}^{\lVert o_{i} \rVert}\min\left(r_{i,t}(\theta)\hat{A}_{i,t},\text{clip}\left(r_{i,t}(\theta),1-\varepsilon,1+\varepsilon\right)\hat{A}_{i,t}\right)-\beta\mathbb{D}_{\mathrm{KL}}\left(\pi_{\theta}(o_{i,t})\Vert\pi_{\mathrm{ref}}(o_{i,t})\right)\Bigg],$$

여기서 $r_{i,t}(\theta)=\frac{\pi_{\theta}(o_{i,t} \Vert q,o_{i,<t})}{\pi_{\mathrm{old}}(o_{i,t} \Vert q,o_{i,<t})}$는 현재 정책과 이전 정책 사이의 중요도 샘플링 비율입니다. 이 비율은 현재 정책이 특정 토큰을 생성할 확률이 이전 정책에 비해 얼마나 높은지를 나타냅니다. $\varepsilon$과 $\beta$는 각각 클리핑 범위와 KL 패널티 강도를 조절하는 하이퍼파라미터입니다.

$\hat{A}\_{i,t}$는 토큰 $o_{i,t}$의 어드밴티지로, 그룹 내에서 결과 보상을 정규화하여 추정됩니다. 구체적으로, 보상 모델 집합이 그룹의 각 출력 $o_{i}$에 대해 결과 보상 $R_{i}$를 점수화하여 총 $G$개의 보상 $\boldsymbol{R}=\{R_{1},\cdots,R_{G}\}$를 생성합니다. 토큰 $o_{i,t}$의 어드밴티지는 출력 $o_{i}$의 보상에서 그룹의 평균 보상을 뺀 값으로 계산됩니다.

$$\hat{A}_{i,t}=R_{i}-\text{mean}(\boldsymbol{R}).$$

이 공식은 각 출력이 그룹 평균 대비 상대적으로 얼마나 우수한지를 측정합니다. 양의 어드밴티지는 평균보다 나은 출력을 나타내며, 음의 어드밴티지는 평균보다 못한 출력을 의미합니다.

다음 내용에서는 GRPO 알고리즘을 기반으로 구축된 추가 전략들을 소개하며, 이러한 전략들이 강화학습 확장을 안정화시킵니다.

#### 불편향 KL 추정

토큰 $o_{i,t}$가 이전 정책 $\pi_{\mathrm{old}}(\cdot \Vert q,o_{i,<t})$로부터 샘플링되었다는 점을 고려하여, K3 추정기를 수정하여 현재 정책 $\pi_{\theta}$와 이전 정책 $\pi_{\mathrm{old}}$ 사이의 중요도 샘플링 비율을 사용한 불편향 KL 추정치를 얻습니다.

$$\mathbb{D}_{\mathrm{KL}}\left(\pi_{\theta}(o_{i,t})\,\middle\|\,\pi_{\mathrm{ref}}(o_{i,t})\right)=\frac{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}{\pi_{\mathrm{old}}(o_{i,t}|q,o_{i,<t})}\left(\frac{\pi_{\mathrm{ref}}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}-\log\frac{\pi_{\mathrm{ref}}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}-1\right).$$

이 수정의 직접적인 결과로, 이 KL 추정기의 그래디언트가 불편향이 되어 체계적인 추정 오류를 제거하고 안정적인 수렴을 촉진합니다. 이는 특히 샘플링된 토큰이 참조 정책에 비해 현재 정책에서 상당히 낮은 확률을 가질 때, 즉 $\pi_{\theta}\ll\pi_{\mathrm{ref}}$인 경우 원래의 K3 추정기와 극명하게 대조됩니다. 이러한 경우 K3 추정기의 그래디언트는 이러한 토큰의 우도를 최대화하기 위해 불균형적으로 큰 무제한 가중치를 할당하여, 노이즈가 많은 그래디언트 업데이트를 초래하고 후속 반복에서 샘플 품질을 저하시키며 불안정한 훈련 동역학을 야기합니다.

다음 코드는 불편향 KL 추정을 구현하는 방법을 보여줍니다.

```python
def unbiased_kl_estimate(pi_theta, pi_old, pi_ref, token, context):
    """
    중요도 샘플링을 사용한 불편향 KL 발산 추정

    Args:
        pi_theta: 현재 정책의 토큰 확률
        pi_old: 이전 정책(샘플링 정책)의 토큰 확률
        pi_ref: 참조 정책의 토큰 확률
        token: 평가할 토큰
        context: 토큰의 컨텍스트

    Returns:
        불편향 KL 발산 추정치
    """
    # 중요도 샘플링 비율 계산
    importance_ratio = pi_theta(token | context) / pi_old(token | context)

    # 참조 정책 대비 현재 정책의 비율
    ref_ratio = pi_ref(token | context) / pi_theta(token | context)

    # 불편향 KL 추정: r * (ratio - log(ratio) - 1)
    # 이 형태는 샘플이 pi_old로부터 왔을 때 E[gradient] = 0을 보장
    kl_estimate = importance_ratio * (ref_ratio - torch.log(ref_ratio) - 1)

    return kl_estimate
```

실제 응용에서는 서로 다른 영역이 다양한 강도의 KL 정규화로부터 이득을 얻는다는 것을 발견했습니다. 수학과 같은 특정 영역의 경우 상대적으로 약한 KL 패널티를 적용하거나 심지어 완전히 생략하는 것이 성능 향상을 가져올 수 있습니다. 이는 수학적 추론에서 창의적인 탐색이 중요하며, 과도한 정규화가 오히려 제약이 될 수 있음을 시사합니다.

#### 오프-폴리시 시퀀스 마스킹

강화학습 시스템의 효율성을 향상시키기 위해 일반적으로 대량의 롤아웃 데이터를 생성하고, 이를 여러 미니배치로 분할하여 여러 번의 그래디언트 업데이트 스텝에 사용합니다. 이러한 관행은 본질적으로 오프-폴리시 행동을 도입합니다. 추가로 효율적인 데이터 생성을 위해 사용되는 추론 프레임워크는 종종 고도로 최적화되어 있으며, 이는 구현 세부 사항에서 훈련 프레임워크와 다를 수 있습니다. 이러한 훈련-추론 불일치는 오프-폴리시 정도를 더욱 악화시킵니다.

훈련을 안정화하고 오프-폴리시 업데이트에 대한 내성을 향상시키기 위해, 데이터 샘플링 정책 $\pi_{\mathrm{old}}$와 현재 정책 $\pi_{\theta}$ 사이의 KL 발산으로 측정되는 상당한 정책 발산을 유발하는 음의 시퀀스를 마스킹합니다. 구체적으로, 이진 마스크 $M$을 GRPO 손실에 도입합니다.

$$\mathcal{J}_{\mathrm{GRPO}}(\theta)=\mathbb{E}_{q\sim P(Q),\{o_{i}\}_{i=1}^{G}\sim\pi_{\mathrm{old}}(\cdot|q)}\Bigg[\frac{1}{G}\sum_{i=1}^{G}\frac{1}{|o_{i}|}\sum_{t=1}^{|o_{i}|}\min\left(r_{i,t}(\theta)\hat{A}_{i,t},\text{clip}\left(r_{i,t}(\theta),1-\varepsilon,1+\varepsilon\right)\hat{A}_{i,t}\right)M_{i,t}-\beta\mathbb{D}_{\mathrm{KL}}\left(\pi_{\theta}(o_{i,t})\,\middle\|\,\pi_{\mathrm{ref}}(o_{i,t})\right)\Bigg],$$

여기서 마스크 $M_{i,t}$는 다음과 같이 정의됩니다.

$$M_{i,t}=\begin{cases}0&{\hat{A}_{i,t}<0,\frac{1}{|o_{i}|}\sum_{t=1}^{|o_{i}|}\log\frac{\pi_{\mathrm{old}}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}>\delta}\\[4.30554pt] 1&{\text{otherwise},}\end{cases}$$

$\delta$는 정책 발산의 임계값을 제어하는 하이퍼파라미터입니다. 여기서 $\pi_{\mathrm{old}}$는 추론 프레임워크가 직접 반환하는 샘플링 확률을 나타내므로, 이전 정책과 현재 정책 사이의 KL 발산은 위에서 언급한 두 가지 오프-폴리시 원인을 모두 고려합니다.

다음 구현 예시는 오프-폴리시 시퀀스 마스킹 로직을 보여줍니다.

```python
def compute_off_policy_mask(advantages, pi_old_logprobs, pi_theta_logprobs, delta=0.1):
    """
    오프-폴리시 시퀀스 마스킹 계산

    Args:
        advantages: 각 토큰의 어드밴티지 값 [batch_size, seq_len]
        pi_old_logprobs: 이전 정책의 로그 확률 [batch_size, seq_len]
        pi_theta_logprobs: 현재 정책의 로그 확률 [batch_size, seq_len]
        delta: 정책 발산 임계값

    Returns:
        이진 마스크 [batch_size, seq_len]
    """
    # 시퀀스 평균 KL 발산 계산
    # KL(old || theta) = log(old/theta) = log(old) - log(theta)
    per_token_kl = pi_old_logprobs - pi_theta_logprobs
    avg_kl_per_sequence = per_token_kl.mean(dim=1, keepdim=True)

    # 마스킹 조건: 음의 어드밴티지 AND 높은 KL 발산
    is_negative_advantage = advantages < 0
    is_high_divergence = avg_kl_per_sequence > delta

    # 두 조건 모두 만족하면 마스킹 (0), 그렇지 않으면 유지 (1)
    mask = ~(is_negative_advantage & is_high_divergence).float()

    return mask

# 사용 예시
advantages = compute_advantages(rewards)  # 그룹 내 정규화된 어드밴티지
mask = compute_off_policy_mask(advantages, old_logprobs, current_logprobs, delta=0.1)

# GRPO 손실에 마스크 적용
policy_loss = clipped_surrogate_objective * mask
total_loss = policy_loss - beta * kl_penalty
```

음의 어드밴티지를 가진 시퀀스만 마스킹한다는 점이 중요합니다. 직관적으로, 모델은 자신의 실수로부터 학습하는 것이 가장 유익하지만, 고도로 오프-폴리시인 음의 샘플은 해로울 수 있으며 최적화 프로세스를 오도하거나 불안정하게 만들 수 있습니다. 경험적으로 이 오프-폴리시 시퀀스 마스킹 작업은 그렇지 않으면 불안정성을 보일 수 있는 특정 훈련 시나리오에서 안정성을 향상시킵니다.

#### Keep Routing

Mixture-of-Experts (MoE) 모델은 추론 중에 전문가 모듈의 일부만 활성화하여 계산 효율성을 향상시킵니다. 그러나 추론 및 훈련 프레임워크 간의 불일치는 정책 업데이트와 결합되어 동일한 입력에 대해서도 추론과 훈련 중에 일관되지 않은 전문가 라우팅을 초래할 수 있습니다. 이러한 불일치는 활성 파라미터 부분공간의 급격한 변화를 유발하여 최적화를 불안정하게 만들고 오프-폴리시 문제를 악화시킵니다.

이를 완화하기 위해 추론 프레임워크에서 샘플링 중에 사용된 전문가 라우팅 경로를 보존하고 훈련 중에 동일한 라우팅 경로를 강제하여 동일한 전문가 파라미터가 최적화되도록 합니다.

```python
def keep_routing_forward(x, expert_weights, routing_decisions_from_sampling):
    """
    샘플링 시 결정된 라우팅을 유지하는 MoE forward pass

    Args:
        x: 입력 텐서 [batch_size, hidden_dim]
        expert_weights: 전문가 네트워크의 가중치
        routing_decisions_from_sampling: 샘플링 시 저장된 라우팅 결정
            - expert_indices: 선택된 전문가 인덱스 [batch_size, top_k]
            - expert_weights: 전문가 가중치 [batch_size, top_k]

    Returns:
        전문가 출력의 가중 합
    """
    batch_size = x.shape[0]
    expert_indices = routing_decisions_from_sampling['expert_indices']
    expert_combination_weights = routing_decisions_from_sampling['expert_weights']

    # 훈련 중에는 샘플링 시와 동일한 전문가 사용
    expert_outputs = []
    for i in range(batch_size):
        batch_expert_outputs = []
        for k, expert_idx in enumerate(expert_indices[i]):
            # 샘플링 시 선택된 전문가로 forward
            expert_output = expert_weights[expert_idx](x[i])
            # 샘플링 시의 가중치 적용
            weighted_output = expert_combination_weights[i, k] * expert_output
            batch_expert_outputs.append(weighted_output)

        # 선택된 전문가들의 출력 합산
        expert_outputs.append(sum(batch_expert_outputs))

    return torch.stack(expert_outputs)
```

이 Keep Routing 작업은 MoE 모델의 강화학습 훈련 안정성에 중요한 것으로 밝혀졌으며, DeepSeek-V3-0324 이후 강화학습 훈련 파이프라인에 채택되었습니다.

#### Keep Sampling Mask

Top-p 및 top-k 샘플링은 대규모 언어 모델이 생성하는 응답의 품질을 향상시키기 위해 널리 사용되는 샘플링 전략입니다. 강화학습 훈련에서 이러한 전략을 사용하는 것도 유리한데, 최적화 대상으로 사용될 극히 낮은 확률의 토큰 샘플링을 피할 수 있기 때문입니다.

이러한 절단이 샘플 품질을 보존하는 반면, $\pi_{\mathrm{old}}$와 $\pi_{\theta}$의 행동 공간 간에 불일치를 도입하여 중요도 샘플링의 원리를 위반하고 훈련을 불안정하게 만듭니다. 이를 해결하기 위해 $\pi_{\mathrm{old}}$로부터 샘플링 중에 절단 마스크를 보존하고 훈련 중에 $\pi_{\theta}$에 적용하여 두 정책이 동일한 행동 부분공간을 공유하도록 합니다.

```python
def apply_top_p_sampling_with_mask(logits, p=0.9, return_mask=False):
    """
    Top-p (nucleus) 샘플링과 마스크 저장

    Args:
        logits: 모델 출력 로짓 [batch_size, vocab_size]
        p: 누적 확률 임계값
        return_mask: 마스크 반환 여부

    Returns:
        sampled_tokens: 샘플링된 토큰
        sampling_mask: (선택적) 허용된 토큰의 마스크
    """
    # 소프트맥스로 확률 계산
    probs = F.softmax(logits, dim=-1)

    # 확률 내림차순 정렬
    sorted_probs, sorted_indices = torch.sort(probs, descending=True, dim=-1)

    # 누적 확률 계산
    cumsum_probs = torch.cumsum(sorted_probs, dim=-1)

    # Top-p 임계값을 초과하는 토큰 제거
    # 최소 하나의 토큰은 유지 (첫 번째 토큰)
    sorted_mask = cumsum_probs <= p
    sorted_mask[..., 0] = True  # 최소 하나는 유지

    # 원래 인덱스 순서로 마스크 복원
    sampling_mask = torch.zeros_like(probs, dtype=torch.bool)
    sampling_mask.scatter_(-1, sorted_indices, sorted_mask)

    # 마스크 적용된 로짓으로 샘플링
    masked_logits = logits.clone()
    masked_logits[~sampling_mask] = float('-inf')
    masked_probs = F.softmax(masked_logits, dim=-1)

    sampled_tokens = torch.multinomial(masked_probs, num_samples=1)

    if return_mask:
        return sampled_tokens, sampling_mask
    return sampled_tokens


def training_step_with_kept_mask(model, tokens, old_sampling_masks):
    """
    샘플링 시 저장된 마스크를 사용한 훈련 스텝

    Args:
        model: 훈련할 모델
        tokens: 입력 토큰 [batch_size, seq_len]
        old_sampling_masks: 샘플링 시 저장된 마스크 [batch_size, seq_len, vocab_size]
    """
    logits = model(tokens)

    # 샘플링 시와 동일한 마스크 적용
    masked_logits = logits.clone()
    masked_logits[~old_sampling_masks] = float('-inf')

    # 동일한 행동 공간에서 확률 계산
    log_probs = F.log_softmax(masked_logits, dim=-1)

    # 이후 GRPO 손실 계산...
    return log_probs
```

경험적으로, top-p 샘플링과 Keep Sampling Mask 전략을 결합하는 것이 강화학습 훈련 중에 언어 일관성을 효과적으로 보존하는 것으로 확인되었습니다. 이 기법은 샘플링 전략의 이점을 유지하면서도 중요도 샘플링의 수학적 타당성을 보장합니다.

### 도구 사용에서의 사고

#### 사고 컨텍스트 관리

DeepSeek-R1은 사고 과정을 통합하는 것이 복잡한 문제를 해결하는 모델의 능력을 크게 향상시킬 수 있음을 입증했습니다. 이러한 통찰을 기반으로, 도구 호출 시나리오에 사고 능력을 통합하고자 합니다. 그러나 두 번째 라운드의 메시지가 도착하면 추론 내용을 버리는 DeepSeek-R1의 전략을 복제하면 상당한 토큰 비효율성이 발생한다는 것을 관찰했습니다. 이 접근 방식은 모델이 각 후속 도구 호출에 대해 전체 문제를 중복적으로 재추론하도록 강제합니다.

이를 완화하기 위해 도구 호출 시나리오에 엄격하게 맞춤화된 컨텍스트 관리를 개발했습니다. 이 전략의 핵심 원칙은 다음과 같습니다. 과거 추론 내용은 대화에 새로운 사용자 메시지가 도입될 때만 삭제됩니다. 도구 관련 메시지(예: 도구 출력)만 추가되는 경우 추론 내용은 상호작용 전반에 걸쳐 유지됩니다. 추론 흔적이 제거될 때 도구 호출의 히스토리와 그 결과는 컨텍스트에 보존됩니다.

![도구 호출 시나리오에서의 사고 유지 메커니즘](https://arxiv.org/html/2512.02556/x5.jpeg)

위 그림은 도구 호출 시나리오에서 사고 유지 메커니즘의 아키텍처를 보여줍니다. 다이어그램은 사용자 입력, Thinking 구성 요소, 도구 호출, 도구 결과를 포함한 도구 호출 프로세스의 일련의 단계를 나타냅니다. 이 메커니즘은 연구의 핵심 기여 중 하나로, 효율적인 추론 지속성을 통해 반복적인 재계산을 방지합니다.

특정 에이전트 프레임워크, 예를 들어 Roo Code나 Terminus는 사용자 메시지를 통해 도구 상호작용을 시뮬레이션합니다. 이러한 프레임워크는 위에서 설명한 컨텍스트 관리 규칙으로 인해 향상된 추론 지속성의 모든 이점을 완전히 활용하지 못할 수 있습니다. 따라서 이러한 아키텍처에는 최적의 성능을 위해 비사고 모델을 사용할 것을 권장합니다.

#### 콜드 스타트

추론 데이터(비에이전트)와 비추론 에이전트 데이터가 모두 사용 가능한 상황에서, 이 두 가지 능력을 통합하기 위한 직접적인 전략은 신중하게 설계된 프롬프팅을 통하는 것입니다. 모델이 명시적 지침을 정확하게 따를 충분한 능력을 보유하고 있어, 추론 프로세스 내에 도구 실행을 원활하게 통합할 수 있다고 가정합니다.

콜드 스타트 메커니즘의 작동을 입증하기 위해 훈련 데이터를 선택적으로 샘플링합니다. 서로 다른 작업 프롬프트가 서로 다른 시스템 프롬프트와 연관되어 있다는 점이 중요합니다. 추론 데이터의 예시는 시스템 프롬프트를 사용하여 모델에게 최종 답변 전에 추론을 수행하도록 명시적으로 요청하고 특수 태그 `<think></think>`를 사용하여 추론 경로를 표시합니다. 비추론 에이전트 데이터의 프롬프트는 시스템 프롬프트에 도구 호출 가이드가 포함되어 있습니다.

추론 중 도구 사용 패턴을 위해 설계된 시스템 프롬프트는 모델에게 추론 프로세스 내에 여러 도구 호출을 통합하도록 지시합니다. 이러한 방식으로 도구 사용 패턴에서의 추론이 견고하지 않을 수 있지만, 모델은 때때로 원하는 궤적을 생성할 수 있으며, 이는 후속 강화학습 단계의 기반을 제공합니다.

#### 대규모 에이전트 작업

다양한 강화학습 작업 세트는 모델 견고성을 향상시키는 데 중요합니다. 검색, 코드 엔지니어링, 코드 해석과 같은 작업의 경우 실제 웹 검색 API, 코딩 도구, Jupyter Notebook을 포함한 실제 도구를 사용합니다. 이러한 강화학습 환경은 실제이지만, 사용된 프롬프트는 실제 사용자 상호작용에서 얻은 것이 아니라 인터넷 소스에서 추출하거나 합성적으로 생성됩니다. 다른 작업의 경우 환경과 프롬프트가 모두 합성적으로 구성됩니다.

다음 표는 사용된 에이전트 작업의 설명을 보여줍니다.

| 작업 수                 | 환경 | 프롬프트 |
| ----------------------- | ---- | -------- |
| code agent: 24,667      | 실제 | 추출     |
| search agent: 50,275    | 실제 | 합성     |
| general agent: 4,417    | 합성 | 합성     |
| code interpreter: 5,908 | 실제 | 추출     |

이 표는 서로 다른 에이전트 작업의 설명으로, 작업 수, 환경 유형(실제 또는 합성), 프롬프트 소스(추출 또는 합성)를 포함합니다.

**검색 에이전트**: DeepSeek-V3.2를 기반으로 한 다중 에이전트 파이프라인을 사용하여 다양하고 고품질의 훈련 데이터를 생성합니다. 먼저 대규모 웹 코퍼스에서 다양한 영역에 걸쳐 정보가 풍부한 롱테일 엔티티를 샘플링합니다. 질문 구성 에이전트는 구성 가능한 깊이 및 너비 파라미터를 사용하여 검색 도구로 각 엔티티를 탐색하고, 발견된 정보를 질문-답변 쌍으로 통합합니다. 이질적인 구성(서로 다른 체크포인트, 시스템 프롬프트 등)을 가진 여러 답변 생성 에이전트가 제안된 각 QA 쌍에 대해 다양한 후보 응답을 생성합니다. 검색 기능을 갖춘 검증 에이전트는 여러 패스를 통해 모든 답변을 검증하며, 정답이 올바르고 모든 후보가 검증 가능하게 잘못된 인스턴스만 보존합니다. 이러한 데이터는 여러 언어, 영역 및 난이도 수준에 걸쳐 있습니다.

이러한 검증 가능한 샘플을 보완하고 실제 사용을 더 잘 반영하기 위해, 검색 도구가 측정 가능한 이점을 제공하는 기존 유용성 강화학습 데이터셋에서 필터링된 인스턴스로 데이터셋을 보강합니다. 그런 다음 여러 품질 차원에 걸쳐 상세한 평가 루브릭을 개발하고 생성형 보상 모델을 사용하여 이러한 루브릭을 기반으로 응답을 점수화합니다. 이 하이브리드 접근 방식은 사실적 신뢰성과 실용적 유용성 모두에 대한 최적화를 가능하게 합니다.

**코드 에이전트**: GitHub에서 수백만 개의 이슈-PR 쌍을 마이닝하여 소프트웨어 이슈 해결을 위한 대규모 실행 가능한 환경을 구축했습니다. 이 데이터셋은 휴리스틱 규칙과 대규모 언어 모델 기반 판단을 사용하여 엄격하게 필터링되어 높은 품질을 보장하며, 각 항목이 합리적인 이슈 설명, 상관 관계가 있는 골드 패치, 검증을 위한 테스트 패치를 포함하도록 요구합니다. DeepSeek-V3.2로 구동되는 자동화된 환경 설정 에이전트가 이러한 쌍에 대한 실행 가능한 환경을 구축하는 데 사용되었습니다. 이 에이전트는 패키지 설치, 종속성 해결, 테스트 실행을 처리합니다.

테스트 결과는 표준 JUnit 형식으로 출력되어 프로그래밍 언어 및 테스트 프레임워크 전반에 걸쳐 일관된 구문 분석을 보장합니다. 환경은 골드 패치를 적용할 때 0이 아닌 수의 false-to-positive (F2P) 테스트 케이스(이슈가 수정되었음을 나타냄)와 0개의 pass-to-fail (P2F) 테스트 케이스(회귀가 없음을 나타냄)를 초래하는 경우에만 성공적으로 구축된 것으로 간주됩니다. 이 파이프라인을 사용하여 Python, Java, JavaScript, TypeScript, C, C++, Go, PHP를 포함한 여러 프로그래밍 언어에 걸쳐 수만 개의 재현 가능한 이슈 해결 환경을 성공적으로 구축했습니다.

**코드 인터프리터 에이전트**: Jupyter Notebook을 코드 인터프리터로 활용하여 복잡한 추론 작업을 해결합니다. 이를 위해 수학, 논리, 데이터 과학에 걸친 다양한 문제 세트를 큐레이션하며, 각 문제는 모델이 코드 실행 기능을 활용하여 솔루션에 도달하도록 요구합니다.

**일반 에이전트**: 강화학습에서 에이전트 환경과 작업을 확장하기 위해 1,827개의 작업 지향 환경을 합성하는 자동 환경 합성 에이전트를 사용합니다. 이러한 작업은 해결하기는 어렵지만 검증하기는 쉽습니다. 합성 워크플로우는 주로 환경 및 도구 세트 구축, 작업 합성, 솔루션 생성으로 구성됩니다.

워크플로우는 다음과 같이 진행됩니다. 먼저 작업 카테고리(예: 여행 일정 계획)와 bash 및 검색 도구가 장착된 샌드박스가 주어지면, 에이전트는 이러한 도구를 사용하여 인터넷에서 관련 데이터를 생성하거나 검색하고 샌드박스 데이터베이스에 저장합니다. 그런 다음 에이전트는 각각 함수로 구현된 작업별 도구 세트를 합성합니다. 도전적이면서도 자동으로 검증 가능한 작업을 생성하기 위해, 에이전트는 먼저 현재 데이터베이스를 기반으로 간단한 작업을 제안하고, Python으로 구현된 솔루션 및 검증 함수와 함께 제공합니다. 솔루션 함수는 도구 함수를 호출하거나 논리적 계산을 수행하는 것으로 제한되며 다른 함수를 호출하거나 데이터베이스에 직접 액세스할 수 없어, 작업이 도구 인터페이스를 통해서만 해결될 수 있도록 합니다.

추가로 솔루션 함수가 생성한 결과는 검증 함수에 의해 검증되어야 합니다. 솔루션이 검증되지 않으면 에이전트는 솔루션의 출력이 검증을 통과할 때까지 솔루션 또는 검증 함수를 수정합니다. 그런 다음 에이전트는 반복적으로 작업의 난이도를 증가시키고 해당 솔루션 및 검증 함수를 업데이트합니다. 이 반복 프로세스 중에 현재 도구 세트가 작업을 해결하기에 충분하지 않으면 에이전트는 도구 세트를 증강합니다. 이 워크플로우를 따라 수천 개의 $\langle\text{environment},\text{tools},\text{task},\text{verifier}\rangle$ 튜플을 얻습니다. 그런 다음 DeepSeek-V3.2를 사용하여 이 데이터셋에 대해 강화학습을 수행하고 0이 아닌 pass@100을 가진 인스턴스만 보존하여 1,827개의 환경과 해당 작업(총 4,417개)을 얻습니다.

합성된 작업의 예시로 여행 계획을 들 수 있습니다. 이 예시는 모든 제약을 만족하는 여행 계획을 찾기 위해 대규모 조합 공간을 검색하는 것은 어렵지만, 주어진 후보 솔루션이 이러한 제약을 만족하는지 확인하는 것은 상대적으로 간단하다는 점을 강조합니다.

**합성 작업 예시: 여행 계획**

저는 항저우에서 출발하는 3일간의 여행을 계획하고 있으며, 2025년 10월 1일부터 10월 3일까지의 일정을 만드는 데 도움이 필요합니다. 몇 가지 중요한 요구 사항이 있습니다. 전체 여행 동안 도시, 호텔, 명소 또는 레스토랑을 반복하고 싶지 않습니다. 또한 추천하는 모든 호텔, 레스토랑, 명소가 실제로 그날 머물 도시에 위치해 있는지 확인해 주세요.

둘째 날에 대한 한 가지 더 말씀드리자면, 예산을 현명하게 관리하려고 합니다. 1박당 800 CNY 이상의 고급 호텔을 예약하게 되면 다른 비용에 더 신중해야 합니다. 레스토랑(점심 및 저녁)의 총 지출은 350 CNY 미만이어야 하고, 두 레스토랑 모두 최소 4.0성급 평가를 받아야 하며, 오후 명소 티켓은 120 CNY 미만이어야 합니다. 둘째 날 호텔이 중상급 범위(500-800 CNY)인 경우 약간 더 유연합니다. 레스토랑 선택 중 최소 하나가 4.0 이상의 평가를 받아야 하고 명소 티켓은 180 CNY 미만이어야 합니다. 더 저렴한 호텔(200-500 CNY 범위)의 경우 최소 하나의 레스토랑이 3.2 이상의 평가를 받도록 하면 됩니다.

이 일정을 작성하는 데 도움을 주시겠습니까?

**제출 결과 형식**:

```json
[
  {
    "time": "2025-10-01",
    "city": "도시명",
    "hotel": "호텔명",
    "afternoon_restaurant": "레스토랑명",
    "afternoon_attraction": "명소명",
    "evening_restaurant": "레스토랑명"
  },
  {
    "time": "2025-10-02",
    "city": "도시명",
    "hotel": "호텔명",
    "afternoon_restaurant": "레스토랑명",
    "afternoon_attraction": "명소명",
    "evening_restaurant": "레스토랑명"
  },
  {
    "time": "2025-10-03",
    "city": "도시명",
    "hotel": "호텔명",
    "afternoon_restaurant": "레스토랑명",
    "afternoon_attraction": "명소명",
    "evening_restaurant": "레스토랑명"
  }
]
```

**여행 계획용 도구 세트**:

| 함수 이름                                          | 설명                                       |
| -------------------------------------------------- | ------------------------------------------ |
| get_all_attractions_by_city(city)                  | 주어진 도시의 모든 명소 가져오기           |
| get_all_cities()                                   | 데이터베이스에서 모든 도시 가져오기        |
| get_all_hotels_by_city(city)                       | 주어진 도시의 모든 호텔 가져오기           |
| get_all_restaurants_by_city(city)                  | 주어진 도시의 모든 레스토랑 가져오기       |
| get_city_by_attraction(attraction)                 | 주어진 명소의 도시 가져오기                |
| get_city_by_hotel(hotel)                           | 주어진 호텔의 도시 가져오기                |
| get_city_by_restaurant(restaurant)                 | 주어진 레스토랑의 도시 가져오기            |
| get_city_transport(city)                           | 주어진 도시의 모든 시내 교통 옵션 가져오기 |
| get_infos_by_attraction(info_keywords, attraction) | 주어진 명소의 지정된 정보 가져오기         |
| get_infos_by_city(info_keywords, city)             | 주어진 도시의 지정된 정보 가져오기         |
| get_infos_by_hotel(info_keywords, hotel)           | 주어진 호텔의 지정된 정보 가져오기         |
| get_infos_by_restaurant(info_keywords, restaurant) | 주어진 레스토랑의 지정된 정보 가져오기     |
| get_inter_city_transport(from_city, to_city)       | 주어진 도시 쌍 간의 모든 교통수단 가져오기 |
| get_weather_by_city_date(city, date)               | 주어진 도시-날짜 쌍의 날씨 가져오기        |
| submit_result(answer_text)                         | 최종 답변 내용 제출                        |

이 합성된 여행 계획 작업은 복잡한 제약 만족 문제를 해결하면서도 솔루션 검증이 명확하게 정의되어 있어, 강화학습을 통한 에이전트 능력 향상에 이상적인 예시입니다.
## 평가

DeepSeek-V3.2의 성능을 종합적으로 검증하기 위해 추론, 코딩, 수학, 코드 에이전트, 검색 에이전트, 도구 사용 등 다양한 영역의 벤치마크에서 평가가 수행되었습니다. 평가는 온도 1.0, 컨텍스트 윈도우 128K 토큰 설정에서 진행되었으며, 도구 사용 벤치마크는 표준 함수 호출 형식을 사용하여 사고 모드로 구성되었습니다. 수학 관련 작업에는 "{question} Please reason step by step, and put your final answer within \boxed{}." 템플릿이 적용되었습니다.

### 벤치마크 성능 비교

다음 표는 DeepSeek-V3.2와 주요 경쟁 모델들의 성능을 다양한 벤치마크에서 비교한 결과입니다.

| 벤치마크 (지표)             | Claude-4.5-Sonnet | GPT-5-High | Gemini-3.0-Pro | Kimi-K2-Thinking | MiniMax-M2 | DeepSeek-V3.2-Thinking |
| --------------------------- | ----------------- | ---------- | -------------- | ---------------- | ---------- | ---------------------- |
| **영어 이해**               |
| MMLU-Pro (EM)               | 88.2              | 87.5       | 90.1           | 84.6             | 82.0       | 85.0                   |
| GPQA Diamond (Pass@1)       | 83.4              | 85.7       | 91.9           | 84.5             | 77.7       | 82.4                   |
| HLE (Pass@1)                | 13.7              | 26.3       | 37.7           | 23.9             | 12.5       | 25.1                   |
| **코딩**                    |
| LiveCodeBench (Pass@1-COT)  | 64.0              | 84.5       | 90.7           | 82.6             | 83.0       | 83.3                   |
| Codeforces (Rating)         | 1480              | 2537       | 2708           | -                | -          | 2386                   |
| **수학**                    |
| AIME 2025 (Pass@1)          | 87.0              | 94.6       | 95.0           | 94.5             | 78.3       | 93.1                   |
| HMMT Feb 2025 (Pass@1)      | 79.2              | 88.3       | 97.5           | 89.4             | -          | 92.5                   |
| HMMT Nov 2025 (Pass@1)      | 81.7              | 89.2       | 93.3           | 89.2             | -          | 90.2                   |
| IMOAnswerBench (Pass@1)     | -                 | 76.0       | 83.3           | 78.6             | -          | 78.3                   |
| **코드 에이전트**           |
| Terminal Bench 2.0 (Acc)    | 42.8              | 35.2       | 54.2           | 35.7             | 30.0       | 46.4                   |
| SWE Verified (Resolved)     | 77.2              | 74.9       | 76.2           | 71.3             | 69.4       | 73.1                   |
| SWE Multilingual (Resolved) | 68.0              | 55.3       | -              | 61.1             | 56.5       | 70.2                   |
| **검색 에이전트**           |
| BrowseComp (Pass@1)         | 24.1              | 54.9       | -/60.2*        | 44.0             | -          | 51.4/67.6*             |
| BrowseCompZh (Pass@1)       | 42.4              | 63.0       | -              | 62.3             | 48.5       | 65.0                   |
| HLE (Pass@1)                | 32.0              | 35.2       | 45.8           | 44.9             | 31.8       | 40.8                   |
| **도구 사용**               |
| τ²-Bench (Pass@1)           | 84.7              | 80.2       | 85.4           | 74.3             | 76.9       | 80.3                   |
| MCP-Universe (Success Rate) | 46.5              | 47.9       | 50.7           | 35.6             | 29.4       | 45.9                   |
| MCP-Mark (Pass@1)           | 33.3              | 50.9       | 43.1           | 20.4             | 24.4       | 38.0                   |
| Tool-Decathlon (Pass@1)     | 38.6              | 29.0       | 36.4           | 17.6             | 16.0       | 35.2                   |

표에서 별표(*)는 컨텍스트 관리 기법을 적용한 성능을 나타냅니다. τ²-Bench 결과는 각 카테고리의 평균으로 계산되었으며, 구체적으로 Airline 63.8, Retail 81.1, Telecom 96.2의 점수를 기록했습니다.

DeepSeek-V3.2는 추론 작업에서 GPT-5-High와 유사한 성능을 달성했지만 Gemini-3.0-Pro보다는 약간 낮은 결과를 보였습니다. K2-Thinking과 비교했을 때 DeepSeek-V3.2는 상당히 적은 출력 토큰으로 비슷한 점수를 달성했습니다. 이러한 성능 향상은 강화학습 훈련에 할당된 계산 자원의 증가에 기인하며, 최근 몇 달 동안 강화학습 훈련 예산 확장과 함께 지속적인 성능 개선이 관찰되었습니다. 현재 강화학습 훈련 예산은 이미 사전 훈련 비용의 10%를 크게 초과했으며, 추가 계산 예산 할당을 통해 추론 능력이 더욱 향상될 수 있을 것으로 예상됩니다.

코드 에이전트 평가에서 DeepSeek-V3.2는 SWE-bench Verified와 Terminal Bench 2.0 모두에서 오픈소스 대규모 언어 모델을 크게 능가하여 실제 코딩 워크플로우에서의 잠재력을 입증했습니다. Terminal Bench 2.0의 경우, 사고 모드를 위한 컨텍스트 관리 전략이 현재 Terminus와 호환되지 않아 Claude Code 프레임워크를 사용하여 46.4점을 달성했습니다. 비사고 모드에서 Terminus로 평가했을 때는 39.3점을 기록했습니다. SWE-bench Verified의 주요 점수는 내부 프레임워크를 사용하여 얻었으며, Claude Code 및 RooCode 프레임워크를 포함한 다른 설정과 비사고 모드에서의 견고성 테스트는 72에서 74 사이의 일관된 결과를 보였습니다.

검색 에이전트 평가에서는 표준 상용 검색 API를 사용했습니다. DeepSeek-V3.2가 최대 128K의 컨텍스트 길이만 지원하기 때문에 테스트 케이스의 약 20% 이상이 이 제한을 초과했습니다. 이를 해결하기 위해 컨텍스트 관리 방법을 사용하여 최종 점수를 도출했으며, 컨텍스트 관리 없이는 51.4점을 기록했습니다.

도구 사용 벤치마크에서 DeepSeek-V3.2는 오픈소스와 비공개 대규모 언어 모델 간의 성능 격차를 상당히 줄였지만 최전선 모델보다는 낮은 성능을 보였습니다. MCP 벤치마크의 경우 함수 호출 형식을 사용하고 도구 출력을 'user' 역할이 아닌 'tool' 역할로 지정된 메시지 내에 배치했습니다. 테스트 중 DeepSeek-V3.2가 중복적인 자체 검증을 자주 수행하여 지나치게 긴 궤적을 생성하는 경향이 관찰되었습니다. 이러한 경향은 특히 MCP-Mark GitHub 및 Playwright 평가와 같은 작업에서 컨텍스트 길이가 128K 제한을 초과하게 만들어 최종 성능을 저해했습니다. 그러나 컨텍스트 관리 전략을 통합하면 성능을 더욱 향상시킬 수 있습니다. 이러한 문제에도 불구하고 DeepSeek-V3.2는 여전히 기존 오픈 모델을 크게 능가했습니다.

주목할 점은 이러한 벤치마크에서 사용된 환경과 도구 세트가 강화학습 훈련 중에 접하지 않았던 것들이라는 점입니다. 관찰된 개선 사항은 DeepSeek-V3.2가 추론 전략을 도메인 외 에이전트 시나리오로 일반화할 수 있는 능력을 보여줍니다.

### 확장된 추론 능력의 DeepSeek-V3.2-Speciale

다음 표는 추론 모델들의 벤치마크 성능과 효율성을 비교한 것입니다. 각 벤치마크에 대해 정확도와 출력 토큰 수(천 단위)가 표시되어 있으며, 가장 높은 정확도는 굵은 글씨로, 두 번째로 높은 정확도는 밑줄로 표시되어 있습니다.

| 벤치마크                   | GPT-5-High | Gemini-3.0-Pro | Kimi-K2-Thinking | DeepSeek-V3.2-Thinking | DeepSeek-V3.2-Speciale |
| -------------------------- | ---------- | -------------- | ---------------- | ---------------------- | ---------------------- |
| AIME 2025 (Pass@1)         | 94.6 (13k) | **95.0** (15k) | 94.5 (24k)       | 93.1 (16k)             | **96.0** (23k)         |
| HMMT Feb 2025 (Pass@1)     | 88.3 (16k) | 97.5 (16k)     | 89.4 (31k)       | 92.5 (19k)             | **99.2** (27k)         |
| HMMT Nov 2025 (Pass@1)     | 89.2 (20k) | **93.3** (15k) | 89.2 (29k)       | 90.2 (18k)             | **94.4** (25k)         |
| IMOAnswerBench (Pass@1)    | 76.0 (31k) | **83.3** (18k) | 78.6 (37k)       | 78.3 (27k)             | **84.5** (45k)         |
| LiveCodeBench (Pass@1-COT) | 84.5 (13k) | **90.7** (13k) | 82.6 (29k)       | 83.3 (16k)             | 88.7 (27k)             |
| CodeForces (Rating)        | 2537 (29k) | **2708** (22k) | -                | 2386 (42k)             | **2701** (77k)         |
| GPQA Diamond (Pass@1)      | 85.7 (8k)  | **91.9** (8k)  | 84.5 (12k)       | 82.4 (7k)              | 85.7 (16k)             |
| HLE (Pass@1)               | 26.3 (15k) | **37.7** (15k) | 23.9 (24k)       | 25.1 (21k)             | 30.6 (35k)             |

DeepSeek-V3.2-Speciale는 증가된 추론 토큰을 활용하여 여러 벤치마크에서 최첨단 Gemini-3.0-Pro를 능가하는 우수한 성능을 달성했습니다. 특히 HMMT Feb 2025에서 99.2%의 정확도를 기록하며 모든 모델 중 최고 성능을 보였고, AIME 2025에서도 96.0%로 1위를 차지했습니다. 이 범용 모델은 목표 지향 훈련 없이도 2025년 국제 정보 올림피아드(IOI)와 ICPC World Finals(ICPC WF)에서 금메달 수준의 성능을 달성했습니다.

다음 표는 DeepSeek-V3.2-Speciale의 최상위 수학 및 코딩 대회 성과를 보여줍니다.

| 대회     | P1  | P2  | P3  | P4  | P5  | P6  | 총점    | 메달 |
| -------- | --- | --- | --- | --- | --- | --- | ------- | ---- |
| IMO 2025 | 7   | 7   | 7   | 7   | 7   | 0   | 35/42   | 금   |
| CMO 2025 | 18  | 18  | 9   | 21  | 18  | 18  | 102/126 | 금   |
| IOI 2025 | 100 | 82  | 72  | 100 | 55  | 83  | 492/600 | 금   |

| 대회         | A   | B   | C   | D   | E   | F   | G   | H   | I   | J   | K   | L   | 총점  | 메달 |
| ------------ | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ----- | ---- |
| ICPC WF 2025 | 3   | -   | 1   | 1   | 2   | 2   | -   | 1   | 1   | 1   | 1   | 1   | 10/12 | 금   |

ICPC WF 2025의 경우 각 성공적으로 해결된 문제에 대한 제출 횟수가 표시되어 있으며, DeepSeek-V3.2-Speciale는 2위를 차지했습니다. IOI 2025에서는 10위를 기록했습니다. 또한 [DeepSeekMath-V2](https://github.com/deepseek-ai/DeepSeek-Math-V2)의 기법을 통합하여 복잡한 증명 작업에서 탁월한 성능을 보였으며, IMO 2025와 CMO 2025에서 금메달 기준점에 도달했습니다.

그러나 DeepSeek-V3.2-Speciale의 토큰 효율성은 Gemini-3.0-Pro에 비해 상당히 낮습니다. 배포 비용과 지연 시간을 완화하기 위해 공식 DeepSeek-V3.2 훈련 중에는 성능과 비용 간의 균형을 최적화하기 위해 더 엄격한 토큰 제약을 부과했습니다. 토큰 효율성은 향후 연구의 중요한 영역으로 남아 있습니다.

### 합성 에이전트 작업의 효과성

합성 에이전트 작업의 효과를 연구하기 위해 절제 실험이 수행되었습니다. 첫 번째 질문은 합성 작업이 강화학습에 충분히 도전적인가 하는 것이고, 두 번째 질문은 이러한 합성 작업이 얼마나 잘 일반화되는가, 즉 다른 하위 작업이나 실제 환경으로 전이될 수 있는가 하는 것입니다.

첫 번째 질문을 다루기 위해 일반 합성 에이전트 작업에서 50개의 인스턴스를 무작위로 샘플링하고 합성에 사용된 모델과 최전선 비공개 대규모 언어 모델을 모두 평가했습니다.

| Pass@K | DeepSeek-v3.2-Exp | Sonnet-4.5 | Gemini-3.0 Pro | GPT-5-Thinking |
| ------ | ----------------- | ---------- | -------------- | -------------- |
| 1      | 12%               | 34%        | 51%            | 62%            |
| 2      | 18%               | 47%        | 65%            | 75%            |
| 4      | 26%               | 62%        | 74%            | 82%            |

DeepSeek-V3.2-Exp는 12%의 정확도만 달성했으며, 최전선 비공개 모델도 최대 62%를 달성했습니다. 이러한 결과는 합성 데이터에 DeepSeek-V3.2-Exp와 최전선 비공개 모델 모두에게 도전적인 에이전트 작업이 포함되어 있음을 나타냅니다.

강화학습이 합성 데이터에서 다른 작업이나 실제 환경으로 일반화될 수 있는지 조사하기 위해, DeepSeek-V3.2의 지도 학습 체크포인트(DeepSeek-V3.2-SFT로 표시)에 강화학습을 적용했습니다. 긴 체인 오브 소트와 다른 강화학습 데이터의 영향을 배제하기 위해 비사고 모드에서 합성 에이전트 작업에만 강화학습을 수행했습니다. 그런 다음 모델을 DeepSeek-V3.2-SFT 및 DeepSeek-V3.2-Exp와 비교했으며, DeepSeek-V3.2-Exp는 검색 및 코드 환경에서만 강화학습으로 훈련되었습니다.

![합성 일반 에이전트 데이터만을 사용한 DeepSeek-V3.2-SFT의 강화학습 훈련](https://arxiv.org/html/2512.02556/figures/synthesis-rl-plot.png)

위 그림은 여러 라인 플롯을 보여주며, Tau2Bench의 Airline, Retail, Telecom 카테고리와 MCP-Mark의 Filesystem, PostgreSQL, Financial-Analysis, Location-Navigation, 3D-Designing 작업에서 DeepSeek-V3.2 모델의 성능을 나타냅니다. 합성 데이터에 대한 대규모 강화학습은 Tau2Bench, MCP-Mark, MCP-Universe 벤치마크에서 DeepSeek-V3.2-SFT에 비해 상당한 개선을 가져왔습니다. 반면 코드 및 검색 시나리오로 강화학습을 제한하면 이러한 벤치마크에서 성능이 향상되지 않아 합성 데이터의 잠재력을 더욱 강조합니다.

### 검색 에이전트의 컨텍스트 관리

128K와 같은 확장된 컨텍스트 윈도우에서도 에이전트 워크플로우, 특히 검색 기반 시나리오에서는 추론 프로세스를 조기에 중단시키는 최대 길이 제한에 자주 직면합니다. 이러한 병목 현상은 테스트 시간 계산 잠재력의 완전한 실현을 방해합니다. 이를 해결하기 위해 토큰 사용량이 컨텍스트 윈도우 길이의 80%를 초과할 때 테스트 시간에 토큰 예산을 확장하는 간단한 전략을 사용하는 컨텍스트 관리가 도입되었습니다.

이러한 전략에는 (1) Summary: 오버플로우된 궤적을 요약하고 롤아웃을 재시작, (2) Discard-75%: 궤적의 처음 75% 도구 호출 히스토리를 삭제하여 공간 확보, (3) Discard-all: 이전 도구 호출 히스토리를 모두 삭제하여 컨텍스트 재설정(Opus 4.5의 새 컨텍스트 도구와 유사)이 포함됩니다. 비교를 위해 N개의 독립적인 궤적을 샘플링하고 가장 적은 단계를 가진 궤적을 선택하는 병렬 확장 기준선인 Parallel-fewest-step도 구현했습니다.

![다양한 테스트 시간 계산 확장 전략에 따른 Browsecomp의 정확도](https://arxiv.org/html/2512.02556/x6.png)

위 그림은 BrowseComp 벤치마크에서 다양한 테스트 시간 계산 확장 전략의 정확도를 보여줍니다. 다양한 계산 예산 하에서 컨텍스트 관리는 모델이 테스트 시간 계산을 확장하여 추가 실행 단계를 수행할 수 있는 공간을 제공함으로써 상당한 성능 향상을 가져왔습니다. 예를 들어 Summary는 평균 단계를 364로 확장하여 최대 60.2의 성능 향상을 달성했지만 전체 효율성은 상대적으로 낮았습니다. 단순함에도 불구하고 Discard-all은 효율성과 확장성 모두에서 우수한 성능을 보였으며, 67.6점을 달성하여 병렬 확장과 비슷하면서도 훨씬 적은 단계를 사용했습니다.

테스트 시간 계산은 컨텍스트 관리를 통한 직렬 방식이나 병렬 방식으로 확장될 수 있으며, 두 방식 모두 모델의 문제 해결 능력을 효과적으로 확장합니다. 그러나 서로 다른 전략은 다양한 효율성과 확장성을 보입니다. 따라서 모델 성능을 벤치마킹할 때 실제 계산 비용을 고려하는 것이 중요합니다. 한편 효율성과 확장성을 모두 최대화하기 위한 직렬 및 병렬 확장의 최적 조합을 찾는 것은 향후 연구의 중요한 방향으로 남아 있습니다.
DeepSeek-V3.2는 계산 효율성과 고급 추론 능력을 효과적으로 연결하는 프레임워크를 소개했습니다. DSA를 사용하여 긴 문맥 성능을 희생하지 않으면서 중요한 계산 복잡도 문제를 해결했으며, 계산 예산을 증가시킴으로써 추론 벤치마크에서 GPT-5와 비교 가능한 성능을 달성했습니다. 또한 대규모 에이전트 작업 합성 파이프라인의 통합은 도구 사용 숙련도를 크게 향상시켜 오픈 대규모 언어 모델로 강력하고 일반화 가능한 AI 에이전트를 구현할 수 있는 새로운 가능성을 열었습니다. 더 나아가 높은 계산량을 투입한 변형 모델인 DeepSeek-V3.2-Speciale는 IMO와 IOI에서 금메달 수준의 성과를 달성하여 오픈 대규모 언어 모델의 새로운 이정표를 세웠습니다.

이러한 성과에도 불구하고 Gemini-3.0-Pro와 같은 최전선 비공개 모델과 비교했을 때 몇 가지 한계점이 인정됩니다. 첫째, 총 훈련 FLOPs가 적기 때문에 DeepSeek-V3.2의 세계 지식의 폭은 여전히 선도적인 상용 모델에 비해 뒤처져 있습니다. 이는 모델이 다양한 주제와 영역에 걸쳐 보유한 사실적 정보의 양과 깊이가 제한적임을 의미합니다. 연구팀은 향후 반복 개발에서 사전 훈련 계산을 확장하여 이러한 지식 격차를 해소할 계획입니다. 사전 훈련 단계에서 더 많은 계산 자원을 투입하면 모델이 더 광범위한 데이터로부터 학습할 수 있어 지식 기반이 확장될 것으로 기대됩니다.

둘째, 토큰 효율성이 여전히 과제로 남아 있습니다. DeepSeek-V3.2는 일반적으로 Gemini-3.0-Pro와 같은 모델의 출력 품질과 일치하기 위해 더 긴 생성 궤적, 즉 더 많은 토큰을 필요로 합니다. 이는 동일한 수준의 답변 품질을 달성하기 위해 더 많은 추론 단계와 더 긴 설명이 필요하다는 것을 의미하며, 이는 추론 비용과 지연 시간 측면에서 비효율적입니다. 앞서 제시된 벤치마크 성능 비교 표에서 볼 수 있듯이, DeepSeek-V3.2-Speciale는 우수한 정확도를 달성하지만 평균적으로 Gemini-3.0-Pro보다 훨씬 많은 토큰을 사용합니다. 예를 들어 AIME 2025에서 DeepSeek-V3.2-Speciale는 23,000개의 토큰을 사용하여 96.0%의 정확도를 달성한 반면, Gemini-3.0-Pro는 15,000개의 토큰으로 95.0%를 달성했습니다. 향후 연구는 모델의 추론 체인의 지능 밀도를 최적화하여 효율성을 개선하는 데 초점을 맞출 것입니다. 이는 각 토큰이 더 많은 정보와 추론 가치를 담도록 하여 동일한 품질을 더 적은 토큰으로 달성하는 것을 목표로 합니다.

셋째, 복잡한 작업을 해결하는 능력은 여전히 최전선 모델에 비해 열등합니다. 이는 특히 다단계 추론이 필요하거나 여러 지식 영역을 통합해야 하는 고난도 문제에서 두드러집니다. 이러한 한계는 연구팀이 파운데이션 모델과 사후 훈련 레시피를 더욱 개선하도록 동기를 부여합니다. 파운데이션 모델의 개선은 더 나은 아키텍처 설계, 더 효과적인 사전 훈련 전략, 그리고 더 강력한 표현 학습을 포함할 수 있습니다. 사후 훈련 레시피의 개선은 더 정교한 강화학습 알고리즘, 더 다양하고 도전적인 훈련 데이터, 그리고 더 효과적인 보상 설계를 통해 이루어질 수 있습니다.

이러한 한계점들은 DeepSeek-V3.2가 이미 상당한 성과를 달성했음에도 불구하고 여전히 개선의 여지가 있음을 보여줍니다. 특히 지식의 폭, 토큰 효율성, 복잡한 작업 해결 능력이라는 세 가지 핵심 영역에서의 개선은 오픈소스 대규모 언어 모델이 비공개 최전선 모델과의 격차를 더욱 좁히는 데 필수적입니다. 연구팀은 이러한 한계를 명확히 인식하고 향후 연구 방향을 구체적으로 제시함으로써, 오픈소스 커뮤니티가 이러한 과제를 해결하기 위한 협력적 노력을 기울일 수 있는 기반을 마련했습니다.

DeepSeek-V3.2의 개발 과정은 오픈소스 대규모 언어 모델이 적절한 아키텍처 혁신, 충분한 계산 투자, 그리고 효과적인 데이터 합성 전략을 통해 상용 모델에 근접하거나 특정 영역에서는 능가할 수 있음을 입증했습니다. DSA를 통한 계산 효율성 개선, 대규모 강화학습을 통한 추론 능력 향상, 그리고 체계적인 에이전트 작업 합성을 통한 도구 사용 능력 강화는 모두 오픈소스 모델 개발의 중요한 이정표입니다. 특히 DeepSeek-V3.2-Speciale가 국제 올림피아드 수준의 문제에서 금메달 성과를 달성한 것은 오픈소스 모델이 최고 수준의 추론 능력을 갖출 수 있음을 보여주는 강력한 증거입니다.

향후 연구는 이러한 성과를 기반으로 세 가지 주요 방향으로 진행될 것입니다. 첫째, 사전 훈련 계산을 확장하여 모델의 지식 기반을 넓히고 다양한 영역에서의 성능을 향상시킬 것입니다. 둘째, 추론 체인의 지능 밀도를 최적화하여 더 적은 토큰으로 더 높은 품질의 출력을 생성할 수 있도록 할 것입니다. 셋째, 파운데이션 모델과 사후 훈련 방법론을 지속적으로 개선하여 복잡한 작업에서의 성능을 향상시킬 것입니다. 이러한 노력을 통해 오픈소스 대규모 언어 모델은 비공개 최전선 모델과의 격차를 더욱 줄이고, 궁극적으로는 동등하거나 더 나은 성능을 달성할 수 있을 것으로 기대됩니다.
## 부록

### MLA의 MHA 및 MQA 모드

앞서 본문에서 소개한 Multi-Head Latent Attention (MLA) 아키텍처는 훈련과 추론의 서로 다른 단계에서 두 가지 작동 모드를 사용합니다. DeepSeek-V3.1-Terminus의 경우 훈련과 프리필링 단계에서는 Multi-Head Attention (MHA) 모드를 사용하고, 디코딩 단계에서는 Multi-Query Attention (MQA) 모드를 사용합니다.

![MLA의 MHA 모드](https://arxiv.org/html/2512.02556/x7.png)

위 다이어그램은 MLA의 MHA 모드를 보여줍니다. 이 모드에서는 각 어텐션 헤드가 독립적인 쿼리, 키, 값 표현을 사용하여 풍부한 표현력을 제공합니다.

![MLA의 MQA 모드](https://arxiv.org/html/2512.02556/x8.png)

MQA 모드에서는 모든 쿼리 헤드가 공유된 키-값 쌍을 사용하여 메모리 효율성을 극대화합니다. 이러한 두 모드 간의 전환은 저차원 잠재 공간에서의 압축을 통해 구현되며, MHA 모드에서 학습된 표현 능력을 유지하면서도 디코딩 단계에서 메모리 사용량을 크게 줄일 수 있습니다.

### 콜드 스타트 템플릿

추론 능력과 도구 사용 능력을 통합하기 위해 신중하게 설계된 시스템 프롬프트가 사용됩니다. 다음은 각 작업 유형에 대한 대표적인 프롬프트 예시입니다.

**추론 데이터 시스템 프롬프트:**

| 구성 요소     | 내용                                                                                                                                                                                      |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 역할 정의     | You are an expert Python programmer. You will be given a question (problem specification) and will generate a correct Python program that matches the specification and passes all tests. |
| 추론 요구사항 | Please first reason before giving the final answer. The reasoning process enclosed within `<think> </think>`.                                                                             |
| 출력 형식     | The final answer is output after the `</think>` tag.                                                                                                                                      |

이 프롬프트는 모델이 최종 답변에 도달하기 전에 `<think></think>` 태그 내에 추론 과정을 명시적으로 출력하도록 요구합니다.

**에이전트 시스템 프롬프트:**

| 구성 요소 | 내용                                                                                                                                                                                                      |
| --------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 도구 설명 | Use Python interpreter tool to execute Python code. The code will not be shown to the user. This tool should be used for internal reasoning, but not for code that is intended to be visible to the user. |
| 도구 목록 | You have access to the following tools: {TOOL-DESCRIPTIONS}                                                                                                                                               |
| 호출 형식 | Important: ALWAYS adhere to this exact format for tool use: {TOOLCALL-FORMAT}                                                                                                                             |
| 시간 제한 | Python will respond with the output of the execution or time out after 120.0 seconds.                                                                                                                     |

에이전트 프롬프트는 사용 가능한 도구의 설명과 호출 형식을 명시하여, 모델이 도구를 일관되게 사용할 수 있도록 합니다.

**추론 과정에서 도구를 호출하는 에이전트 시스템 프롬프트:**

| 구성 요소   | 내용                                                                                                                                                                                   |
| ----------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 추론 통합   | You may use the Python tool **multiple times** during your reasoning, a.k.a in `<think></think>`, with a maximum of 20 code executions.                                                |
| 실행 전략   | Call the Python tool early in your reasoning to aid in solving the task. Continue reasoning and invoking tools as needed until you reach the final answer.                             |
| 효율성 지침 | To improve efficiency and accuracy, you should prefer code execution over language-based reasoning whenever possible. Keep your reasoning succinct; let the code do the heavy lifting. |
| 출력 제약   | Do NOT invoke any tools in your presented final solution steps.                                                                                                                        |

이 프롬프트는 추론 과정 내에서 최대 20회의 도구 호출을 허용하며, 모델이 언어 기반 추론보다 코드 실행을 우선시하도록 유도합니다.

### 비사고 모드 DeepSeek-V3.2 에이전트 평가

비사고 모드와 사고 모드의 성능 차이를 비교한 결과는 다음과 같습니다.

| 벤치마크 (지표)             | 비사고 모드 | 사고 모드 |
| --------------------------- | ----------- | --------- |
| Terminal Bench 2.0 (Acc)    | 37.1        | 46.4      |
| SWE Verified (Resolved)     | 72.1        | 73.1      |
| SWE Multilingual (Resolved) | 68.9        | 70.2      |
| ToolUse τ²-bench (Pass@1)   | 77.2        | 80.3      |
| MCP-Universe (Success Rate) | 38.6        | 45.9      |
| MCP-Mark (Pass@1)           | 26.5        | 38.0      |
| Tool-Decathlon (Pass@1)     | 25.6        | 35.2      |

Terminal Bench 2.0의 비사고 모드 점수는 Claude Code 프레임워크로 평가되었으며, Terminus 프레임워크를 사용한 경우 39.3점을 기록했습니다. 사고 모드가 일관되게 더 높은 성능을 보이지만, 비사고 모드도 여전히 경쟁력 있는 성능을 유지합니다.

### IOI, ICPC World Final, IMO, CMO 평가 방법

모든 대회에서 모델의 최대 생성 길이는 128K 토큰으로 설정되었으며, 도구나 인터넷 접근은 사용되지 않았습니다. 평가는 각 대회의 시간 제약과 제출 횟수 제한을 엄격하게 준수했습니다.

**IOI 평가**: 공식 대회 규칙에 따라 문제당 최대 50회 제출이 허용되며, 각 제출은 모든 서브태스크에서 달성한 최대 점수로 평가됩니다. 문제당 500개의 후보 솔루션을 샘플링한 후 다단계 필터링 파이프라인을 적용했습니다. 먼저 제공된 샘플 테스트 케이스를 통과하지 못하거나 길이 제약을 초과하는 무효 제출을 제거했습니다. 이후 DeepSeek-V32-Exp 모델을 사용하여 모델이 명시적으로 문제 해결 불가능성을 표시한 샘플을 식별하고 제거했습니다. 남은 유효 후보 중에서 가장 긴 사고 흔적을 가진 50개의 샘플을 최종 제출용으로 선택했습니다.

**ICPC 평가**: 동일한 필터링 방법론을 적용했지만 초기 샘플 크기를 줄여 문제당 32개의 후보 솔루션을 생성하고 동일한 필터링 기준을 적용하여 제출할 샘플을 선택했습니다.

**IMO 및 CMO 평가**: DeepSeekMath-V2에서 사용된 것과 동일한 생성-검증-개선 루프를 사용했습니다. 모델은 완벽한 자체 평가를 달성하거나 최대 수정 횟수에 도달할 때까지 솔루션을 반복적으로 개선합니다.

- - -
### References
* [DeepSeek-V3.2: Pushing the Frontier of Open Large Language Models](https://arxiv.org/pdf/2512.02556v1)
